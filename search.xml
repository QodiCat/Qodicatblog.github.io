<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/2023/12/02/about/index/"/>
      <url>/2023/12/02/about/index/</url>
      
        <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><p>博主: Qodicat<br>AI算法应用爱好者<br>与世界大战三百回合不服输的屠龙少年~<br>喜欢探索美食，以及一切有趣充满活力的事物！<br>爱好跑步、羽毛球、滑板、游泳、读书、看电影、做美食、剪辑funny视频<br>喜欢可爱的小动物~</p><h3 id="a-bit-技能"><a href="#a-bit-技能" class="headerlink" title="a bit 技能"></a>a bit 技能</h3><p>Stable Diffusion,Midjourney等AIGC应用<br>AI算法，包括传统卷积神经网络，Transformer，扩散模型<br>模型微调，模型调参等<br>前端语言开发，嵌入式开发</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><p>云FPGA平台开发<br>星与安卓APP开发<br>Diana-Coding Vscode插件开发<br>社会实践队前端网页开发</p><h3 id="平台账号"><a href="#平台账号" class="headerlink" title="平台账号"></a>平台账号</h3><div style="display: flex;"><span class='btn center cool-2'><a class="button" href='https://github.com/QodiCat' title='Github'><i class='fa-brands fa-github-alt'></i>Github</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://blog.csdn.net/Q52099999?spm=1010.2135.3001.5343' title='CSDN'><i class='fa-brands fa-CSDN'></i>CSDN</a></span></div><h3 id="我喜欢的一些书籍"><a href="#我喜欢的一些书籍" class="headerlink" title="我喜欢的一些书籍"></a>我喜欢的一些书籍</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E9%9D%92%E9%93%9C%E8%91%B5%E8%8A%B1/8891559"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《青铜葵花》</span><span class="desc">温暖了我一个冬天</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E7%A5%9E%E7%A7%98%E5%B2%9B/3094497?fromtitle=%E5%A4%96%E5%9B%BD%E6%96%87%E5%AD%A6%E5%90%8D%E8%91%97%EF%BC%9A%E7%A5%9E%E7%A7%98%E5%B2%9B&fromid=5685499"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《神秘岛》</span><span class="desc">凡尔纳yyds</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%8B%A6%E5%84%BF%E6%B5%81%E6%B5%AA%E8%AE%B0/80000"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《苦儿流浪记》</span><span class="desc">小时候读的印象最深的一本书</span></div></a><a class="site-card" href="https://zhuanlan.zhihu.com/p/150729443"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《撒哈拉的故事》</span><span class="desc">只能说泰裤辣</span></div></a></div><h3 id="我喜欢的一些电影"><a href="#我喜欢的一些电影" class="headerlink" title="我喜欢的一些电影"></a>我喜欢的一些电影</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E/27198"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">三傻大脑宝莱坞</span><span class="desc">打破刻板印象</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%BB%E5%8A%A8%E5%91%98/27212"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">机器人总动员</span><span class="desc">暖心</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E9%A9%AF%E9%BE%99%E9%AB%98%E6%89%8B/10650780?fromModule=disambiguation"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">驯龙高手</span><span class="desc">可爱的宠物？</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E/5358"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">让子弹飞</span><span class="desc">背后暗藏玄机</span></div></a></div><!-- ### 其他<div class="link-group"><div class="tagLink"><a class="link-card" title="项目一" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目一</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目二" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目二</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目三" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目三</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目四" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目四</p><p class="url">http://www.baidu.com</p></div></a></div></div> --><!-- ### 我的游戏<div class="gallery ">              <p><img src="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="王者荣耀"><br><img src="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="和平精英"></p>            </div> --><h3 id="我的相册"><a href="#我的相册" class="headerlink" title="我的相册"></a>我的相册</h3><p>不定时掉落一些回忆</p><div class="tag-plugin post-swiper-container" width="fill"><div class="swiper-wrapper"><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">苏州~金鸡湖畔</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/479da3fd2ffb596b95aa2f411e94ca2.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">微软~Promt大会</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/81723041eb7fc632101661526fed932.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">讯飞星火~开发者会议</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/8d33b15cd9c08a8de1d30a96fe8d6b4.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">探索的好吃的！</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20231203-223736.jpg"></a></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div><h3 id="未来进行时"><a href="#未来进行时" class="headerlink" title="未来进行时"></a>未来进行时</h3><p>大学生活正在向前，进度条已经百分之60啦，冲冲冲！！！</p><div style="display: grid;  grid-template-columns: 50% 50%;  grid-template-rows: 30px 30px;  grid-column-gap: 20px"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-success"  style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"><p>完成时</p></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）设备管理</title>
      <link href="/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><h1 id="1-设备管理概述"><a href="#1-设备管理概述" class="headerlink" title="1 设备管理概述"></a>1 设备管理概述</h1><h2 id="1-1-系统总线结构"><a href="#1-1-系统总线结构" class="headerlink" title="1.1 系统总线结构"></a>1.1 系统总线结构</h2><p>系统总线上传输的信息有——数据 地址 其他控制状态定时信号</p><p>系统总线其实有几类</p><p>如下图 CPU总线 存储器总线 和I&#x2F;O总线</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="CPU总线 存储总线 I/O总线"></p><p>其中北桥芯片组把处理器和存储器分成了两个总线</p><p>南桥芯片连接在I&#x2F;O总线上</p><p>I&#x2F;O总线上连着众多的I&#x2F;O设备</p><p>当然I&#x2F;O总线和I&#x2F;O设备之间通过设备管理器进行连接控制</p><p>那么设备管理器的结构是怎样的呢？</p><h2 id="1-2-设备控制器通用结构"><a href="#1-2-设备控制器通用结构" class="headerlink" title="1.2 设备控制器通用结构"></a>1.2 设备控制器通用结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设备控制器结构"></p><p>控制不同的外设需要不同的设备控制器，将系统总线和设备侧的接口连在一起</p><h2 id="1-3-I-O设备的模型"><a href="#1-3-I-O设备的模型" class="headerlink" title="1.3 I&#x2F;O设备的模型"></a>1.3 I&#x2F;O设备的模型</h2><p>对于外部设备而言，他们的设备如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="外部设备通用模型"></p><h1 id="2-I-O端口"><a href="#2-I-O端口" class="headerlink" title="2 I&#x2F;O端口"></a>2 I&#x2F;O端口</h1><p>I&#x2F;O设备中非常重要的一部分就是外设寄存器（也叫做I&#x2F;O端口，下文我们都叫做I&#x2F;O端口了）（存储着设备状态，数据等）</p><p>控制需要了解外设寄存器值，读取数据也是从相应的寄存器值读取</p><p>I&#x2F;O端口通常包括：控制寄存器、状态寄存器和数据寄存器三大类</p><p>所以这里就牵扯出一个问题，CPU下达指令读或写某个I&#x2F;O端口（寄存器），需要知道那个寄存器在哪里，也就是说寄存器的地址是什么，这就涉及到I&#x2F;O端口的编址以及寻址</p><h2 id="2-1-寻址方式"><a href="#2-1-寻址方式" class="headerlink" title="2.1 寻址方式"></a>2.1 寻址方式</h2><p><strong>统一编址方式（内存映射方式）</strong></p><p>与主存空间统一编址，主存单元和I&#x2F;O端口在同一个地址空间</p><p>外设与内存统一的编址方式，优点是编程简单，因为可以像访问内存一样去访问外设。缺点是IO也占用CPU的寻址空间。</p><p><strong>独立编址方式（特殊I&#x2F;O指令方式）</strong></p><p>单独编号，不和主存单元一起编，使成为一个独立的I&#x2F;O地址空间，例如Intel处理器</p><p>而独立编址的方式，优点是不占用CPU的寻址空间，但是CPU的构造比较复杂。(因为额外的CPU指令需要对CPU进行额外的设计处理)。</p><h1 id="3-驱动程序"><a href="#3-驱动程序" class="headerlink" title="3 驱动程序"></a>3 驱动程序</h1><p>控制外设进行输入输出的底层I&#x2F;O软件是驱动程序，由设备生产商制作，包括 设备控制器中有哪些用户可以访问的寄存器、控制状态寄存器的每一位的含义，通信协议等等</p><p>驱动程序通过访问 I&#x2F;O端口控制外设进行I&#x2F;O</p><p>​比如 读取控制命令送到控制寄存器来启动外设工作</p><p>​读取状态寄存器了解外设和设备控制器的状态</p><p>​访问数据缓冲寄存器进行数据的输入和输出</p><p>实现这种访问操作是通过I&#x2F;O操作完成的，他是一种特权指令</p><h1 id="4-基本I-O控制方式"><a href="#4-基本I-O控制方式" class="headerlink" title="4 基本I&#x2F;O控制方式"></a>4 基本I&#x2F;O控制方式</h1><p>有如下四种</p><h2 id="4-1-程序直接控制"><a href="#4-1-程序直接控制" class="headerlink" title="4.1 程序直接控制"></a>4.1 程序直接控制</h2><p>​程序查询I&#x2F;O方式</p><p><strong>原理</strong> 由CPU负责直接控制I&#x2F;O操作，不涉及中断或DMA（Direct Memory Access）。</p><p><strong>方法</strong></p><p>计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字， CPU 需要对外设状态进行循环检查，直到确定该字已经在I&#x2F;0 控制器的数据寄存器中</p><p><strong>优点</strong> 简单、易于实现。</p><p><strong>缺点</strong></p><p>在程序直接控制方式中，由于CPU 的高速性和I&#x2F;0设备的低速性，致使CPU 的绝大部分时间都处于等待I&#x2F;0 设备完成数据I&#x2F;0 的循环测试中，造成了<strong>CPU 资源的极大浪费</strong>。在该方式中， CPU 之所以要不断地测试I&#x2F;0 设备的状态，就是因为在CPU 中未采用中断机构，使I&#x2F;0 设备无法向CPU报告它已完成了一个字符的输入操作。</p><h2 id="4-2-中断I-O方式"><a href="#4-2-中断I-O方式" class="headerlink" title="4.2 中断I&#x2F;O方式"></a>4.2 中断I&#x2F;O方式</h2><p>​中断I&#x2F;O方式</p><p><strong>原理</strong> 设备在完成操作后发出中断信号，通知CPU进行数据传输。</p><p><strong>方法</strong></p><p>中断驱动方式的思想是，允许I&#x2F;0 设备主动打断CPU 的运行并请求服务，从而“解放”CPU, 使得其向I&#x2F;0 控制器发送读命令后可以继续做其他有用的工作。</p><p><strong>优点：</strong> 提高CPU利用率，减少了对CPU的占用。</p><p><strong>缺点</strong></p><p>中断方式在一些情况下可以提高CPU利用率，但在一些情况下，字符式设备，其中断频率太高，来回切换的话也会耗费处理机较多时间</p><p>核心是因为什么？</p><p>是因为上面两种方式都需要经过CPU处理？</p><p>什么叫经过CPU处理</p><p>是外设输入数据流大概是这样的： 【外围设备-&gt;I&#x2F;O控制器的数据寄存器-&gt;CPU寄存器-&gt;存储器】，这就叫经过CPU，或者说传输数据的过程需要CPU的干预</p><p>于是引出了下面的DMA(直接在I&#x2F;O设备和内存之间建立数据通路)</p><h2 id="4-3-DMA方式"><a href="#4-3-DMA方式" class="headerlink" title="4.3 DMA方式"></a>4.3 DMA方式</h2><p>磁盘等高速外设设备所用的方式</p><p><strong>原理</strong></p><p>​基本思想 在高速外设和主存间直接传送数据</p><p>​由专门硬件<strong>（即DMA控制器）</strong>控制总线进行传输，注意这里不是CPU了</p><p><strong>方式</strong></p><ol><li>基本单位是数据块（前面是一个字）。</li><li>所传送的数据，是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU 干预，整块数据的传送是在DMA控制器的控制下完成的。</li></ol><p><strong>优点</strong> 大大减轻了CPU的负担，提高了数据传输速率。</p><p><strong>缺点</strong> 需要额外的硬件支持，复杂度较高。</p><p>如何进一步提高资源利用率呢？当然是请更牛逼的通道，将苦逼的CPU尽可能的从累活中解放出来。</p><h2 id="4-4-I-O通道控制方式"><a href="#4-4-I-O通道控制方式" class="headerlink" title="4.4 I&#x2F;O通道控制方式"></a>4.4 I&#x2F;O通道控制方式</h2><p><strong>原理</strong> 使用专门的I&#x2F;O通道控制器，它独立于CPU和主存储器，负责管理多个设备的I&#x2F;O操作</p><p><strong>方式</strong></p><p>I&#x2F;0 通道是指专门负责输入／输出的处理机。I&#x2F;O通道方式是DMA方式的发展，它可以进一步 减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I&#x2F;0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p><p><strong>优点：</strong> 高度并行化的数据传输，减少了对CPU的占用。</p><p><strong>缺点：</strong> 需要更复杂的硬件支持，成本较高。</p><h1 id="5-I-O管理中的重要思想"><a href="#5-I-O管理中的重要思想" class="headerlink" title="5 I&#x2F;O管理中的重要思想"></a>5 I&#x2F;O管理中的重要思想</h1><h2 id="5-1-设备独立性"><a href="#5-1-设备独立性" class="headerlink" title="5.1 设备独立性"></a>5.1 设备独立性</h2><p>该思想旨在使应用程序与具体的I&#x2F;O设备解耦，从而提高系统的灵活性、可移植性和可维护性。</p><h2 id="5-2-SPOOLing技术"><a href="#5-2-SPOOLing技术" class="headerlink" title="5.2 SPOOLing技术"></a>5.2 SPOOLing技术</h2><p>​即外围设备同时联机操作，又称作假脱机操作</p><p>什么是<strong>脱机I&#x2F;O</strong>？</p><p>​脱机I&#x2F;O  目的是为了解决CPU和I&#x2F;O速度不匹配的问题，输入由一台低挡计算机做中介</p><p>什么是<strong>假脱机</strong>？</p><p>​即模拟实现上面的脱机i&#x2F;O</p><p><strong>实现方法</strong></p><p>​OS利用两个进程分别模拟脱机I&#x2F;O时外围机的功能</p><p>​其中一个进程负责将输入设备的数据传送到磁盘，另一个进程负责将数据从磁盘送到输出设备</p><p><strong>组成</strong></p><p>​1 输入输出井</p><p>​2 预输入进程和缓输出进程</p><h2 id="5-3-I-O软件的多层模型"><a href="#5-3-I-O软件的多层模型" class="headerlink" title="5.3 I&#x2F;O软件的多层模型"></a>5.3 I&#x2F;O软件的多层模型</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="I/O软件的多层模型"></p><p>1 用户进程层——执行I&#x2F;O系统调用，对I&#x2F;O数据进行格式化(如将十进制数转换为ASCLL码字符串以便输出)</p><p>2 独立于设备的软件——实现设备的命名，分配，数据的缓冲，设备的保护，提供下层的统一接口，检查用户是否有权使用</p><p>3 设备驱动程序，与设备有关的代码，向设备控制器发送命令，检测设备的执行状态</p><p>4 中断处理程序，负责I&#x2F;O完成时，唤醒设备驱动程序的进程，进行中断处理</p><p>5 硬件层 实现物联I&#x2F;O操作</p><h1 id="6-磁盘I-O"><a href="#6-磁盘I-O" class="headerlink" title="6 磁盘I&#x2F;O"></a>6 磁盘I&#x2F;O</h1><p>磁盘一般分为固定结构和移动头磁盘两大类</p><p>固定头磁盘——每个盘面的每条磁道都有一个读写磁头，固定头磁盘各个磁头可并行读写，成本高</p><p>移动头磁道——每个盘面只有一个读写磁头</p><h2 id="6-1-磁盘调度算法"><a href="#6-1-磁盘调度算法" class="headerlink" title="6.1 磁盘调度算法"></a>6.1 磁盘调度算法</h2><p>目标 使得磁盘平均寻道时间最短 </p><h3 id="6-1-1-先来先服务-FCFS"><a href="#6-1-1-先来先服务-FCFS" class="headerlink" title="6.1.1 先来先服务 FCFS"></a>6.1.1 先来先服务 FCFS</h3><p>按请求访问磁盘的先后次序进行调度</p><h3 id="6-1-2-最短寻道时间优先-SSTF"><a href="#6-1-2-最短寻道时间优先-SSTF" class="headerlink" title="6.1.2 最短寻道时间优先 SSTF"></a>6.1.2 最短寻道时间优先 SSTF</h3><p>选择处理与当前磁头距离最近的磁道请求，以减少寻道时间</p><h3 id="6-1-3-扫描算法-电梯调度算法-SCAN"><a href="#6-1-3-扫描算法-电梯调度算法-SCAN" class="headerlink" title="6.1.3 扫描算法 电梯调度算法 SCAN"></a>6.1.3 扫描算法 电梯调度算法 SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，再反方向</p><p>（可以联想电梯哦！！）</p><h3 id="6-1-3-循环扫描-C-SCAN"><a href="#6-1-3-循环扫描-C-SCAN" class="headerlink" title="6.1.3  循环扫描 C-SCAN"></a>6.1.3  循环扫描 C-SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，不反方向直接回到最后一个磁道，开始扫描</p><p>（可以联想循环结构哦！第一次for(i&#x3D;0;i&lt;&#x3D;10;i++) ，i从0开始，到10 下次执行还是从0开始）</p><p>SSFT、SCAN、C-SCAN都存在“饿死现象”</p><p>即当一个或多个进程反复请求某个磁道I&#x2F;O，垄断了整个磁盘，其他磁道得不到访问</p><h3 id="6-1-4-N-Step-SCAN"><a href="#6-1-4-N-Step-SCAN" class="headerlink" title="6.1.4 N-Step-SCAN"></a>6.1.4 N-Step-SCAN</h3><p>将磁盘请求队列分成若干个长度为N的子队列</p><p>每一次SCAN处理一个子队列</p><p>磁盘调度将按FCFS算法依次处理这些子队列，而每处理一个子队列时，又是按照SCAN算法，当一个队列处理完后，再处理其他队列。当正在处理某子队列时，如果又出现新的磁盘I&#x2F;O请求，则将其放入其他队列中（这时候，因为不在同一队列里了，所以就不能老是执行一个进程的请求了！！！）</p><h3 id="6-1-5-FSCAN"><a href="#6-1-5-FSCAN" class="headerlink" title="6.1.5 FSCAN"></a>6.1.5 FSCAN</h3><p>使用2个子队列</p><p>当扫描开始时，所有请求都在一个子队列，另一个子队列为空，扫描过程中，所有新到的请求加入另一个子队列中，使得新请求服务延迟老请求处理完后（这样也可以避免饿死现象）</p><h2 id="6-2-其他磁盘I-O性能的改善"><a href="#6-2-其他磁盘I-O性能的改善" class="headerlink" title="6.2 其他磁盘I&#x2F;O性能的改善"></a>6.2 其他磁盘I&#x2F;O性能的改善</h2><p>高速缓存</p><p>合理分配磁盘空间</p><p>把有可能顺序访问的放到一块</p><p>提前读，延迟写，周期性的成簇写回</p><p><strong>例题</strong></p><p>尝试给出一种能够满足下列要求的I&#x2F;O设备管理设计方案：</p><p>1 应用程序在访问设备时候，不需要关心设备的物理特性</p><p>2 应用程序申请使用某类设备时，不需要指定具体的物理设备</p><p>3 应用程序可以通过文件系统访问设备</p><p>设计方案：</p><p>为满足上述要求，可以设计一个综合管理系统，其设计思路如下：</p><p>1 <strong>采用分层的I&#x2F;O软件模型</strong>  多层处理，如用户层，设备驱动程序等待。进行设备抽象，将不同类型的设备进行抽象，屏蔽设备的具体物理特性。通过设备抽象，应用程序可以以统一的方式访问各种设备，而无需关心设备的底层实现。</p><p> 2 <strong>设备分组</strong>：将相同类型的设备进行分组，并为每个设备组分配一个唯一的标识符。应用程序在申请使用某类设备时，只需指定设备组的标识符，而无需指定具体的物理设备。</p><p>3  <strong>权限控制</strong>：设计合适的权限控制机制，确保应用程序只能访问其被授权的设备组和设备文件，以保护系统的安全性和数据的机密性。</p><p>数据结构</p><p>1 用类和结构定义抽象层，包括设备的通用属性，操作方法，事件等</p><p>2 用哈希表或映射存储设备组的标识符和相应的设备类型</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）文件系统</title>
      <link href="/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="文件系统上总览图"></p><h1 id="1-文件系统概述"><a href="#1-文件系统概述" class="headerlink" title="1 文件系统概述"></a>1 文件系统概述</h1><p><strong>为什么引入文件系统</strong></p><p>​长期保存（大量的）数据</p><p>​方便用户使用</p><p>文件是有名字的记录在外存中的一组有逻辑意义的数据项序列</p><p><strong>什么是文件系统</strong></p><p>文件系统是OS中用来管理文件的那一部分软件</p><p><strong>文件系统功能</strong></p><p>统一管理文件的存储空间，实施存储空间的分配与回收<br>实现文件信息的共享，提供文件的保护和保密措施<br>实现文件的按名访问<br>     访问的透明性：用户不关心文件的物理位置和存储结构<br>向用户提供一个方便使用的接口，提供对文件系统操作的命令<br>提供与I&#x2F;O的统一接口</p><p><strong>文件分类：</strong></p><p>Unix系统将文件分为3类:<br>普通文件(regular)：ASCII或二进制文件<br>目录文件(directory)<br>特殊文件：设备文件，管道，套接字（socket），符号链接等</p><h1 id="2-文件的结构与存取方式"><a href="#2-文件的结构与存取方式" class="headerlink" title="2 文件的结构与存取方式"></a>2 文件的结构与存取方式</h1><p>文件是存在磁盘上的</p><h2 id="2-1-磁盘"><a href="#2-1-磁盘" class="headerlink" title="2.1 磁盘"></a>2.1 磁盘</h2><p>磁盘有扇片  磁道 扇区</p><p>扇区——磁盘最小可寻址单元</p><p>簇——存储块，固定数量的扇区</p><ul><li>平均存取时间</li></ul><p>​T&#x3D;平均寻道时间+平均旋转等待时间+数据传输时间（有时候忽略不计）</p><p>​其中</p><p>​平均寻道时间——磁头寻找到指定磁道所需要的平均时间（大约5ms）</p><p>​平均旋转等待时间——指定扇区旋转到磁头下方所需要的平均时间（约4-6ms）</p><ul><li>磁盘响应时间&#x3D;平均存取时间+排队时间+控制器时间</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算例题"></p><p>注意想明白这里的0.5的来源</p><h2 id="2-2-文件的物理结构"><a href="#2-2-文件的物理结构" class="headerlink" title="2.2 文件的物理结构"></a>2.2 文件的物理结构</h2><h3 id="2-2-1-连续结构"><a href="#2-2-1-连续结构" class="headerlink" title="2.2.1 连续结构"></a>2.2.1 连续结构</h3><p>文件的数据存放在若干连续的物理块中</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连续结构"></p><p><strong>优点：</strong></p><p>简单，只要记住首块的地址和文件长度即可<br> 支持顺序存取和随机存取<br> 顺序存取速度快<br> 所需的磁盘寻道时间最少</p><p><strong>缺点：</strong></p><p>不利于文件的动态增长<br>    若预留空间：浪费，而且预先不知道文件的最大长度<br>    否则需要重新分配和移动<br>不利于文件内容的插入和删除<br>存在外部碎片问题</p><h3 id="2-2-2-链式结构"><a href="#2-2-2-链式结构" class="headerlink" title="2.2.2 链式结构"></a>2.2.2 链式结构</h3><p> 一个文件的数据存放在若干不连续的物理块中，各块之间通过指针连接，<br> 每个物理块指向下一个物理块</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="链式结构"></p><p><strong>优点</strong></p><p>提高了磁盘空间利用率<br> 不存在外部碎片问题<br> 有利于文件的插入和删除<br> 有利于文件的动态扩充</p><p><strong>缺点：</strong><br>随机存取相当缓慢<br>需要更多的寻道时间<br>链接指针占用一定的空间</p><p>改进变形</p><p>FAT表</p><p>文件分配表FAT的一种实现：<br>磁盘的每个分区包含一个FAT，分区中的每个盘块在其中占有1项（以块号为索引），指出文件中下一块的块号。<br>在目录项中包含文件首块的块号。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="FAT表图示"></p><h3 id="2-2-3-索引结构"><a href="#2-2-3-索引结构" class="headerlink" title="2.2.3 索引结构"></a>2.2.3 索引结构</h3><p>一个文件的数据存放在若干不连续的物理块中，系统为每个文件建立一个专用数据结构–索引表。<br>索引表存放逻辑块号与物理块号的对应关系<br>一个索引表就是磁盘块地址（块号）数组，其中第i个条目存放的是逻辑块号i对应的物理块号<br>文件目录的目录项中指出索引表的物理地址</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="索引结构"></p><p><strong>优点</strong>：保持了链接结构的优点，又避免了其缺点<br> 既能顺序存取，又能随机存取<br> 能满足文件动态增长、插入、删除的要求<br> 能充分利用外存空间<br><strong>缺点</strong>：<br>索引表本身带来了系统开销</p><p>UNIX文件系统采用的是多级混合索引结构。<br>每个文件的索引表为13个索引项<br>最前面10项直接登记存放文件数据的物理块号（直接寻址）<br>如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址<br>UNIX中采用了三级索引结构后，文件最大可达16M个物理块</p><p>索引表的组织方式</p><p>如果文件很大，索引表较大，超过了一个物理块，就必须考虑索引表的组织方式，即怎么去存储索引表</p><p>索引表的组织方式:<br>（1）连续方式<br>    索引表占用多个连续的盘块<br>（2）链接方式<br>    索引表按照链式结构组织，占用多个不连续的盘块<br>（3）多级索引（多重索引）<br>  例如，二级索引：将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中<br>  此外，还有三级索引等。</p><p>题目</p><p>设每个盘块4kB，每个盘块号4B，则采用3次间址可表示的文件最大长度为 [4T] B。</p><h2 id="2-3-文件的存取方式"><a href="#2-3-文件的存取方式" class="headerlink" title="2.3 文件的存取方式"></a>2.3 文件的存取方式</h2><p>主要有顺序存取和随机存取两种。<br>1 顺序存取<br>  对文件中的数据按逻辑顺序进行读&#x2F;写的存取方式<br> 2 随机存取<br>  对文件中的数据按任意顺序进行读&#x2F;写的存取方式<br> 3 按键（key）存取：如DBMS</p><p>还与介质有关</p><h1 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3 文件目录"></a>3 文件目录</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>几个基本的概念</p><p><strong>1 文件控制块</strong></p><p>文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有相关信息（文件属性）</p><p>基本信息：文件的名字、地址（起始物理块号）、长度、结构（逻辑结构、物理结构）、类型<br>存取控制信息：文件属主（owner）、存取权限或口令<br>使用信息：共享计数，文件的建立、修改日期等</p><p><strong>2 文件目录</strong></p><p> 把所有的FCB组织在一起，就构成了文件目录<br>  即文件控制块的有序集合</p><p><strong>3  目录项</strong><br>  构成文件目录的项目（目录项就是FCB）</p><p><strong>4 目录文件</strong></p><p>为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，<br> 这个文件就叫目录文件<br> 目录主要是为了系统快速实现“按名访问”而引入的，<br> 查目录是文件系统最频繁的操作，因此目录的合理组织很重要</p><h2 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h2><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>为所有文件建立一个目录文件（组成一线性表）<br>优点：简单，易实现</p><p>缺点：<br> 限制了用户对文件的命名（容易出现“命名冲突”）<br> 顺序检索文件时，平均检索时间长<br> 不利于对文件的共享</p><h3 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h3><p>对二级目录简单扩充可得三级或三级以上的多级目录结构，<br>即允许每一级目录中的FCB要么指向文件，要么指向下一级子目录。<br>这是当今主流OS普遍采用的目录结构<br>优点：<br>    层次结构清晰，便于管理和保护；有利于文件分类；<br>    能较好地避免重名问题；提高了文件检索速度；有利于访问权限的控制</p><h2 id="3-3-文件目录检索"><a href="#3-3-文件目录检索" class="headerlink" title="3.3 文件目录检索"></a>3.3 文件目录检索</h2><p>访问文件时，必须首先确定<strong>读写文件的地址</strong>，需要下列2步：<br>（1）目录检索：根据文件名，查目录，确定文件的起始地址。<br>（2）文件寻址：确定所要访问文件内容的起始位置（地址）。</p><h3 id="3-3-1-目录检索"><a href="#3-3-1-目录检索" class="headerlink" title="3.3.1 目录检索"></a>3.3.1 目录检索</h3><p>文件的“按名存取”是通过查目录实现的，系统按照文件的路径名检索<br>基本的目录检索技术主要有：<br>线性检索法<br>Hash方法<br>为了加快目录检索，许多系统引入当前目录（工作目录）、相对路径名等。</p><h3 id="文件寻址"><a href="#文件寻址" class="headerlink" title="文件寻址"></a>文件寻址</h3><p>根据目录项（FCB）中记录的文件物理地址等信息，<br>求出文件的任意记录或字节在存取介质上的地址<br>文件寻址与文件的物理结构和逻辑结构以及设备的物理特性有关<br>文件的内容是以块为单位存储的。<br>但存取文件时，对于记录式文件，是以逻辑记录为单位提出存取要求的，因此，<br>存储介质上的物理块长度与逻辑记录的长度是否匹配直接影响到对文件的寻址</p><h2 id="3-4-文件目录的实现"><a href="#3-4-文件目录的实现" class="headerlink" title="3.4 文件目录的实现"></a>3.4 文件目录的实现</h2><p>当查找文件时候，需要依次将存放目录的物理块装入内存，逐一比较文件名，直到找到为止</p><p>例如：文件说明占128B，每块512B，则每块可存放4个目录项</p><p>设目录文件占用的盘块数是N个，则要找到一个目录项，<br>平均需要读入多少个盘块？(N+1)&#x2F;2块</p><p>把文件说明信息（FCB）都放在目录项中的缺点：<br>  查找文件缓慢，因为目录项较大<br>  文件目录平常放在外存中，当文件很多时，可能占用大量的外存物理块</p><p>但实际上我们文件检索只需要文件名，不需要那么多其他的信息</p><p>所以我们将文件说明分成两部分   把FCB分成两部分</p><p>1 符号目录项——包括文件名，文件号</p><p>2 基本目录项——除文件名以外的所有信息</p><p>目录项分解法的典型实现</p><p>1 符号文件目录+基本文件目录</p><p>2 目录项 +I 节点</p><p>Unix&#x2F;Linux采用此方法，它把符号目录项称为目录项，而把基本目录项称为I节点（Index node，索引节点），这样，目录项中的文件号就是I节点号。</p><p>举例一个查找过程</p><p>一个文件存在根目录下的wang目录下，若获得这个文件的I结点号，需要读几个磁盘物理块</p><p>注意 I节点只存储当前目录或者文件的信息！！！</p><p>I节点存的物理块号（如果是目录的话，就是目录项的地址，如果是文件的话，则是文件的首地址）！！！</p><p>首先根据根目录的I节点号以及内存中的I节点与物理块号的对应关系，可以知道根目录I节点的地址，去读这个地址的内容（第一次读物理块读取），即是获得了根目录的目录项的地址，去读根目录的目录项（第二次物理块读取）可以知道wang对应的I节点物理地址，读wang的I节点地址内容（第三次读取）可以知道wang的目录项地址，读wang目录项地址就可以获得文件a.c的I节点号（第四次读取）</p><p>如果是索引的话 获得的地址不是物理块地址，而是索引表地址，所以需要每一个获取地址都增加一次，总共六次</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231126210111722"></p><h1 id="4-空闲存储空间的管理"><a href="#4-空闲存储空间的管理" class="headerlink" title="4 空闲存储空间的管理"></a>4 空闲存储空间的管理</h1><h2 id="4-1-空闲区表"><a href="#4-1-空闲区表" class="headerlink" title="4.1 空闲区表"></a>4.1 空闲区表</h2><p>将所有空闲区记录在一个表中。<br>    适合连续文件的外存分配与回收。如今很少用</p><h2 id="4-2-空闲块链"><a href="#4-2-空闲块链" class="headerlink" title="4.2 空闲块链"></a>4.2 空闲块链</h2><p>把所有空闲块链成一个链，适合离散分配</p><p>扩展：<br>①不断地适度增加块大小<br>    从最早的512B 1KB  2KB  4KB  8KB  16KB  32KB  64KB。<br>②成组链接法<br>  链上每个节点记录1组空闲块。适合大型文件系统，分配、释放快，<br>  链占用空间少（除首组外均隐藏在空闲块中）。UNIX用之</p><p>成组连接法</p><h2 id="4-3-位图"><a href="#4-3-位图" class="headerlink" title="4.3 位图"></a>4.3 位图</h2><p>用一串二进制位反映磁盘空间的分配情况，每个物理块对应1位，已分配的物理块为1，否则为0<br>申请物理块时，可以在位图中查找为0的位，返回对应的物理块号<br>归还时，将对应位设置为0<br>描述能力强，适合各种物理结构</p><h1 id="5-文件的使用"><a href="#5-文件的使用" class="headerlink" title="5 文件的使用"></a>5 文件的使用</h1><p>为方便用户使用文件，文件系统提供对文件的各种操作，<br>使用的形式包括系统调用或命令<br> ① 提供设置和修改用户对文件访问权限的操作<br> ② 提供建立、修改、删除目录的操作<br> ③ 提供文件共享、设置访问路径的操作<br> ④ 提供创建、打开、读、写、关闭、删除文件等操作<br>其中，最基本的操作是：打开、关闭、读、写文件等</p><p>为什么要 打开&#x2F;关闭文件呢</p><p>open：把文件说明信息（FCB）装入内存，便于以后的快速访问。<br>（1）根据指定的文件路径名，查目录，找到相应文件的目录项，检查权限；<br>（2）将文件说明信息装入内存；<br>（3）分配一个文件id（整数）。后面通过该id实施对该文件的操作。</p><p>close：<br> （1）释放文件说明信息所占的内存空间；<br> （2）把文件缓冲区中已修改的内容写回文件。<br> 很多系统限制进程打开文件的个数，用户尽可能要关闭不再使用的文件。</p><p>打开文件会在内存建立文件的描述信息，记录文件的当前指针，有助于提高文件的访问速度与灵活性。</p><p>关闭会释放文件缓冲区，将已修改的内容写盘，释放文件描述信息所占的内存空间。若不关闭文件，则内存空间被浪费，甚至可能会使修改的内容丢失。</p><h1 id="6-文件共享"><a href="#6-文件共享" class="headerlink" title="6 文件共享"></a>6 文件共享</h1><p>文件共享：一个文件被多个用户或进程使用<br>共享的目的：<br>节省时间和存储空间，减少用户工作量<br>进程间通过文件交换信息</p><h2 id="6-1-普通的文件共享方法"><a href="#6-1-普通的文件共享方法" class="headerlink" title="6.1 普通的文件共享方法"></a>6.1 普通的文件共享方法</h2><h3 id="6-1-1-按路径名访问共享文件"><a href="#6-1-1-按路径名访问共享文件" class="headerlink" title="6.1.1 按路径名访问共享文件"></a>6.1.1 按路径名访问共享文件</h3><p>  实现简单，不需要建立另外的目录项<br>  但路径名可能长，检索较慢</p><h3 id="6-1-2-链接法"><a href="#6-1-2-链接法" class="headerlink" title="6.1.2 链接法"></a>6.1.2 链接法</h3><p>在相应目录项之间建立链接。即一个目录项中含有指向另一个目录项的指针。<br> 实现方法：<br>  在目录项中设置一个“链接属性”，<br>  表示目录项中的“物理地址”是指向另一目录项的指针。<br>  同时，在共享文件的目录项中包含“用户计数”。</p><h3 id="6-1-3-基本文件目录BFD"><a href="#6-1-3-基本文件目录BFD" class="headerlink" title="6.1.3 基本文件目录BFD"></a>6.1.3 基本文件目录BFD</h3><p>整个文件系统有1个基本文件目录BFD：<br>    每个文件（及目录）有1个目录项，包含系统赋予的唯一标识符ID（整数）<br>    以及其他的文件说明信息<br>每个目录有1个符号文件目录SFD：除了ID &#x3D; 0，1，2外,<br>     每个目录项仅包含文件名和ID<br>系统把ID &#x3D; 0，1，2的目录项分别作为BFD、FFD、MFD的标识符<br>共享方法：<br>     若一个用户想共享另一用户的文件，只需在自己的目录文件中增加一个目录项，填上自己起的文件名和该共享文件的唯一ID即可。如ID &#x3D; 6的文件。  </p><h2 id="6-2-基于I节点的文件共享方法（Unix采用）"><a href="#6-2-基于I节点的文件共享方法（Unix采用）" class="headerlink" title="6.2 基于I节点的文件共享方法（Unix采用）"></a>6.2 基于I节点的文件共享方法（Unix采用）</h2><h3 id="6-2-1-硬链接"><a href="#6-2-1-硬链接" class="headerlink" title="6.2.1 硬链接"></a>6.2.1 硬链接</h3><h3 id="6-2-3-符号链接"><a href="#6-2-3-符号链接" class="headerlink" title="6.2.3 符号链接"></a>6.2.3 符号链接</h3><p>在Windows中叫做 快捷方式</p><h1 id="7-文件保护"><a href="#7-文件保护" class="headerlink" title="7 文件保护"></a>7 文件保护</h1><p>主要涉及文件存取控制</p><ol><li><p>存取控制矩阵<br> 给出每个用户对每个文件的访问权限。<br> 一维是所有用户，另一维是所有文件，<br> 对应的矩阵元素是用户对文件的访问权限。<br> 例如，访问操作分为：<br> 读操作（r）<br> 写操作（w）<br> 执行操作（x）<br> 不能执行任何操作（-）<br> 当用户和文件较多时，很庞大。</p></li><li><p>存取控制表（Access Control List，ACL）<br> 每个文件一张ACL，将用户分类，规定每类用户的访问权限。<br> 例如，Unix&#x2F;Linux将用户分类为：<br> 文件主（owner）<br> 文件主的同组用户（group）<br> 其他用户（other）</p></li><li><p>存取权限表（Capability List，CL）<br> 每个用户一张CL，规定对每个文件的访问权限。</p></li><li><p>口令<br> 用户创建文件时，设置一个口令，放在文件目录中。</p></li><li><p>密码<br> 写入时加密，读出时解密。</p></li></ol><p>假定两个用户共享一个文件系统，用户A有文件a，b，e，f ，用户B有文件c，d，e，f。用户A的b和用户B的d是同一个文件。用户A的e和用户B的e不是同一个文件，用户A的f和用户B的f是同一个文件。拟定一个文件组织方案，使得A，B两个用户能够共享该文件系统而不会造成混乱</p><p>答</p><p>为了确保用户A和用户B能够共享文件系统而不会造成混乱，可以采用以下文件组织方案：</p><ol><li><strong>首先创建两个用户目录</strong>：为每个用户创建一个独立的目录，目录A和目录B。这样，用户A和用户B的文件可以分别存储在各自的目录中，避免混淆，对于用户A的e和用户B的e不是同一个文件，则可以将它们分别存放在各自的目录中，因为它们不需要共享</li><li><strong>共享文件存放目录</strong>：对于文件f，创建一个共享文件存放目录，这确保了用户A和用户B可以共同访问和修改这些共享文件。</li><li><strong>建立符号链接</strong>：对于用户A的b和用户B的d是同一个文件，则可以在用户A的目录中创建一个符号链接，指向用户B的文件d。这样，用户A可以访问和操作这个文件，同时避免重复存储。</li></ol><p>通过以上的文件组织方案，用户A和用户B可以共享文件系统，各自管理自己的文件，并且能够访问和修改共享文件，同时避免重名文件和混淆。这样可以确保文件系统的整体有序性和可维护性。</p><p>已知某文件系统采用多级目录结构，逻辑块和物理块大小均为1KB，目录当做文件，采用目录项+I结点的方式。假定要读取文件&#x2F;a&#x2F;b&#x2F;c.dat的第10600-10900个字节，针对连续结构，基本链式结构，FAT和单级索引结构这四种情况，回答下列问题</p><p>1 给出读盘过程</p><p>2 给出读盘次数（如果有必要，可以对本题未给出的条件做出合理假设）</p><ol><li>读盘过程：</li></ol><ul><li><p>连续结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到其起始逻辑块号。然后根据逻辑块号和文件系统的块映射关系，直接读取对应的物理块</p></li><li><p>基本链式结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，逐级跳转到链式结构中的下一个块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>FAT（文件分配表）结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据FAT表的信息，依次读取块链中的物理块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>单级索引结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据单级索引指向的块，再根据块内的索引信息找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li></ul><ol start="2"><li>读盘次数：</li></ol><ul><li><p>连续结构：只需进行一次读取，因为连续结构中的数据是连续存储的。</p></li><li><p>基本链式结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要跳转到下一个块。</p></li><li><p>FAT结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据FAT表的信息找到下一个块。</p></li><li><p>单级索引结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据索引结构中的信息找到下一个块。</p></li></ul><p>需要注意的是，以上的读盘次数可能还会受到文件系统的缓存策略等因素的影响，这里只是基于给出的情况做出的合理估计。</p><p>为某一个应用场景设计一个文件系统，所设计的文件系统不能建立在已有的文件系统的基础上。具体要求如下：</p><p>1 举一个应用场景的例子，说明该场景下对文件系统的具体需求</p><p>2 针对具体需求给出一种文件系统的设计方案</p><p>3 对你的设计方案进行评价</p><ol><li><p>应用场景示例：智慧农业控制嵌入式系统。在智慧农业系统中，用户可以通过手机或者智能音箱等设备来控制农场中的各种设备，如灯光、温度、安防等。在这个场景中，文件系统被用于存储和管理各类设备的配置文件、日志文件等数据。</p></li><li><p>文件系统设计方案：</p></li></ol><p>考虑到智慧农业控制嵌入式系统的特点和需求，可以设计一种轻量级的文件系统，具备以下特点：</p><ul><li><strong>简单快速</strong>: 提供简洁的操作界面和易于理解的文件组织方式，方便用户进行文件的存储、查找和管理。优化文件系统的读写性能，以满足实时控制的需求。采用文件缓存、文件索引等技术来提升文件读写效率。</li><li><strong>可靠性</strong>: 采用数据冗余和文件系统日志等机制来保证数据的完整性和可靠性，防止数据丢失或损坏。</li><li><strong>安全性</strong>: 对于敏感信息，采用加密算法进行数据保护，防止数据泄露和非法访问。</li><li><strong>灵活扩展</strong>: 设计分级的结构设计，以便未来能够支持新的设备类型、新的功能和协议。</li></ul><ol start="3"><li>设计方案评价：</li></ol><p>该设计方案针对智慧农业控制嵌入式系统的需求进行了考虑，并且具备一定的可行性和可实现性。然而，对于一个完整的文件系统来说，还需要更多的细节和技术实现方面的考虑，如并发访问的处理、容错和恢复机制等。此外，还需要考虑与其他系统组件的协同工作，以确保整个智慧农业控制嵌入式系统的稳定运行和良好的用户体验</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）内存管理</title>
      <link href="/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="内存管理总览图"></p><h1 id="1-内存管理概述"><a href="#1-内存管理概述" class="headerlink" title="1 内存管理概述"></a>1 内存管理概述</h1><p>内存是存储系统的一部分</p><p>存储系统核心目的是存储要运行的程序数据之类的</p><p>存储系统的设计目标可以归纳为3个问题</p><p>容量，速度，和成本之间的矛盾：</p><p>​三个目标不可能同时达到最优，要权衡利弊</p><p>​存取速度越快，每一位价格越高</p><p>​大容量就要降低速度</p><p>​高速度就要降低容量</p><p>解决方案：采用层次化的存储体系</p><p>换句话说 靠近CPU的，我们把他的存取速度加大，同时他的成本就会增加，容量就会减少</p><p>寄存器（CPU内）-》高速缓冲（Cache）-》内存-》磁盘-》磁带</p><p>从左到右，存取速度下降，存取容量增大</p><h2 id="1-1-内存管理目的"><a href="#1-1-内存管理目的" class="headerlink" title="1.1 内存管理目的"></a>1.1 内存管理目的</h2><p>​有效利用内存空间</p><p>​应用程序不必特别考虑内存的大小</p><p>​可以大于内存</p><h2 id="1-2-内存管理功能"><a href="#1-2-内存管理功能" class="headerlink" title="1.2 内存管理功能"></a>1.2 内存管理功能</h2><p>​记录内存的使用情况</p><p>​进程所占内存空间的分配与回收</p><p>​当内存不足时，采取相应措施</p><p>​内存空间的共享与保护</p><h1 id="2-程序的连接和装入"><a href="#2-程序的连接和装入" class="headerlink" title="2 程序的连接和装入"></a>2 程序的连接和装入</h1><h2 id="2-1-程序的连接"><a href="#2-1-程序的连接" class="headerlink" title="2.1 程序的连接"></a>2.1 程序的连接</h2><h3 id="2-1-1程序的连接的功能"><a href="#2-1-1程序的连接的功能" class="headerlink" title="2.1.1程序的连接的功能"></a>2.1.1程序的连接的功能</h3><p>多个目标文件及库文件连接成1个完整的可执行文件。</p><h3 id="2-1-2-程序连接的时机"><a href="#2-1-2-程序连接的时机" class="headerlink" title="2.1.2 程序连接的时机"></a>2.1.2 程序连接的时机</h3><p>静态连接：静态的，只连接1次，多次运行<br> 装入时连接：装入后是静态的<br> 实际运行时连接：调用时动态连接</p><h2 id="2-2-程序的装入"><a href="#2-2-程序的装入" class="headerlink" title="2.2 程序的装入"></a>2.2 程序的装入</h2><p>每个程序运行前，必须装入内存(为什么？这样存取速度才能匹配上CPU的速度)不一定一次性全部装入</p><p>装入方式有</p><h3 id="2-1-1-完全静态装入"><a href="#2-1-1-完全静态装入" class="headerlink" title="2.1.1 完全静态装入"></a>2.1.1 完全静态装入</h3><p>程序装入时不作任何修改。<br>即装入内存的每个字节与其可执行文件完全相同。</p><h3 id="2-1-2-静态重定位装入"><a href="#2-1-2-静态重定位装入" class="headerlink" title="2.1.2 静态重定位装入"></a>2.1.2 静态重定位装入</h3><p>程序装入时进行一次地址重定位，运行时不变。</p><p><strong>重定位</strong>是把汇编中的相对地址转换为内存中的实际地址</p><p><strong>相对地址:</strong><br>用户的程序经过汇编或编译连接后形成可执行代码，代码通常采用相对地址的形式，其首地址为0，指令中的地址都采用相对于首地址的偏移量。<br>机器是不能用相对地址在内存中读取信息的，必须用绝对地址<br><strong>绝对地址:</strong><br>内存中存储单元的实际地址</p><h3 id="2-1-3-动态重定位装入"><a href="#2-1-3-动态重定位装入" class="headerlink" title="2.1.3 动态重定位装入"></a>2.1.3 动态重定位装入</h3><p>真正<strong>执行到一条指令</strong>要访问某个内存地址时，才进行地址重定位。</p><p>一般设置1个重定位寄存器 存放当前进程在内存的起始地址<br> 绝对地址 &#x3D; 相对地址 + 重定位寄存器的值</p><h1 id="3-实存储器管理"><a href="#3-实存储器管理" class="headerlink" title="3 实存储器管理"></a>3 实存储器管理</h1><p>程序的大小不能超过可用内存空间的大小</p><p> 实实在在的 给我装进去哈哈哈</p><h2 id="3-1-连续分配"><a href="#3-1-连续分配" class="headerlink" title="3.1 连续分配"></a>3.1 连续分配</h2><p> 为每个进程分配连续的内存空间</p><h3 id="3-1-1-单一连续分配"><a href="#3-1-1-单一连续分配" class="headerlink" title="3.1.1 单一连续分配"></a>3.1.1 单一连续分配</h3><p>一般将内存划分为2个区：<br>     系统区：存放OS程序和数据<br>     用户区：存放用户程序和数据</p><p>如果是单一连续分配</p><p>内存中只存在1个用户程序。<br>     整个用户区为该程序独占！</p><p><strong>缺点：</strong></p><p>只能用于单用户、单任务OS。所以在现代操作系统肯定是不行的</p><h3 id="3-1-2-固定静态分区"><a href="#3-1-2-固定静态分区" class="headerlink" title="3.1.2 固定静态分区"></a>3.1.2 固定静态分区</h3><p>刚刚讲到的单一连续分配为什么不能多用户，多程序呢？</p><p>因为没有划分区域，不知道哪个用户或哪个程序该用哪一块内存</p><p><strong>改进</strong></p><p>所以固定分区进行划分区域操作</p><p>将内存的用户区预先划分为若干区域（分区）<br>分区个数和每个分区的大小是固定的<br>每个分区存放1个进程</p><p><strong>管理所需要的数据结构</strong></p><p>1个分区使用表（内存分配表），记录分区状态（比如区号id，分区大小，起始地址，状态是否被使用）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="管理所需的数据结构"></p><p><strong>缺点：</strong></p><p>(1) 当进程大小大于划分区域的时候，无法装入，<br>(2) 当进程大小小于划分区域的时候，存在内部碎片(Internal fragmentation)意味着会有内存资源的浪费<br>(3) 分区数目固定，使活动进程数目受限，比如划分十个区域，那么最多就是十个进程</p><p>所以也是不行的</p><h3 id="3-1-3-可变动态分区"><a href="#3-1-3-可变动态分区" class="headerlink" title="3.1.3 可变动态分区"></a>3.1.3 可变动态分区</h3><p>刚刚讲到的固定静态分区很差劲哦</p><p>原因在于很多东西都是固定的，比如分区数目，比如分区大小。</p><p>那么既然如此，我们就可以让他们“动”起来！</p><p><strong>改进</strong></p><p>动态分区<br>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化，既然如此我们需要一些数据结构进行记录</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="动态分区图示"></p><p><strong>需要的记录的数据结构</strong></p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据结构"></p><p>动态分区有一个核心就是怎么去分配分区，所以有着一系列的分区分配算法</p><p><strong>分区分配算法</strong></p><p>① 最先适配法（first fit）<br>    空闲分区链（表）按地址递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>② 下次适配法（next fit）<br>    从上次分配的分区的下一个开始，选择第1个大小足够的分区</p><p>③ 最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>④ 最差适配法（worst fit）<br>    空闲分区链（表）按大小递减的次序排列<br>    从头开始，选择第1个分区（如果足够大）</p><p>后两种方法利用率更高，但是需要排序，开销会更大</p><p>分区给不同 进程分配出去了，当进程执行结束后，还需要将该进程的所在分区释放回收，这时候可能会产生一些碎片（因为没有比这些碎片小的进程放入的时候就会产生这些碎片</p><p>如何解决</p><p>1 内存紧凑（compaction）：集中小碎片为大分区</p><p> 但是涉及到程序在内存中的移动，开销很大</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="紧凑"></p><p>2 根本上是因为 我们上述讨论的一直都是连续分配，所以我们可以从根本上解决，提出离散分配，也就是下一章的重点！</p><h2 id="3-2-离散分配"><a href="#3-2-离散分配" class="headerlink" title="3.2 离散分配"></a>3.2 离散分配</h2><p>刚刚3.1我们讲到连续分配导致很多的碎片，所以我们可以进行离散分配，首先进程可以分为不同部分装入内存的不同分区</p><p>典型的离散分配方式，分页管理，分段管理</p><h3 id="3-2-1-分页管理"><a href="#3-2-1-分页管理" class="headerlink" title="3.2.1 分页管理"></a>3.2.1 分页管理</h3><p>（1）等分内存为物理块（或称页面，页框，page frame）<br>         物理块编号为0，1，2，．．．。<br>（2）进程的逻辑地址空间分为不同的页（page）<br>         页大小 &#x3D; 物理块大小<br>         页编号为0，1，2，．．．。<br>（3）内存分配原则：<br>         进程的1页可装入任一物理块</p><p>这里我们注意一下和固定分区的区别，固定分区一下子只能装入一整个程序（整个程序在内存中是连续的），而分页操作可以使得一个进程不同部分离散的存储在内存的不同位置！</p><p><strong>问题</strong></p><p>进程的最后1页可能装不满，产生“页内碎片”。</p><p><strong>管理的数据结构</strong></p><p>OS为每个进程建立1个页表（Page Table）<br>记录进程的页号和物理块号的对应关系</p><p><img src="/img/OS/image-20231115225502679.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115225502679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115225502679"></p><p><strong>地址转换</strong></p><p>逻辑地址 → 物理地址</p><p>我们给程序分页的时候 0，1,2,3 实际上是逻辑地址或者叫相对地址，只知道这个我们肯定不知道程序在内存中的哪里，所以我们还需要通过上图的页表转换为实际的物理地址</p><p>所以对于一个程序而言，我们要找到页表，那么我们怎么找到一个程序的页表呢？</p><p>通过<strong>页表寄存器</strong> 存放当前进程的页表起始地址和长度  每个进程的页表起始地址和长度平时放在其PCB（进程管理模块）中，调度时由OS放入PTR</p><p>注意的几点问题</p><p>（1）在这个过程中，需要选择页的大小</p><p>页小：碎片小，但页表占用空间大（因为页的数量会很多）</p><p>页大：页表小，但页内碎片大<br>通常，页的大小为2的整数次幂</p><p>所以需要对两者进行权衡</p><p>假设我们页大小为1KB&#x3D;1024B（$2^{10}&#x3D;1024$）则需要10位页内地址，假设逻辑地址是16位，第0-9位是页内地址，10-15位是页号</p><p>（2）进程的逻辑地址结构 ——及地址转换<br>   地址的高位部分为页号，低位部分为页内地址</p><p><img src="/img/OS/image-20231115230855467.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115230855467.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115230855467"></p><p>物理地址 &#x3D; 块号×页大小 + 页内地址</p><p>（3）引入快表</p><p>快表，又称联想存储器(Associative Memory) ： 具有并行查找能力的特殊高速缓存（cache）。<br>用途：保存当前进程的页表的子集（部分表项），比如最近访问过的页表项。<br> 当切换到新进程时，快表要刷新。</p><p>目的：提高地址转换速度</p><p>思考一个问题，加深我们对于该部分的理解</p><p>1  CPU要存取一个数据时，需要访问内存几次？</p><p>2次。<br> 第1次：访问页表，找到该页号P对应的物理块号，将此块号×页大小 与页内地址拼接形成物理地址；<br> 第2次：访问该物理地址，存取其中的指令或数据。</p><p>假设逻辑地址中，页号占20位，页内地址12位，则总共有$2^{20}$个页1M个页，如果每个页表项4B，光页表就占用4MB的空间</p><p>因而 页表本身可能占用相当大的内存空间，而且是连续的。</p><p>如何解决？</p><p>采用二级页表(只能解决连续，但解决不了占用较大的内存)</p><p>将页表进行分页，页大小 &#x3D; 物理块大小<br>  设置1个一级页表，多个二级页表<br>   一级页表：第i项记录第i号二级页表所在的物理块号<br>  二级页表：第i项记录第i页对应的物理块号<br>  系统设置１个页表寄存器，存放一级页表的起始地址和长度</p><p>二级页表并未减少页表所占的内存空间，但解决了页表的离散分配问题</p><h3 id="3-2-2-分段管理"><a href="#3-2-2-分段管理" class="headerlink" title="3.2.2 分段管理"></a>3.2.2 分段管理</h3><p>静态段式管理</p><p>按程序的逻辑划分为若干个程序段，每一个段连续，且各个段的长度不要求相等</p><p>段号从0开始</p><p>分段类似于可变分区，但不同之处在于：<br>       一个进程可占据多个分区，而且分区之间不要求连续<br>分段无内部碎片，但有外部碎片。</p><p>（2）内存分配原则</p><p>以段为单位，各段不要求相邻</p><p>我们刚刚讲到的分页管理类似于固定分区，现在的分段管理则类似于可变分区，不同之处在于分区之间不要求连续。</p><p><strong>管理需要的数据结构</strong></p><p>OS为每个进程建立1个段表（Segment Table）<br>每个段在段表中有1项，记录该段在内存中的基址和长度</p><p><img src="/img/OS/image-20231116093449579.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231116093449579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231116093449579"></p><p>分段分页比较</p><p>（1）分页对程序员是不可见的；分段通常是可见的，并作为组织程序和数据的手段提供给程序员；<br>（2）页的大小由系统确定，段的大小由用户程序确定；<br>（3）分段更利于多个进程共享程序和数据；<br>（4）分段便于实现动态链接;<br>（5）分页可有效提高内存利用率，分段可更好地满足用户需要。</p><h3 id="3-2-3-分页分段管理"><a href="#3-2-3-分页分段管理" class="headerlink" title="3.2.3 分页分段管理"></a>3.2.3 分页分段管理</h3><p> 动机：结合分段和分页的优点，克服二者的缺点。</p><p>进程分段——同段式管理<br>每段分页，内存分块，内存以块为单位分配——同页式管理</p><p>进程的逻辑地址结构</p><p>由段号、页号和页内地址构成</p><p><strong>管理需要的数据结构</strong></p><p>每个进程有一个段表</p><p>记录每个段对应的页表的起始地址和长度</p><p>每个段有一个页表</p><p>记录该段所有页号与物理块的关系</p><p>CPU要存取一个数据时，需要访问3次内存。</p><p>第1次：访问段表，获得该段的页表地址；<br>第2次：访问页表，取得物理块号，形成物理地址；<br>第3次：访问该物理地址，存取其中的指令或数据。</p><p>实存储管理模式下，怎么提高运行程序的大小</p><p><strong>覆盖</strong></p><p>把程序划分为若干个功能上相对独立的程序段（称为覆盖块），按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域；</p><p>覆盖块存放在磁盘上，当一个程序段执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）</p><p>   (1)  要求程序员划分程序，提供一个明确的覆盖结构；<br>   (2) 增加了编程的复杂度。<br>   (3) 增加执行时间，从外存装入覆盖模块，时间换空间<br>    对用户不透明，增加了用户负担。</p><p>所以更好的方式是虚拟存储管理</p><h1 id="4-虚拟存储管理"><a href="#4-虚拟存储管理" class="headerlink" title="4 虚拟存储管理"></a>4 虚拟存储管理</h1><p>进程的大小可以超过可用物理内存的大小，<br>由OS把当前用到的那部分留在内存，其余的放在外存中。</p><p>几个概念</p><p> 虚拟地址：程序中使用的地址。进程的虚拟地址从0开始。<br> 物理地址：可寻址的内存实际地址<br> 虚拟地址空间：虚拟地址的集合<br> 物理地址空间：实际的内存空间</p><p>交换技术</p><p>将当前要使用的那部分程序或数据装入内存，将暂时不用的放在磁盘上，待需要时再装入。</p><p>交换是虚拟存储器设计的基础，最初的交换是针对整个进程的交换</p><h2 id="4-1-分页-虚拟存储"><a href="#4-1-分页-虚拟存储" class="headerlink" title="4.1 分页+虚拟存储"></a>4.1 分页+虚拟存储</h2><p>在进程开始运行之前，不是装入全部页，而是装入部分或0个页，之后根据进程运行的需要，动态装入其它页；<br>当内存空间已满，而又需要装入新的页时，则根据某种算法淘汰某个页，以便装入新的页。</p><p><img src="/img/OS/image-20231117222116973.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231117222116973.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117222116973"></p><p>除了页号和物理块号外，需要增加下列字段：</p><p> 有效位（状态）：表示该页是否在内存中<br>1 表示该页位于内存中，该页表项是有效的，可以使用<br>0表示该页当前在外存中，访问该页表项将导致缺页异常</p><p> 修改位M：表示该页在装入内存后是否被修改过<br>在有效位为1的情况下有效的情况下<br>用于回收该物理页面时，据此判断是否要把它的内容写回外存</p><p> 访问位A（访问字段）：记录该页最近是否被访问过<br>用于页面置换算法</p><p>  保护位：表示该页的允许访问方式<br>只读、可读写、可执行等</p><p> 外存地址：该页在磁盘上的地址</p><p>由于访问的页可能不在内存，所以需要</p><p>报告不在内存——缺页中断处理</p><p>将页从外存读入内存——页的换入换出</p><h3 id="4-1-0-缺页中断处理"><a href="#4-1-0-缺页中断处理" class="headerlink" title="4.1.0 缺页中断处理"></a>4.1.0 缺页中断处理</h3><p>1  保护当前进程现场；<br>2  根据页表中给出的外存地址，在外存中找到该页；<br>3  若内存中无空闲物理块，则选择1页换出；<br>4  分配一个空闲物理块，将新调入页装入内存；<br>5  修改页表中相应表项的状态位及相应的物理块号，修改空闲物理块表（链）；<br>6  恢复现场。</p><h3 id="4-1-1-页的换入换出"><a href="#4-1-1-页的换入换出" class="headerlink" title="4.1.1 页的换入换出"></a>4.1.1 页的换入换出</h3><p>页的换入换出涉及到</p><p>如何给进程分配物理块——页的分配策略</p><p>在什么范围内选择淘汰页——页的置换策略</p><p>页该怎么调入——页的调入策略</p><p>该选择哪些页被换出去——页的置换算法</p><p><strong>1）页的分配策略</strong>：为每个进程分配多少个物理块</p><p> 固定分配<br>    为每个进程分配的总物理块数固定，在整个运行期间不变。</p><p>可变分配<br>    先为每个进程分配一定数目的物理块，OS自身维持一个空闲物理块队列。<br>    当发生缺页时，由系统分配一个空闲块，存入调入的页；</p><p><strong>2）页的置换策略</strong>：在什么范围内选择淘汰页<br> 局部置换<br>只从缺页进程自身选择淘汰页<br>全局置换<br>从整个内存中选择淘汰页    当无空闲块时，才会换出。</p><p><strong>3）页的调入策略</strong><br>① 何时调入<br> 请求调页（demand paging）<br>    只有访问的页不在内存中时，才会调入该页。<br> 预调页（prepaging）<br>    一次调入多个连续的页。为什么这样做？<br>② 从何处调入：文件区（可执行文件）、交换区<br> 全部从交换区调入<br>    进程创建时，全部从文件区拷贝到交换区。<br> 首次调入从文件区，以后从交换区</p><p><strong>4）页的置换算法</strong></p><p>选择换出页 减少缺页率</p><ul><li><strong>最优置换算法 OPT</strong></li></ul><p>​淘汰以后永不使用的，或者过最长时间才会被访问的页</p><p>​因为无法预测将来，所以不好实现</p><ul><li><strong>先进先出置换算法 FIFO</strong></li></ul><p>​只需把进程中已调入内存的页，按先后次序链成一个队列即可；链首最长，链尾最短；出现缺页时，选择链首页面进行置换，新页面加到链尾。</p><p>​优点：开销较小，实现简单。<br>​缺点：<br>       ① 它与进程访问内存的动态特性不相适应；有可能调出的页面可能是经常访问的<br>       ② 会产生belady现象。即：当分配给进程的物理块数增加时，有时缺页次数反而增加。</p><ul><li><strong>最近最久未使用算法 LRU</strong></li></ul><p>淘汰最近一次访问距当前时间最长的页。<br>即淘汰未使用时间最长的页<br>关键：如何快速地判断出哪一页是最近最久未使用的。<br>算法较好，但实现代价高。</p><p>实现方法</p><p>方法一：计时器</p><p>​对于每一页增设一个访问时间计时器</p><p>​每当某页被访问时，当时的绝对时钟内容被拷贝到对应的访问时间计时器中，这样系统记录了内存中所有页最后一次被访问的时间。<br>  淘汰时，选取访问时间计时器值最小的页。</p><p>方法二：移位寄存器</p><p>​为内存中的每一页配置一个移位寄存器<br>  当访问某页时，将相应移位寄存器的最高位置1<br>  每隔一定时间，寄存器右移1位<br>  淘汰寄存器值最小的页。</p><p>方法三：栈</p><p>​  每次访问某页时，将其页号移到栈顶。使得栈顶始终是最近被访问的页，<br>  栈底是最近最久未用的。</p><p>以上的最近最久未使用算法核心需要判断最久，开销较大</p><p>所以我们提出一个近似，最近未使用算法NRU</p><ul><li><strong>最近未使用算法 NRU 也叫做CLOCK算法</strong></li></ul><p>实现方法</p><p>页表中设置一个访问位，当访问某页时，将访问位置1<br>将内存中的所有页链成一个循环队列<br>从上次换出页的下一个位置开始扫描<br>在扫描过程中，将访问位&#x3D;1的页清0，直到遇到访问位&#x3D;0的页，淘汰该页，并将指针指向下一页</p><p>改进：</p><p>该算法的提出基于如下考虑：<br>① 对于已修改的页，换出时必须重新写回到磁盘上。因此，优先选择未访问过、未修改过的页换出；<br>② 淘汰一个最近未访问的已修改页要比淘汰一个被频繁访问的“干净”页好。</p><p>所以按照下面的顺序进行淘汰</p><p>第1类：A &#x3D; 0，M &#x3D; 0：未访问，未修改；最佳淘汰页<br>第2类：A &#x3D; 0，M &#x3D; 1：未访问，已修改<br>第3类：A &#x3D; 1，M &#x3D; 0：已访问，未修改；有可能再次访问<br>第4类：A &#x3D; 1，M &#x3D; 1：已访问，已修改</p><p>算法</p><p>① 找第1类页，将遇到的第1个页作为淘汰页；<br>② 若查找1周后未找到第1类页，则寻找第2类页，并将扫描经过的页的访问位清0。将遇到的第1个页作为淘汰页；<br>③ 否则，转①、②，一定能找到淘汰页。</p><ul><li><strong>最少使用算法 LFU</strong></li></ul><p>选择最近访问次数最少得页淘汰</p><p> 通常不直接利用计数器来记录页的访问次数，而是采用移位寄存器R。<br>  类似于LRU算法，每次访问某页时，将其移位寄存器的最高位置1。每隔一定时间将移位寄存器右移1位。</p><p>这样，在最近一段时间内使用次数最少的页就是移位寄存器各位之和最小的页。</p><p>往往配合页缓冲算法，提高LFU的效率</p><p>基本方法 设置两个空闲链表 空闲页链表，已修改页链表</p><p>① 若淘汰页未修改，则直接放入空闲页链表，否则放入已修改页链表；<br>② 当已修改页达到一定数量时，再将其一起写回磁盘，即成簇写回，以减少I&#x2F;O操作的次数。</p><p>缺页率对于虚拟存储来说非常重要</p><p>因为缺页导致的中断处理相对处理时间也比较长</p><p>前面进程没有考虑进程对内存块需求的差异性，有可能给进程多增加一个物理页面，就会导致缺页率大幅度下降</p><p>所以全局置换算法可能效果更好，为进程分配可变数目的物理页面，经典的算法有工作集</p><ul><li>工作集置换算法</li></ul><p>1 基本思想</p><p> 根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页，这些页称为活动页。<br>    如果分配给一个进程的物理块数太少了，使该进程所需的活动页不能全部装入内存，则进程在运行过程中将频繁发生缺页中断。<br>    如果能为进程提供与活动页数相等的物理块数，则可减少缺页中断次数。</p><p> 首先什么是工作集</p><p>一个进程在时刻t、参数为△的工作集W(t, △)，表示该进程在过去的△个时间单位中被访问到的页的集合。△称为工作集的窗口大小。</p><p>工作集大小的三个因素</p><p>   访页序列特性<br>   时刻t<br>   观察该进程的时间窗口大小(△)</p><p>实现方法：</p><p>访存链表：维护窗口内的访存页面链表<br>访存时，换出不在工作集的页面；更新访存链表<br>缺页时，换入页面；更新访存链表</p><h2 id="4-2-分段-虚拟存储"><a href="#4-2-分段-虚拟存储" class="headerlink" title="4.2 分段+虚拟存储"></a>4.2 分段+虚拟存储</h2><p>要比虚拟页式管理复杂一些</p><p>会有缺段中断</p><h2 id="4-3-段页-虚拟存储"><a href="#4-3-段页-虚拟存储" class="headerlink" title="4.3 段页+虚拟存储"></a>4.3 段页+虚拟存储</h2><p>涉及缺段中断、缺页中断。<br>注意的是，对于缺段中断处理，主要是在内存中建立该段的页表，而非调入完整的一段。</p><p>影响缺页次数的因素</p><p>（1）分配给进程的物理块数<br>    一般来说，进程的缺页中断率与进程所占的内存块数成反比。<br>    分配给进程的内存块数太少是导致抖动现象发生的最主要原因。<br>（2）页的大小<br>     缺页中断率与页的大小成反比，但页的大小也不能一味地求大，它一般在0.5KB~4KB之间，是个实验统计值。因为页大时，页表较小，占空间少，查表速度快，缺页中断次数少，但页内碎片较大。页小时，恰恰相反。<br>（3）程序的编写方法<br>    进程的缺页中断率与程序的局部性（包括时间和空间局部性）程度成反比。<br>     用户程序编写的方法不合适可能导致程序运行的时空复杂度高，缺页次数多。<br>（4）页置换算法<br>    算法不合理会引起抖动。</p><p>页式管理</p><p><strong>页</strong></p><p>相对物理块来说，页是逻辑地址空间（<a href="https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a>空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB。</p><p>例如：一个 32 位的<strong>操作系统</strong>，页的大小设为 2^12&#x3D;4Kb，那么就有页号从 0 编到 2^20 的那么多页逻辑空间。</p><p>段式管理</p><p>段页式管理</p><p>段页</p><p>虚拟内存</p><p>​让用户感觉像是在分段，但实际上是分页管理</p><p>$命中率h&#x3D;\frac{N_c}{N_c+N_m}$</p><p>其中$N_c$为Cache完成存取的总次数，$Nm$表示主存完成存取的次数</p><p>页框是什么</p><p><strong>高级调度：</strong></p><p>​功能：调度对象是作业。其主要功能是根据某种算法，其选择从就绪队列中选择哪个进程进入内存执行，以便后续的执行。决定从外存中处于后备队列中的哪几个作业调入内存，为创建进程、分配必要的资源。</p><p>​关系：高级调度与中级调度之间的关系是，高级调度将作业从后备队列中选择并将它们加载到内存中，然后中级调度负责将这些作业分配给可运行队列。高级调度与低级调度之间的关系是，它确定了哪些进程将被带入内存，以供后续的执行。</p><p><strong>中级调度：</strong></p><p>又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。</p><p>​功能：中级调度的主要任务是管理内存中的进程。它可以将某些进程从内存中暂时移出，以便为其他进程腾出空间，以减轻内存压力，提高内存利用率和系统吞吐量。</p><p>​关系：中级调度与高级调度之间的关系是，它接受高级调度分配的作业，将它们加载到内存中，并可以在必要时将它们暂时移出内存。中级调度还与低级调度之间有关，因为它可以调整进程的内存分布，以优化系统性能。</p><p><strong>低级调度：</strong></p><p>​功能：低级调度是最频繁的调度级别，其任务是从就绪队列中选择下一个要执行的进程。它控制着CPU的分配，决定哪个进程将在CPU上执行，以确保公平性和性能。</p><p>​关系：低级调度与高级调度之间的关系是，它执行高级调度选择的进程，将其分配给CPU执行。它还与中级调度之间有关，因为中级调度可能会将某些进程暂时移出内存，而低级调度负责在需要时将它们带回内存。</p><p>慢表（Page）：页表、段表存放在主存中，收到虚拟地址后要先访问主存，査询页表、段表，进行虚实<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">地址转换</a>。</p><p>快表（TLB）：提高变换速度→用高速缓冲存储器存放常用的页表项（注意不是放在内存的）</p><p>假设某计算机硬件提供了动态重定位寄存器和地址越界检查，现在为计算机涉及一个操作系统的内存管理方案，支持多进程并发执行,且不大于内存空间大小的进程可以装入内存执行</p><p>（1）阐述方案的设计思路</p><p>由于该计算机需要多进程并发执行，所以可以采用可变动态分区的方法进行内存管理，同时计算机只需要装入不大于内存的进程，所以可以采用实存储器管理方案。</p><p>综上所述可以采用 实存储器管理的可变动态分区的方案进行管理</p><p>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化</p><p>（2）管理所需要的数据结构</p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">free_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> start_address; <span class="comment">//开始地址</span></span><br><span class="line">        <span class="type">double</span> length; <span class="comment">//长度</span></span><br><span class="line">    <span class="type">double</span>  state; <span class="comment">//状态（是否分配）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">used_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> id;<span class="comment">//进程号</span></span><br><span class="line">    <span class="type">double</span> start_address;<span class="comment">//开始地址</span></span><br><span class="line">    <span class="type">double</span> length;<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）为了尽可能的避免产生碎片，我决定采用最佳适配法</p><p>最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assignment memory&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">length</span>(free_list_queue)!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">sort</span>(free_list_queue);<span class="comment">//对空闲列表进行排序</span></span><br><span class="line">best=<span class="built_in">check</span>(free_list_queue,process_memory)<span class="comment">//遍历空闲列表，找到第一个足够大小的分区</span></span><br><span class="line"><span class="built_in">fill_memory</span>(best,process)<span class="comment">//将进程放入该分区</span></span><br><span class="line"><span class="keyword">delete</span> free_list_queue[best] <span class="comment">//更新空闲列表</span></span><br><span class="line">        add <span class="built_in">used_list_queue</span>(prcess,best)<span class="comment">//更新已使用的列表</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">    置换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软中断和硬中断区别</p><p>总体而言，硬中断和软中断都是计算机系统中用于处理异步事件的机制，但它们的触发方式和处理方式有所不同。硬中断是由外部硬件设备触发的，而软中断是由软件程序主动发起的。</p><p>看到网上的一个比喻我觉得非常恰当：</p><p>你在屋里打电话，这时候响起了敲门声，你可以去处理敲门声，也可以不理会继续打电话，这是软中断。但是如果电话线断了，你必须停止打电话，这是硬中断</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）进程管理下</title>
      <link href="/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/"/>
      <url>/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="进程管理下总览图"></p><p>进程之间的同步和互斥</p><p>同步，是指一个某一步的执行必须需要等待其他操作完成之后</p><p>互斥，是指一个进程的某一块只能有一个进程访问</p><h1 id="6-经典进程同步问题"><a href="#6-经典进程同步问题" class="headerlink" title="6.经典进程同步问题"></a>6.经典进程同步问题</h1><h2 id="6-1-生产者-消费者问题-既有同步又有互斥"><a href="#6-1-生产者-消费者问题-既有同步又有互斥" class="headerlink" title="6.1 生产者-消费者问题 (既有同步又有互斥)"></a>6.1 生产者-消费者问题 (既有同步又有互斥)</h2><p><strong>问题描述</strong></p><p>生产者往缓冲区写数据，满了的话就不能写了</p><p>消费者从缓冲区取数据，空的话就不能取了</p><p>一次只能有一个生产者或消费者取读数据</p><p><strong>问题分析</strong></p><p>核心解决</p><p>（1）不能向满的缓存区写数据，否则的话必须等待（同步关系）</p><p>（2）不能向空的缓存区取数据，否则的话必须等待（同步关系）</p><p>（3）任何时刻，仅允许一个1个生成者或1个消费者访问</p><p>意味着消费者之间互斥，生成者之间互斥，消费者和生产者之间互斥，总结来说就是任意两个进程之间对缓冲区操作的时候，其他进程不能操作 （互斥关系）</p><p>full：记录缓冲区中非空的槽数，初始值&#x3D;0</p><p>empty：记录缓冲区中空的槽数，初始值&#x3D;N</p><p>mutex：确保进程不同时访问缓冲区，初始值&#x3D;1</p><p>解决（1）（2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void producer(void)&#123;</span><br><span class="line">while (True) &#123;</span><br><span class="line">        produce(); //生产1项</span><br><span class="line">        P(empty); //申请1个空槽</span><br><span class="line">        P(mutex); //请求进入临界区</span><br><span class="line">        append(); //加入缓冲区</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(full); //递增非空槽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void)&#123;</span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">        P(full); //申请1个非空槽</span><br><span class="line">        P(mutex); //申请进入临界区</span><br><span class="line">        remove(); //从缓冲区移出1项</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(empty); //递增空槽数</span><br><span class="line">        consume(); //消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-读者-写者问题"><a href="#6-2-读者-写者问题" class="headerlink" title="6.2 读者-写者问题"></a>6.2 读者-写者问题</h2><p><strong>问题描述</strong></p><p>多个Reader进程，多个Writer进程，共享文件F<br>要求：<br>  允许多个Reader进程同时读文件<br>  不允许任何一个Writer进程与其他进程同时访问（读或写）文件</p><p><strong>问题分析</strong></p><p>​写者之间要互斥</p><p>​读者和写者之间互斥</p><p>​读者之间不互斥</p><p>所以核心是我们要在第一个读者进来的时候，进行判断是否有写者正在写</p><p><strong>标答</strong></p><p>write</p><p>WriteMutex &#x3D; 0  读写操作的互斥访问<br>Rcount &#x3D; 0 正在读操作的读者数目<br>CountMutex &#x3D; 0 读者计数的互斥访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (True) &#123;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line">  <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">     ++Rcount;</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line">     read;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line"> --Rcount;</span><br><span class="line">      <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">    <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">        write;</span><br><span class="line">    <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-哲学家进餐问题"><a href="#6-3-哲学家进餐问题" class="headerlink" title="6.3 哲学家进餐问题"></a>6.3 哲学家进餐问题</h2><p><strong>问题描述</strong></p><p>有5个哲学家围坐在一张圆桌周围，每个哲学家面前有1碗饭，左右各1把叉子。<br>哲学家有两种活动：思考和吃饭。<br>只有拿到左右两把叉子才能吃饭。<br>吃饭后，放下叉子，继续思考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5个信号量，分别用于对5个叉子互斥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  5 <span class="comment">//哲学家数</span></span></span><br><span class="line">Semaphore_t  fork[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span> <span class="params">(<span class="type">int</span> i)</span> <span class="comment">//i是哲学家编号：0~N-1  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)  &#123;</span><br><span class="line">        <span class="built_in">think</span>(); </span><br><span class="line">        <span class="built_in">P</span>(fork[i]); </span><br><span class="line">        <span class="built_in">P</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">        <span class="built_in">eat</span>(); </span><br><span class="line">        <span class="built_in">V</span>(fork[i]); </span><br><span class="line">        <span class="built_in">V</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-进程之间通信"><a href="#7-进程之间通信" class="headerlink" title="7.  进程之间通信"></a>7.  进程之间通信</h1><p>P,V操作实现的是进程之间的低级通信，所以P,V操作是低级通讯原语，即不能传递大量的信息</p><p>所以我们引入进程间高级通讯方式</p><h2 id="7-1-共享存储区"><a href="#7-1-共享存储区" class="headerlink" title="7.1 共享存储区"></a>7.1 共享存储区</h2><p>相互通信的进程间设有公共的内存区，每个进程既可向该公共内存中写，也可从公共内存中读，通过这种方式实现进程间的信息交换。<br>      把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p><h2 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h2><p> 源进程发送消息，目的进程接受消息。所谓消息，就是一组数据。</p><p>（1）消息队列（message Queue）或消息缓冲<br>    发送者发消息到一个消息队列中；<br>    接收者从相应的消息队列中取消息。<br>    消息队列所占的空间从系统的公用缓冲区中申请得到。<br>（2）邮箱（mailbox）<br>  发送者发消息到邮箱，接收者从邮箱取消息。<br>  邮箱是一种中间实体，一般用于非实时通信。</p><h2 id="7-3-管道"><a href="#7-3-管道" class="headerlink" title="7.3 管道"></a>7.3 管道</h2><p>首创于Unix。用于连接一个读进程、一个写进程，以实现它们之间通信的共享文件，称为pipe文件。</p><p>管道分为下列2种：<br> 有名管道<br> 无名管道</p><h1 id="8-线程"><a href="#8-线程" class="headerlink" title="8.线程"></a>8.线程</h1><p>为什么引入线程</p><p>线程是进程的１条执行路径。方便进程内部的同步操作，线程之间共享内存</p><p>比如，一个文字输入软件，其内部可以有三个线程，一个用来加载视频、一个用来播放视频，一个用来备份。因为进程之间不共享内存，所以不能用多个进程来实现这时就用多线程可以解决。线程之间共享内存，所以从一个线程切换到另一个线程不需要陷入内核，也不需要切换上下文，线程之间的切换比进程切换快捷。</p><p>　1个进程可以有多个线程，其中至少有1个主线程（primary thread）。</p><p>　1个进程内的多个线程在同一个地址空间内（共享该进程的地址空间）。</p><p>每个线程有自己的线程控制块TCB（Thread Control Block），包含自己的堆栈和状态信息。TCB比PCB小得多。</p><h2 id="8-1-线程的实现机制"><a href="#8-1-线程的实现机制" class="headerlink" title="8.1 线程的实现机制"></a>8.1 线程的实现机制</h2><p>用户级线程</p><p>​由在用户空间执行的线程库来实现，OS对此一无所知。　<br>线程库提供线程创建、撤消、上下文切换、通信、调度等功能。</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是进程为单位的，容易阻塞</p><p>​但是性能高，无需陷入内核</p><p>核心级线程</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是线程为单位的</p><p>​但是性能低，需要陷入内核</p><h1 id="9-进程调度"><a href="#9-进程调度" class="headerlink" title="9 进程调度"></a>9 进程调度</h1><p>为什么进程调度</p><p>多个进程就绪时候，OS决定先执行哪一个</p><p>我们进程调度要达到的目的</p><p>​CPU利用率高，吞吐量大，周转时间少，等待时间短，公平</p><p>​很多时候都是在权衡！很多时候很难兼顾所有的目的</p><p>什么时候会切换进程呢？</p><p>​硬件中断，进程异常，或者该进程请求IO，这些都会让CPU闲下来，我们就要给CPU找活干了</p><p>一些概念</p><ul><li>周转时间 &#x3D; 作业完成时刻 - 作业到达时刻</li><li>带权周转时间 &#x3D; 周转时间 &#x2F; 服务时间</li><li>平均周转时间 &#x3D; 作业周转总时间 &#x2F; 作业个数</li><li>平均带权周转时间 &#x3D; 带权周转总时间 &#x2F; 作业个数</li></ul><h2 id="9-1-调度方式"><a href="#9-1-调度方式" class="headerlink" title="9.1 调度方式"></a>9.1 调度方式</h2><p>非抢占方式</p><p>​一旦某进程被调度，直到完成或因某事件而阻塞，才会切换到其他进程</p><p>抢占方式</p><p>​允许暂停正在运行的进程，切换到其他进程</p><p>抢占原则：</p><p>​时间片原则：时间片到时抢占</p><p>​优先级原则：优先级高者到时抢占</p><h2 id="9-2-常见算法"><a href="#9-2-常见算法" class="headerlink" title="9.2 常见算法"></a>9.2 常见算法</h2><h3 id="9-2-1-先来先服务-FCFS"><a href="#9-2-1-先来先服务-FCFS" class="headerlink" title="9.2.1 先来先服务  FCFS"></a>9.2.1 先来先服务  FCFS</h3><p><strong>方法</strong></p><p>按照进程就绪的先后次序来调度进程，非抢占式方式</p><p><strong>优点</strong>：实现简单</p><p><strong>缺点</strong>:<br>    （1）平均等待时间波动很大<br>              短进程、长进程到达时间是随机的<br>    （2）有利于CPU繁忙型进程，不利于I&#x2F;O繁忙型进程<br>    （3）有利于长进程，不利于短进程</p><h3 id="9-2-2-短进程优先-SPN"><a href="#9-2-2-短进程优先-SPN" class="headerlink" title="9.2.2 短进程优先 SPN"></a>9.2.2 短进程优先 SPN</h3><p><strong>方法：</strong></p><p>  选择估计运行时间最短的进程运行。<br>短进程优先算法具有最优平均周转时间</p><p><strong>优点</strong>：</p><p>  平均等待时间较短</p><p><strong>缺点</strong></p><p>  对长进程（作业）不利。<br>  极端情况下，会使长进程（作业）得不到调度。</p><p>所以在这个上面的改进提出最高响应比算法</p><h3 id="9-2-3-最高相应比优先算法"><a href="#9-2-3-最高相应比优先算法" class="headerlink" title="9.2.3 最高相应比优先算法"></a>9.2.3 最高相应比优先算法</h3><p><strong>方法</strong></p><p>选择就绪队列中相应比R值最高的进程<br>     R &#x3D; （W + S）&#x2F; S<br>             W: 等待时间（waiting time）<br>             S: 执行时间（service time）</p><p>短进程优先算法：长进程等待的时间而出现饥饿<br>  对于最高响应优先算法，如果等待时间越长，则R会越大，在一定程度上避免了长进程出现饥饿的情况</p><p>但上面的两种方法都得估计进程运行的时间，这个预测未来比较难</p><p>另外计算开销比较大，所以应用比较少</p><h3 id="9-2-4-时间片轮转-RR"><a href="#9-2-4-时间片轮转-RR" class="headerlink" title="9.2.4 时间片轮转 RR"></a>9.2.4 时间片轮转 RR</h3><p><strong>方法</strong></p><p> 将所有的就绪进程按FCFS原则排成一个队列，<br>    规定一个时间片为进程每次使用CPU的最长时间，<br>    每次选择队首进程运行，<br>    当时间片到时，剥夺该进程的运行，将其排在队尾</p><h3 id="9-2-5-基于优先级的调度"><a href="#9-2-5-基于优先级的调度" class="headerlink" title="9.2.5 基于优先级的调度"></a>9.2.5 基于优先级的调度</h3><p><strong>方法</strong></p><p>每个进程一个优先级；<br>总是选择就绪队列中优先级最高的进程投入运行；<br>可以是抢占式，或非抢占式。</p><h3 id="9-2-6-多级反馈队列"><a href="#9-2-6-多级反馈队列" class="headerlink" title="9.2.6 多级反馈队列"></a>9.2.6 多级反馈队列</h3><p><strong>方法</strong></p><p>(1) 按优先级设置n(n&gt;1)个就绪队列，每个队列赋予不同优先级。如第一级队列到最后一级队列，优先级依次降低。<br>(2) 优先级越高队列，分配的时间片越小。<br>(3) 每个队列按照先来先服务原则排队。<br>(4) 一个新进程就绪后进入第一级（或相应优先级）队尾。<br>(5) 调度方法<br>每次选择优先级最高队列的队首进程运行；<br>若被调度进程的时间片到，则放入下一级队列的队尾；<br>最后一级队列采用时间片轮转；<br>当有一个优先级更高的进程就绪时，可以抢占CPU，被抢占进程回到原来队列的末尾。</p><p>该算法综合了前面几种算法的优点。<br>  既考虑了先来先服务，又照顾了长进程；<br>  既考虑了优先级，又讲求公平。</p><h1 id="10-进程死锁"><a href="#10-进程死锁" class="headerlink" title="10 进程死锁"></a>10 进程死锁</h1><h2 id="10-1-基本概念"><a href="#10-1-基本概念" class="headerlink" title="10.1 基本概念"></a>10.1 基本概念</h2><p>第一个概念死锁</p><p><strong>死锁</strong></p><p>什么是死锁呢？</p><p>一个进程集合中的每个进程都在等待只能由该集合中的其它进程才能引发的事件，这种状态称作死锁。<strong>一组竞争系统资源的进程由于相互等待而出现“永久”阻塞</strong>。</p><p>例如，2个进程A、B，都需要资源R1、R2</p><p>若A：拥有R1，申请R2</p><p>若B：拥有R2，申请R1</p><p>如何？</p><p>第二个概念资源的基本分类</p><p><strong>资源分类</strong></p><p><strong>可重用资源</strong></p><p>资源不能被删除且在任何时刻只能有一个进程使用</p><p>进程释放资源后，其他进程可重用</p><p>例如：处理器，I&#x2F;O通道等等</p><p>可能出现的死锁</p><p>每个进程占用一部分资源并请求其他资源</p><p><strong>消耗资源</strong></p><p>资源创建和销毁过程</p><p>例如：在I&#x2F;O缓冲区的中断、信号和消息等</p><p> 可能出现的死锁</p><p>进程间相互等待接收对方的消息</p><h2 id="10-2-什么情况产生死锁"><a href="#10-2-什么情况产生死锁" class="headerlink" title="10.2 什么情况产生死锁"></a>10.2 什么情况产生死锁</h2><p>四个必要条件</p><p>1）互斥条件<br>   每个资源要么被分配给了1个进程，要么空闲<br>2）占有及等待（部分分配）条件<br>   已经得到了资源的进程要申请新的资源<br>3）不可剥夺条件<br>   已经分配给一个进程的资源不能被剥夺，只能由占有者显式释放<br>4）环路等待条件<br>   存在由2个或多个进程组成的一条环路，<br>   该环路中的每个进程都在等待相邻进程占有的资源</p><h2 id="10-3-死锁前—检测死锁"><a href="#10-3-死锁前—检测死锁" class="headerlink" title="10.3 死锁前—检测死锁"></a>10.3 死锁前—检测死锁</h2><p>一 由OS处理</p><p>​1 检测死锁并恢复</p><p>​2 分配资源时避免死锁</p><p>​3 假装没看见（鸵鸟策略）：多数OS对待死锁的策略，那死锁了怎么办，开机重启</p><p>二 由应用程序本身预防死锁</p><p>实际中检测死锁恢复是可能的，但是代价太大</p><h3 id="10-3-1-死锁检测"><a href="#10-3-1-死锁检测" class="headerlink" title="10.3.1 死锁检测"></a>10.3.1 死锁检测</h3><p>方法一 资源分配图</p><p>看看有没有环，有环的话有没有无法释放的情况</p><p>方法二 矩阵</p><h3 id="10-3-2-何时检测"><a href="#10-3-2-何时检测" class="headerlink" title="10.3.2 何时检测"></a>10.3.2 何时检测</h3><p>1）每当有资源请求时；</p><p>2）周期性检测；</p><p>3）每当CPU的使用率降到某一阈值时。</p><p>死锁检测会占用大量的CPU时间</p><h2 id="10-4-死锁前—死锁避免"><a href="#10-4-死锁前—死锁避免" class="headerlink" title="10.4 死锁前—死锁避免"></a>10.4 死锁前—死锁避免</h2><p><strong>银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定金额的贷款，而他知道不可能所有客户同时都需要最大的贷款额。在这里，我们可将客户比作进程，银行家比作操作系统。银行家算法就是对每一个客户的请求进行检查，检查如果满足它是否会引起不安全状态。如果是，则不满足该请求；否则，便满足。</p><p><strong>使得死锁四个条件有一个不成立</strong></p><p>1 破坏互斥条件   对资源统一管理，如SPOOLing技术</p><p>2 破坏不可剥夺条件 当进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源。</p><p>3 破坏占有及等待条件  原子性地获得所需全部资源。</p><p>4 破坏环路等待条件 把系统中所有资源按类型不同进行线性排队，并编号</p><h2 id="10-5-死锁后—恢复死锁"><a href="#10-5-死锁后—恢复死锁" class="headerlink" title="10.5 死锁后—恢复死锁"></a>10.5 死锁后—恢复死锁</h2><p>如何从死锁中恢复？</p><p>1 剥夺法恢复<br>  将某一资源从一个进程抢占过来给另一个进程使用<br>  不能影响原进程的最终执行结果<br>  取决于资源的特性</p><p>2  回退法恢复<br>  从各进程最近的检查点（check point）逐次重新启动</p><p>3 杀死进程来恢复<br>  最好杀死可重复执行、不会产生副作用的进程</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理上</title>
      <link href="/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/"/>
      <url>/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><p><strong>简单概述</strong></p><p>什么是进程？<br>   是程序的1次执行（程序执行的1个实例）<br>   每个进程有自己的地址空间。</p><p>为什么引入进程？<br>   多任务的需要。在内存中同时有多个可执行的进程，如果某一个进程去请求I&#x2F;O了，那么CPU就会空闲，这时候其他进程如果不执行的话，CPU利用率就会很低，所以进程并发执行以提高效率（特别是CPU的利用率）。</p><p>因此，需要对进程进行管理，以避免冲突：<br>   借助于PCB，记录进程的描述和控制信息、上下文状态</p><h1 id="1-进程和程序区别"><a href="#1-进程和程序区别" class="headerlink" title="1 进程和程序区别"></a>1 进程和程序区别</h1><p>进程是程序的1次执行。<br>进程（Process）和程序（Program）是两个不同的概念，它们在计算机科学中有明确的区别：</p><ol><li><strong>程序（Program）</strong>：<ul><li><strong>定义</strong>：程序是一组计算机指令的有序集合，这些指令被编写成一个文件，通常以可执行文件的形式存在。程序是静态的，它只是一段代码的集合，等待被执行。</li><li><strong>特点</strong>：程序包含了计算机程序员编写的源代码，它描述了一系列任务的算法和逻辑，但并没有实际执行。程序不占用计算机的内存空间，也不消耗计算机的CPU时间。</li><li><strong>例子</strong>：一个文本编辑器的程序文件、一个游戏的可执行文件、一个网页浏览器的应用程序等都是程序的例子。</li></ul></li><li><strong>进程（Process）</strong>：<ul><li><strong>定义</strong>：进程是计算机中正在运行的程序的实例。它是程序在内存中加载并执行时的活动状态，包括程序的代码、数据、执行状态、系统资源分配等。</li><li><strong>特点</strong>：进程是动态的，它占用计算机的内存空间，可以执行计算机指令，与其他进程并发运行。每个进程都有自己的独立内存空间，因此它们不会相互干扰。进程可以创建、启动、暂停、终止等。</li><li><strong>例子</strong>：当运行一个文本编辑器、播放音乐、浏览网页或打印文档时，每个活动都对应一个独立的进程。</li></ul></li></ol><p>总结来说，程序是静态的、不执行的计算机指令集合，而进程是程序的运行实例，它占用计算机内存，执行指令，并与其他进程一起协同工作。进程是计算机操作系统中的核心概念，它使多任务处理成为可能.</p><p>可以将程序和进程比喻为烹饪的过程：</p><ol><li><strong>程序（Program）</strong>就像是一本菜谱。菜谱是一份详细的食物制作指南，它包含了食材清单、烹饪步骤和所需的厨具。但菜谱本身并不能做出美味的食物，它只是一份指导，等待着被厨师（计算机）读取和执行。就像您需要拿出菜谱并按照其中的步骤去做一道菜一样，计算机需要将程序加载到内存中并执行其中的指令。</li><li><strong>进程（Process）</strong>就像是正在烹饪中的一道菜。当您选择一道菜谱并开始烹饪时，您实际上在制作一道具体的菜肴。这个菜肴有自己的成分、调味料和烹饪状态。它在火上烹煮、被切割、被摆盘等等。这个菜肴是实际被制作和提供给食客的，就像进程是正在计算机内存中运行和执行的程序实例。</li></ol><p>所以，程序就像是一份指导，而进程是实际的动态执行。程序是静态的，而进程是具体的、可见的操作。</p><h1 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h1><h2 id="2-1-进程的5种基本状态"><a href="#2-1-进程的5种基本状态" class="headerlink" title="2.1 进程的5种基本状态"></a>2.1 进程的5种基本状态</h2><p>（1）新建（new）：进程正在被创建。<br>（2）就绪（ready）：进程可运行，正等待获得处理机。<br>（3）运行（running）：进程的指令正在被执行。<br>（4）阻塞（blocked）或等待：进程因等待某事件（如请求I&#x2F;O）而暂停执行。<br>（5）完成（done）：进程结束。</p><h2 id="2-2-进程状态之间转换"><a href="#2-2-进程状态之间转换" class="headerlink" title="2.2 进程状态之间转换"></a>2.2 进程状态之间转换</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="状态转换图"></p><h2 id="2-3-七状态模型"><a href="#2-3-七状态模型" class="headerlink" title="2.3 七状态模型"></a>2.3 七状态模型</h2><p>在五状态的模型基础上，引入挂起（即 进程此时在外存等待）</p><p>就绪(Ready)：进程在内存且可立即进入运行状态<br>阻塞(Blocked)：进程在内存并等待某事件的出现<br>阻塞挂起(Blocked, suspend)：进程在外存并等待某事件的出现<br>就绪挂起(Ready, suspend)：进程在外存，但只要进入内存，即可运行<br> 运行<br> 新建<br> 完成</p><p>注意 挂起都在外存</p><p>挂起：把进程从内存转到外存  </p><p>激活：把进程从外存转到内存</p><p>补充：</p><p>时间片是操作系统给程序分配的时间，保证一个进程不会一直占用CPU资源不释放造成混乱</p><h1 id="3-进程描述"><a href="#3-进程描述" class="headerlink" title="3 进程描述"></a>3 进程描述</h1><h2 id="3-1-进程控制块-PCB"><a href="#3-1-进程控制块-PCB" class="headerlink" title="3.1 进程控制块 PCB"></a>3.1 进程控制块 PCB</h2><p><strong>作用</strong></p><p>​1 是OS管理和控制进程的数据结构。</p><p>​2 PCB记录着进程的描述信息。</p><p>​ 每个进程对应1个PCB。</p><p><strong>信息内容</strong></p><p>（1）进程本身的标识信息</p><p>​进程标识符pid(process ID)：整数，由OS分配，唯一</p><p>​用户标识符uid(user ID)：创建该进程的用户</p><p>​对应程序的地址：内存、外存</p><p>（2）CPU现场 - 为进程正确切换所需</p><p>​所有寄存器的值  或称进程上下文(context)</p><p>​因为要切换走进程！所以要保护当前进程的上下内容，使得切换回来的时候可以继续正常执行</p><p>（3）进程调度信息</p><p>​进程的状态</p><p>​优先级</p><p>​使进程阻塞的条件</p><p>​占用CPU 、等待CPU的时间（用于动态调整优先级）</p><p>（4）进程占用资源的信息</p><p>​进程间同步和通信机制，如信号量、消息队列指针</p><p>​打开文件的信息，如文件描述符表</p><p>CPU现场 - 为进程正确切换所需</p><p> 所有寄存器的值</p><p> 或称进程上下文(context)</p><p>Linux的进程控制块:task_struct</p><p>​进程创建时，由OS创建PCB;进程终止时，由OS撤销PCB；进程运行时，以PCB作为调度依据。</p><h2 id="3-2-进程块组织方式"><a href="#3-2-进程块组织方式" class="headerlink" title="3.2 进程块组织方式"></a>3.2 进程块组织方式</h2><p>一般来说，系统把所有PCB组织在一起，并把它们放在内存的固定区域，构成<strong>PCB</strong>表。</p><p>PCB表的大小决定了系统中最多可同时存在的进程个数。</p><p>同一状态进程的PCB组成一个链表，不同状态对应多个不同的链表，如就绪链表、阻塞链表 </p><h1 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4 进程控制"></a>4 进程控制</h1><p>进程控制就是要对我们上述讲到的进程状态之间做转换</p><p>基本概念</p><p><strong>原语</strong></p><p>​创建、撤销进程以及完成进程各状态之间的转换，由具有特定功能的原语完成</p><p>​原语 由若干指令构成的具有特定功能的函数</p><p>​具有原子性，其操作具有不可分割性</p><p>如：</p><p>​进程创建原语</p><p>​进程撤销原语</p><p>​阻塞原语</p><p>​唤醒原语</p><p>​挂起原语</p><p>​激活（解挂）原语</p><p>​改变进程优先级</p><h1 id="5-进程同步-互斥"><a href="#5-进程同步-互斥" class="headerlink" title="5 进程同步 互斥"></a>5 进程同步 互斥</h1><p>在执行时间上互相重叠（或交替），一个进程的执行尚未结束，另一个进程的执行已经开始的执行方式。</p><p>这样会有一个问题</p><p>​因为资源共享的问题，结果会产生不确定性</p><p>举一个例题</p><p>为此，引入同步（synchronization）和互斥（mutual exclusion）。</p><p>临界资源  一次只允许一个进程独占访问（使用）资源 ，越小越好</p><p>临界区   进程中访问临界资源的的程序段</p><h2 id="5-1-区分进程互斥和同步"><a href="#5-1-区分进程互斥和同步" class="headerlink" title="5.1 区分进程互斥和同步"></a>5.1 区分进程互斥和同步</h2><p>互斥是指执行某个进程的时候访问某一临界资源的时候，另一个进程不能执行访问这一临界资源。</p><p>经典只有互斥问题：打印机打印</p><p>同步是指完成某一进程执行是有条件的，必须等另一个进程的某一资源结束才可以</p><p>经典只有同步的问题：售票员售票</p><p>既有互斥又有同步问题：消费者问题</p><h2 id="5-2-核心方案"><a href="#5-2-核心方案" class="headerlink" title="5.2 核心方案"></a>5.2 核心方案</h2><p>信号量</p><p>利用信号量P-V操作可以实现进程的互斥访问</p><p>利用信号量P-V 操作可以实现进程的同步访问</p><h2 id="5-3-其他方案"><a href="#5-3-其他方案" class="headerlink" title="5.3 其他方案"></a>5.3 其他方案</h2><p>实现互斥方案</p><p>一个好的互斥方案应满足以下条件：</p><p>（1）任何两个进程不能同时处于临界区。</p><p>（2）临界区外的进程不应阻止其他进程进入临界区。</p><p>（3）不应使进程在临界区外无休止地等待。就是说，临界区代码执行时间要短。</p><p>（4）不应对CPU的个数和进程之间的相对运行速度作任何假设。</p><h3 id="方案1-设置锁变量"><a href="#方案1-设置锁变量" class="headerlink" title="方案1 设置锁变量"></a>方案1 设置锁变量</h3><p>即设置一个共享变量lock</p><p>当lock&#x3D;0的时候，临界区内无进程，初始值</p><p>当lock&#x3D;1的时候，临界区内有进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lock);</span><br><span class="line">lock=<span class="number">1</span>;</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">lock=<span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt;</span><br></pre></td></tr></table></figure><p>可能的问题</p><p>1 会导致两个进程同时进入临界资源</p><p>​比如进程1走到lock&#x3D;1的时候，还没来得及上锁（修改lock的值为1）就被切换走了，这时候其他进程 就可以避免while也进入临界区</p><p>2  可能会存在盲等待   走到lock&#x3D;0的时候，还没来得及解锁就被切换走了，这时候其他进程都进不来！</p><p>所以这种方案是错误的，不能达到效果</p><h3 id="方案2-严格轮转法"><a href="#方案2-严格轮转法" class="headerlink" title="方案2 严格轮转法"></a>方案2 严格轮转法</h3><p>设置共享变量turn，以指示进入临界区的进程号</p><p>以两个进程为例</p><p>turn&#x3D;0的时候允许进程0进入临界区，初始值</p><p>turn&#x3D;1的时候允许进程1进入临界区</p><p>进程0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">0</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>进程1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">1</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>本质互为锁</p><p>可能的问题</p><p>进程可能会被临界区之外的进程阻塞</p><h3 id="方案3-Peterson解决方案"><a href="#方案3-Peterson解决方案" class="headerlink" title="方案3 Peterson解决方案"></a>方案3 Peterson解决方案</h3><p>设置一个共享变量process，代表此时进入临界区的进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enter_region</span>(process); <span class="comment">//process是 进入/离开临界区的进程号</span></span><br><span class="line">&lt;临界区&gt;</span><br><span class="line"><span class="built_in">leave_region</span>(process);</span><br><span class="line">&lt;非临界区&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个进程想进入临界区时，先调用enter_region函数，判断是否能安全进入，不能的话等待；当进程从临界区退出后，需调用leave_region函数，允许其它进程进入临界区。<br>两个函数的参数均为进程号</p><p>以两个进程为例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FALSE  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TRUE   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   N        2 <span class="comment">// 进程的个数</span></span></span><br><span class="line"><span class="type">int</span>  turn;   <span class="comment">// 轮到谁？</span></span><br><span class="line"><span class="type">int</span>  interested[N];   <span class="comment">// 兴趣数组，表明第i个进程是否在临界区，所有元素初始值均为FALSE</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">enter_region</span> <span class="params">(<span class="type">int</span>  process)</span>  <span class="comment">// process为进程号 0 或 1&#123;        </span></span></span><br><span class="line"><span class="function">    <span class="type">int</span>  other</span>;  <span class="comment">// 另外一个进程的进程号        </span></span><br><span class="line">other  =  <span class="number">1</span>  -  process;        </span><br><span class="line">interested[process]  =  TRUE; <span class="comment">// 表明本进程进入临界区       </span></span><br><span class="line">turn  =  process;          <span class="comment">// 设置标志位       </span></span><br><span class="line"><span class="keyword">while</span> ( turn == process &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">leave_region</span> <span class="params">(<span class="type">int</span>  process)</span></span>&#123;      </span><br><span class="line">    interested[process]  =  FALSE; <span class="comment">// 本进程将离开临界区&#125;</span></span><br></pre></td></tr></table></figure><h3 id="方案4-关中断"><a href="#方案4-关中断" class="headerlink" title="方案4 关中断"></a>方案4 关中断</h3><p>由于进程在切换进程的时候 必须进行中断处理，既然如此的话</p><p>我们可以在一个程序进入临界区域之前，将中断功能给关闭，简称关中断！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关中断；</span><br><span class="line">&lt;临界区&gt;;</span><br><span class="line">开中断;</span><br><span class="line">&lt;非临界区&gt;;</span><br></pre></td></tr></table></figure><p>缺点</p><p>1 对多处理机系统无效，因为每个处理机有自己的中断开关</p><p>2 关中断权利交给用户不合适</p><h3 id="方案5-机器指令实现的互斥"><a href="#方案5-机器指令实现的互斥" class="headerlink" title="方案5 机器指令实现的互斥"></a>方案5 机器指令实现的互斥</h3><p>即保证某些内容他是直接互斥的</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）操作系统概述</title>
      <link href="/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="概述总览图"></p><h1 id="1-程序如何执行"><a href="#1-程序如何执行" class="headerlink" title="1 程序如何执行"></a>1 程序如何执行</h1><p>我们都对运行程序很熟悉，无论是QQ，微信都是一个个在运行的程序</p><p>我们也都知道有这样一个职业叫做——程序员，就是编写这些程序的代码的。</p><p>那么代码从编写好后到最终执行的过程是怎样的呢？实际有三步</p><p>​预处理 编译 链接</p><p>我们感觉好像很简单，但实际上程序运行需要各种资源，会有一些异常，这些处理我们往往不关心，而这些实际上是系统应用程序——操作系统来完成的</p><p>换句话说<strong>程序</strong>执行的整个生命周期都<strong>受操作系统控制</strong></p><p>比如建立程序的内存映像， CPU的分配 内存分配、释放 文件访问，输入输出（I&#x2F;O） 中断（异常）处理</p><h1 id="2-操作系统初探"><a href="#2-操作系统初探" class="headerlink" title="2 操作系统初探"></a>2 操作系统初探</h1><h2 id="2-1-操作系统功能"><a href="#2-1-操作系统功能" class="headerlink" title="2.1 操作系统功能"></a>2.1 操作系统功能</h2><p><strong>从用户观点看</strong>，操作系统是一个<strong>虚拟机</strong></p><p>​让用户（程序员）在使用计算机时不涉及计算机硬件的细节，使硬件细节和用户（程序员）隔离开来，即建立一种简单的高度抽象。</p><p><strong>从系统观点来看</strong>，操作系统是一个<strong>资源管理器</strong>：管理系统的软硬件资源</p><p>​硬件资源：构成计算机系统所必须配置的所有硬件： CPU、内存、时钟、磁盘。       软件资源：程序和数据（文件）。</p><p>总结来看，操作系统有四大功能</p><p>​ 进程管理，内存管理，文件管理， I&#x2F;O设备管理，以后的系列文章也会微软这个展开</p><h2 id="2-2-操作系统定义"><a href="#2-2-操作系统定义" class="headerlink" title="2.2 操作系统定义"></a>2.2 操作系统定义</h2><p>基于操作系统的功能</p><p>操作系统可以定义为</p><p>​OS是硬件之上的第1层软件（系统软件），是一组程序，用来有效控制和管理计算机系统的各类资源（硬件和软件资源：设备、文件、存储器、CPU、程序（进程））， 以方便用户使用计算机（用户和计算机的接口）</p><h1 id="3-操作系统一些概念"><a href="#3-操作系统一些概念" class="headerlink" title="3.操作系统一些概念"></a>3.操作系统一些概念</h1><h2 id="3-1-作业"><a href="#3-1-作业" class="headerlink" title="3.1 作业"></a>3.1 作业</h2><p>从输入开始到输出结束，用户要求计算机所做的一次业务处理的全部工作（一次业务处理往往需要包括多个程序配合）所以操作系统中的作业（Job）通常又可以理解为是一组相关任务或程序的集合</p><p>作业由三部分组成：1 程序  2要执行的程序代码  3数据</p><p>作业通常需要访问和处理数据，因此数据是作业的另一个重要组成部分</p><p>作业往往有着自己的控制信息等</p><p>假设你正在使用一台多任务操作系统的个人电脑，你同时打开了以下两个应用程序：</p><ol><li>文字处理器：你在编辑一份重要的文档。</li><li>网页浏览器：你正在浏览互联网上的一些新闻文章。</li></ol><p>在这个情景中，操作系统将视每个应用程序为一个作业，并为其分配资源和执行环境。</p><h2 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h2><p>为改进内存和I&#x2F;O设备之间的吞吐量 ，进行批处理操作</p><p>就是3.1讲的是一个作业处理</p><p>而3.2 就是同时处理多个作业，多个作业构成一个队列，依次处理</p><p><strong>缺点</strong>：</p><p>​    用户不能干预自己作业的运行     一旦发现作业错误不能及时改正     延长了软件开发时间     一般只适用于成熟的程序或大型的计算程序</p><h2 id="3-3-单道程序和多道程序"><a href="#3-3-单道程序和多道程序" class="headerlink" title="3.3 单道程序和多道程序"></a>3.3 单道程序和多道程序</h2><ul><li>单道程序：</li></ul><p>​内存中只有一个用户程序</p><p>​因为I&#x2F;O很费时，若当前程序因等待I&#x2F;O而暂停， 则<strong>CPU空闲</strong></p><ul><li>多道程序：  在内存中存放多个用户程序，同时处于可运行状态。    当一个程序等待I&#x2F;O时，另一个程序可以使用CPU</li></ul><p>我们现在的操作系统肯定都是多道程序，核心目的让CPU忙起来，提高效率</p><h2 id="3-4-多道批处理系统"><a href="#3-4-多道批处理系统" class="headerlink" title="3.4 多道批处理系统"></a>3.4 多道批处理系统</h2><p>多道程序+批处理&#x3D;多道批处理系统</p><p>与单道批处理系统相比：  系统吞吐量（单位时间内完成的总工作量）大；  资源利用率高； 周转时间（作业从进入系统到完成所经历的时间）长。</p><h2 id="3-5分时系统"><a href="#3-5分时系统" class="headerlink" title="3.5分时系统"></a>3.5分时系统</h2><p>多个用户（程序）共享一台计算机，按时间片（time slice）轮流使用。</p><p>什么是 时间片：OS将CPU时间划分为若干个片段</p><h2 id="3-6-并发和并行"><a href="#3-6-并发和并行" class="headerlink" title="3.6 并发和并行"></a>3.6 并发和并行</h2><p>并发：两个或多个事件在同一时间间隔内交替发生，不一定是同时执行。</p><p>并行：两个或多个事件在同一时刻发生。</p><p> 多用户：允许多个用户通过各自的终端使用同一台主机，共享主机系统中的各类资源。 多任务：允许多个程序并发执行。</p><p>一个 比喻更好理解</p><ul><li><strong>并发</strong>：想象一个餐厅，只有一个厨师和一个服务员。多个客人进入餐厅，他们点餐后，服务员会为每个客人记录点餐的需求，然后将这些需求交给厨师。厨师会依次准备每份菜肴，然后将它们送到客人的桌子上。虽然只有一个厨师，但由于服务员不断地切换处理不同客人的需求，似乎每个客人都在同一时间段内得到了服务，这就是<strong>并发</strong>。多个任务（客人的点餐需求）在同一个资源（厨师）上交替执行。</li><li><strong>并行</strong>：现在，想象这家餐厅升级了，雇佣了多个厨师，每个厨师都可以独立准备菜肴，而服务员可以同时为多个客人提供服务。在这种情况下，每个厨师和服务员都可以同时处理不同的客户需求，这就是<strong>并行</strong>。多个任务（客人的点餐需求）在同时使用不同的资源（多个厨师和服务员）来提高效率。</li></ul><p>还有比如实时OS，网络OS，分布式OS</p><h1 id="4-OS对运行环境的要求"><a href="#4-OS对运行环境的要求" class="headerlink" title="4. OS对运行环境的要求"></a>4. OS对运行环境的要求</h1><h2 id="4-1-CPU"><a href="#4-1-CPU" class="headerlink" title="4.1 CPU"></a>4.1 CPU</h2><p>CPU是执行程序的核心部件</p><p>CPU 通过状态标识，知道是操作系统程序还是用户程序在执行，从而给到OS特权指令（只能由OS执行的命令），进行一些紧急任务建立存储保护，清内存、关中断等</p><p>CPU<strong>两种工作状态</strong></p><p>​<strong>核心态</strong></p><p>处于核心态的时候 </p><p>全部指令（包括特权指令）可以执行 可使用所有资源 并具有改变处理器状态的能力</p><p>​<strong>用户态</strong></p><p>处于用户态的时候</p><p>只有非特权指令能执行 特权级别不同，可运行的指令集合也不同 特权级别越高，可以运行的指令集合越大 高特权级别对应的可运行指令集合包含低特权级的</p><p>CPU的<strong>程序状态字PSW</strong></p><p>指示程序执行的当前状态，主要包括<br>  CPU的工作状态——指明核心态还是用户态，用来说明当前在CPU上执行的是操作系统还是应用程序，从而决定其是否可以使用特权指令或拥有其他的特殊权力<br>  条件标志——反映指令执行后的结果特征<br>  中断标志——指出是否允许中断</p><p>CPU的<strong>程序计数字PC</strong></p><p>指示下一条要执行的指令</p><h2 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h2><p>程序必须存放在内存中才能运行。 </p><p>在多任务系统中，操作系统要管理、保护各任务的程序和数据，使它们不至于受到破坏和相互干扰。 操作系统本身也要存放在内存中并运行，不能被破坏。</p><p><strong>内存分块：</strong>块作为分配内存空间的基本单位，如4KB为1块。</p><p>为什么要按块来分配内存空间？旨在简化对内存的分配和管理</p><p><strong>内存保护：</strong> OS正常运行的基本条件</p><p>常用的保护机制</p><p> (1) 界限寄存器 存放某任务在内存的上界和下界地址(或者下界与长度)，越界后产生越界中断</p><p>(2) 存储保护键（ Key） 当一个程序进入内存时，OS为其分配一个唯一的Key。 同时将分配给它的每个存储块都设置成该Key</p><h2 id="4-3-中断"><a href="#4-3-中断" class="headerlink" title="4.3 中断"></a>4.3 中断</h2><p>指CPU在收到外部中断信号后，停止原来工作，转去处理该中断事件，完毕后回到原来断点继续工作。  CPU对系统中发生的“异步（随机）”事件的处理</p><p><strong>中断类型</strong></p><p>1 硬件中断</p><p>​又分为两类 </p><p>​内部异常（硬故障中断 ： 如电源断掉，程序性中断 ：如溢出，越界，非法指令等）</p><p>​外部中断（CPU外部发生的特殊事件，通过“中断请求”向CPU请求处理  如打印机缺纸等）</p><p> 2 异常（Exception）</p><p>3 陷入（Trap）</p><p>4 访管中断（系统调用）</p><p><strong>中断响应过程</strong></p><p>1 关中断   防止其他中断修改影响当下中断</p><p>2 保护断点和程序状态    将断点和程序状态保存到栈或特殊寄存器中</p><p>3 识别中断事件</p><h2 id="4-4-时钟"><a href="#4-4-时钟" class="headerlink" title="4.4 时钟"></a>4.4 时钟</h2><p>进行程序的同步，计数等</p><p>1 硬件时钟：通过时钟寄存器实现。  绝对时钟：记录当前时间 相对时钟（间隔时钟）：分时系统的基础。 </p><p>2 软件时钟：通过时钟队列实现。 </p><h2 id="4-5-重定位"><a href="#4-5-重定位" class="headerlink" title="4.5 重定位"></a>4.5 重定位</h2><p>将程序中的相对地址转换为绝对地址。 </p><p> 原因：运行前不可能知道程序将放在内存的什么位置。 </p><p>静态重定位：程序装入内存时，由装入程序重定位</p><p>动态重定位：CPU每次访问内存时，由动态地址转换机构（硬件）自动进行</p><h1 id="5-现代操作系统基本特征"><a href="#5-现代操作系统基本特征" class="headerlink" title="5.现代操作系统基本特征"></a>5.现代操作系统基本特征</h1><p>（1）并发         计算机系统中同时存在多个运行的程序，需要OS管理和调度</p><p> （2）共享        “同时”访问          互斥共享  </p><p>（3）虚拟         利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务 （4）异步        程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知         只要运行环境相同，OS需要保证程序运行的结果也要相同</p><h1 id="6-操作系统启动过程"><a href="#6-操作系统启动过程" class="headerlink" title="6 操作系统启动过程"></a>6 操作系统启动过程</h1><ol><li><strong>硬件自检（POST）</strong>：<ul><li>当计算机电源打开时，计算机硬件执行自检过程（POST），以确保所有硬件组件正常运行。这包括检查内存、CPU、磁盘驱动器等。</li></ul></li><li><strong>引导设备选择</strong>：<ul><li>计算机 BIOS 或 UEFI 固件负责选择要从中启动的设备。用户可以在 BIOS&#x2F;UEFI 设置中配置启动顺序，以决定首选引导设备，例如硬盘、光盘驱动器、USB 驱动器等。</li></ul></li><li><strong>MBR&#x2F;GPT加载</strong>：<ul><li>根据 BIOS&#x2F;UEFI 设置，计算机将查找引导设备的主引导记录（MBR）或分区表（GPT），以确定启动引导加载程序的位置。</li></ul></li><li><strong>引导加载程序（Boot Loader）</strong>：<ul><li>引导加载程序是启动过程的下一步，它负责加载操作系统内核。在EOS操作系统中，引导加载程序通常是GRUB（GRand Unified Bootloader）或其他引导加载程序。</li></ul></li><li><strong>内核加载</strong>：<ul><li>引导加载程序加载EOS操作系统内核（Linux内核）到计算机的内存中。内核是操作系统的核心，它负责管理硬件、进程、内存和文件系统等。</li></ul></li><li><strong>初始化（init）</strong>：<ul><li>一旦内核加载到内存中，它会执行初始化过程，初始化操作系统的各个组件和服务。在Linux中，init 进程是初始化的第一个进程，它将创建其他系统进程，并启动用户界面或命令行终端。</li></ul></li><li><strong>启动级别&#x2F;运行级别（Runlevels）</strong>：<ul><li>EOS操作系统支持不同的启动级别，每个级别定义了在系统启动时运行的一组服务和任务。用户可以通过更改运行级别来控制系统启动时加载的服务。不同的运行级别可以是单用户模式、多用户模式等。</li></ul></li><li><strong>登录&#x2F;用户界面</strong>：<ul><li>最后一步是用户登录或进入用户界面。用户可以通过输入用户名和密码登录，或者进入图形用户界面（GUI）或命令行界面（CLI），具体取决于系统配置。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（八）ControlNet</title>
      <link href="/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/"/>
      <url>/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/</url>
      
        <content type="html"><![CDATA[<p>2023年的2月13日，一款名叫ControlNet的插件横空出世，AI绘画变得更加可控</p><p>ControlNet直译过来很简单，就叫做控制网，开发者是一名华裔，毕业于苏州大学，目前在斯坦福做读博士一年级，大佬大佬！</p><p>在controlNet之前，基于扩散模型的绘画是极为难控制的，平时自嗨画画其实没有一点问题，随机就随机一点，但是对于一些特定要求的岗位的同学来说，这种抽卡式缺乏稳定性的模型很难真正提高效率。</p><h1 id="1-ControlNet的作用结构"><a href="#1-ControlNet的作用结构" class="headerlink" title="1 ControlNet的作用结构"></a>1 ControlNet的作用结构</h1><p>​根据一些额外信息控制扩散生成走向，业内人士称为微调，通俗点说就是大模型你不是随机吗，那我给你一些指引信息，让你乖乖听话朝着我期望的方向走</p><p>​这时候有好奇的小伙伴就要问到了，那他和图生图有什么区别吗？我直接输入图片不也可以达到同样的效果吗？其实从某种意义上来说是的，但我举如下一个例子你就明白了</p><p>​比如我现在要生成一个有着特定姿势的图片，我固然可以通过一张自己期待的姿势的图片输入，模型可能会了解到这个姿势，但与此同时，这种图片除了姿势的其他信息如画面颜色，风格，人物特征也会被网络捕获到，因而就可能会产生意外的化学反应，但是用ControlNet可以提取人体关键点（如下图），这样的话模型只会了解到纯粹的需要生成的姿势而不会混杂其他信息，可控性就会增强了</p><h1 id="2-ControlNet的安装和使用"><a href="#2-ControlNet的安装和使用" class="headerlink" title="2 ControlNet的安装和使用"></a>2 ControlNet的安装和使用</h1><p>ControlNet本质是一个插件，所以类似于之前插件的安装（看之前的这篇插件安装的文章）</p><p>不同于一些插件，ControlNet还需要搭配不同的模型来使用，来实现特定的功能</p><p>最推荐的安装方式，是将ControlNet的扩展文件夹放在根目录下的extensions文件夹内，可以省下很多麻烦</p><p>然后在扩展选单里重新加载WebUI 界面，就可以在文生图和图生图里面看到了</p><p>下载一个ControlNet模型（一般是pth和yaml文件）之后移动到ControlNet的扩展文件夹中</p><h1 id="3-基本使用方式"><a href="#3-基本使用方式" class="headerlink" title="3 基本使用方式"></a>3 基本使用方式</h1><p>点开ControlNet控制网。输入一张图片，我们在这里期望输出的图片模仿我们输入图片的姿势</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913193208411.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913193208411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913193208411"></p><p>我们从网上找一张<img src="Snipaste_2023-09-13_19-40-39.png" class="lazyload placeholder" data-srcset="Snipaste_2023-09-13_19-40-39.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-09-13_19-40-39" style="zoom:50%;" />图片上传</p><p>选择预处理器（OpenPose就是提取姿势的），并选择相应的模型</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913194602605.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913194602605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913194602605"></p><p>其他参数先维持不变</p><p>加入我们期望的场景提示词，如在森林里</p><blockquote><p>1 cute girl, forest, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p>生成![00228-2167140323-1 cute girl, forest, smile, _SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper,](00228-2167140323-1 cute girl, forest, smile, _SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper,.png)</p><p>更改一下提示词</p><blockquote><p>1 cute girl, city, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p>![00236-1319366320-1 cute girl, city, smile, white coat_SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wa](00236-1319366320-1 cute girl, city, smile, white coat_SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wa.png)</p><p>可以看出姿势完全不变</p><p>同时它还会附加给我们一张骨骼图</p><p><img src="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" class="lazyload placeholder" data-srcset="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="3-1-参数详解"><a href="#3-1-参数详解" class="headerlink" title="3.1 参数详解"></a>3.1 参数详解</h2><p><strong>Control Weight</strong></p><p>决定这个控制效应在图片中呈现出来的强度，维持默认1不变</p><p><strong>Starting Control step</strong> </p><p><strong>ending Control step</strong> </p><p>什么时候加入ControlNet影响，默认的0到1表示全程生效，缩短影响，可以赋予图像更多的自由度</p><p><strong>ControlMode</strong></p><p>提示词影响和ControlNet之间倾向于哪一个，一般维持默认Balanced即可，二者兼顾</p><p>核心就是控制强弱</p><p><strong>缩放模式</strong></p><p>会在导入图片和你生成图片分辨率不匹配的时候起作用</p><h2 id="3-2-代表性ControlNet模型应用"><a href="#3-2-代表性ControlNet模型应用" class="headerlink" title="3.2 代表性ControlNet模型应用"></a>3.2 代表性ControlNet模型应用</h2><h3 id="3-2-1-Open-Pose姿态"><a href="#3-2-1-Open-Pose姿态" class="headerlink" title="3.2.1 Open Pose姿态"></a>3.2.1 Open Pose姿态</h3><p>上面讲到的只是OpenPose的基本的身体整体骨骼的刻画</p><p>选择不同的预处理器可以获得对手部，脸部更精确的刻画</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913200558559.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913200558559.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913200558559"></p><p>比如我们使用openpose_face,可以看到获得了更精细的脸部特征骨骼图</p><p>![tmpbpgj9ukv (1)](tmpbpgj9ukv (1).png)</p><h3 id="3-2-2-Depth-深度"><a href="#3-2-2-Depth-深度" class="headerlink" title="3.2.2 Depth 深度"></a>3.2.2 Depth 深度</h3><p>适合富有空间感的多层次场景</p><h3 id="3-2-3-canny-边缘检测"><a href="#3-2-3-canny-边缘检测" class="headerlink" title="3.2.3 canny 边缘检测"></a>3.2.3 canny 边缘检测</h3><p>通过边缘来进行绘画输出，超级强大！！！</p><p>比如我们这里用Canny检测器，可以生成几乎一模一样的</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913201834850.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913201834850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913201834850"></p><p>可以实现线稿上色</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913202412411.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913202412411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913202412411"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（七）扩展插件</title>
      <link href="/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Stable diffusion的开源生态为各种各样的辅助插件的开发提供了极大的便利，而这些辅助插件又可以为我们AI作画提供极大的便捷</p><h1 id="1-插件界面介绍"><a href="#1-插件界面介绍" class="headerlink" title="1 插件界面介绍"></a>1 插件界面介绍</h1><p>Extensions 在扩展一栏</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905174839326.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905174839326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905174839326"></p><p>三个installed  (已安装) Available （可用的）install from URL 从URL安装</p><p>如果是自己安装的sd，很可能刚开始的时候installed里面只有一些必要的插件，但是如果是一些大佬的整合包，则已经自带了一些插件</p><h1 id="2-插件安装方式"><a href="#2-插件安装方式" class="headerlink" title="2 插件安装方式"></a>2 插件安装方式</h1><p>1 Available（可用的插件）这里作者会把一些常用的插件记录在一个地址中，点击Load from，则可以加载出一系列详细的扩展应用清单</p><p>2 链接安装，复制代码仓库的地址，再点击安装也能实现一键安装</p><p>3 但上面两种方式都是借助git，因而可能会不稳定，所以还有最后一种方式，直接下扩展插件的代码包，然后送到Stable-diffusion根目录下的extensions文件夹里，然后点击应用并重启用户界面即可</p><h1 id="3-新手插件"><a href="#3-新手插件" class="headerlink" title="3 新手插件"></a>3 新手插件</h1><h2 id="3-1-中文本地化语言包"><a href="#3-1-中文本地化语言包" class="headerlink" title="3.1 中文本地化语言包"></a>3.1 中文本地化语言包</h2><p>​搜索栏里搜索 zh</p><h2 id="3-2-图库浏览器-image-browser"><a href="#3-2-图库浏览器-image-browser" class="headerlink" title="3.2 图库浏览器  image browser"></a>3.2 图库浏览器  image browser</h2><p>​有很多功能如收藏夹，筛选，查看图片信息等等</p><p>​    链接<a href="https://github.com/yfszzx/stable-diffusion-webui-images-browser">https://github.com/yfszzx/stable-diffusion-webui-images-browser</a></p><h2 id="3-3-提示词自动补全-tag-autocompletion"><a href="#3-3-提示词自动补全-tag-autocompletion" class="headerlink" title="3.3 提示词自动补全  tag autocompletion"></a>3.3 提示词自动补全  tag autocompletion</h2><p>​链接<a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git"> https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git</a></p><p>  （1）他可以告诉我们AI可以更好理解的一些提示词</p><p>比如我们这里，输入one girl 这时候他下边自动提示1girl的写法，点击换用1girl会更好</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905175245286.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905175245286.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175245286"></p><p>（2）可以快速补全各类模型名称</p><p>我们知道一些embeddings，lora模型需要特定提示词才能激活，但是那些提示词可能又臭又长记不住，怎么办，提示词插件来咯</p><p>输入：</p><ul><li><code>&lt;e:</code> 会展示 embeddings 名字</li><li><code>&lt;l:</code> 或者<code>&lt;lora:</code> 会展现 Lora 名字</li><li><code>&lt;h:</code> 或者<code>&lt;hypernet:</code> 会展现可选的 Hypernetworks</li></ul><p><img src="/img%5CStable_diffusion%5Cimage-20230905175526580.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905175526580.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175526580"></p><h2 id="3-4-Tagger-提示词反推插件"><a href="#3-4-Tagger-提示词反推插件" class="headerlink" title="3.4 Tagger 提示词反推插件"></a>3.4 Tagger 提示词反推插件</h2><p>链接 <a href="https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git">https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git</a></p><p>上传图片，选择反推算法，一般维持默认即可，点击开始反推</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905180334053-1693910444141.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905180334053-1693910444141.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905180334053"></p><p>使用完后，点击卸载显存中所有反推模型</p><h2 id="3-5-Prompt-all-in-one"><a href="#3-5-Prompt-all-in-one" class="headerlink" title="3.5 Prompt-all-in-one"></a>3.5 Prompt-all-in-one</h2><p> Prompts 神器，它提供了自动翻译、历史记录和收藏等功能，支持多种语言，满足不同用户的需求。对英文不熟悉的用户，使用它，再也不用在翻译软件和SD之间反复横跳了。</p><h1 id="4-进阶扩展"><a href="#4-进阶扩展" class="headerlink" title="4 进阶扩展"></a>4 进阶扩展</h1><h2 id="4-1提升画质"><a href="#4-1提升画质" class="headerlink" title="4.1提升画质"></a>4.1提升画质</h2><h3 id="Ultimate-Upscale-无损放大脚本"><a href="#Ultimate-Upscale-无损放大脚本" class="headerlink" title="Ultimate Upscale 无损放大脚本"></a>Ultimate Upscale 无损放大脚本</h3><p>​类似于SD 自带的放大，把图片拆成不同的块去放大</p><h3 id="local-latent-Couple-局部隐空间"><a href="#local-latent-Couple-局部隐空间" class="headerlink" title="local latent Couple  局部隐空间"></a>local latent Couple  局部隐空间</h3><p>​可以进行一些细节局部修饰，重新绘制</p><h2 id="4-2-提示词"><a href="#4-2-提示词" class="headerlink" title="4.2 提示词"></a>4.2 提示词</h2><h3 id="cutoff-解决提示词之间的相互干预"><a href="#cutoff-解决提示词之间的相互干预" class="headerlink" title="cutoff 解决提示词之间的相互干预"></a>cutoff 解决提示词之间的相互干预</h3><p>​比如我们想让女生穿一个红色裙子，但是忽然发现红色到了帽子上等等其他地方</p><h2 id="4-3-视频制作"><a href="#4-3-视频制作" class="headerlink" title="4.3 视频制作"></a>4.3 视频制作</h2><h3 id="infinite-zoom-无限放大扩展"><a href="#infinite-zoom-无限放大扩展" class="headerlink" title="infinite zoom 无限放大扩展"></a>infinite zoom 无限放大扩展</h3><p>​可以将图片无限延伸成为视频</p><h3 id="Deforum"><a href="#Deforum" class="headerlink" title="Deforum"></a>Deforum</h3><p>最近大火的可以将图片转出视频的插件，</p><h2 id="4-4-精准绘图"><a href="#4-4-精准绘图" class="headerlink" title="4.4 精准绘图"></a>4.4 精准绘图</h2><p> 骨架等识别</p><p> 3d-open-pose-editor插件</p><p> Openpose-editor（骨架编辑）</p><p>用来编辑人体骨架，可以从已有照片中自动检测生成。结合controlnet，可以生成指定姿势的人物。可以大大提高出图的可控性。</p><h2 id="4-5-抠图神器"><a href="#4-5-抠图神器" class="headerlink" title="4.5 抠图神器"></a>4.5 抠图神器</h2><p>Segment-anything（抠图神器）</p><h1 id="5-自身内置"><a href="#5-自身内置" class="headerlink" title="5 自身内置"></a>5 自身内置</h1><p><strong>X&#x2F;Y plot &amp; Prompt matrix</strong></p><p>prompt matrix和x&#x2F;y plot多用于演示,都是生成一个有好几张图组成的多格图、当你想要对比一个或多个词(艺术风格、人物细节描述等等)对最后图片的影响(prompt matrix的使用场景)亦或是一个或多个参数的不同值下(不同扩散次数、不同cfg值等等)生成的不同图片对比结果(x&#x2F;y plot的使用场景)</p><p><a href="https://zhuanlan.zhihu.com/p/637138476">【基础篇 第五课】Stable Diffusion 出图必备脚本神器 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（五）高清作图、高清修复</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>如何优化出图质量，产出更高清，分辨率更高，更有细节的绘画作品呢？</p><p>之前为了提高绘画质量，我们学习了诸多的提示词，选用了更优的模型</p><p>同时我们了解到，越高的分辨率意味着模型有着更大的发挥空间，细节会更好，但是受限于直接放大图片分辨率产生的多头多脚的问题，同时大的分辨率可能会直接爆显存，那么我们该怎么办呢</p><p>本节我们了解更多的放大算法，使得AI画出的图更加有质感</p><p>涉及方法主要有：</p><p><strong>高分辨率修复</strong></p><p><strong>Upscale脚本</strong></p><p><strong>附加功能中的图片放大算法</strong></p><p>他们各有优缺点</p><p>我们首先生成一张原图</p><p>输入正向提示词</p><blockquote><p>cinematic photo official art,unity 8k wallpaper,ultra detailed,aesthetic,masterpiece,best quality,photorealistic,entangle,mandala,tangle,entangle,1girl,cowboy shot,ecstasy of flower,dynamic angle,the most beautiful form of chaos,elegant,a brutalist designed,vivid colours,romanticism,atmospheric . 35mm photograph, film, bokeh, professional, 4k, highly detailed, skin detail realistic, ultra realistic, long hair, straight hair, eyes detail</p></blockquote><p>输入反向提示词</p><blockquote><p>(worst quality:1.5), (low quality:1.5), (normal quality:1.5), lowres, bad anatomy, bad hands, multiple eyebrow, (cropped), extra limb, missing limbs, deformed hands, long neck, long body, (bad hands), signature, username, artist name, conjoined fingers, deformed fingers, ugly eyes, imperfect eyes, skewed eyes, unnatural face, unnatural body, error, painting by bad-artist<br>layman work, worst quality, ugly, (deformed|distorted|disfigured:1.21), poorly drawn, bad anatomy, wrong anatomy, mutation, mutated, (mutated hands AND fingers:1.21), bad hands, bad fingers, loss of a limb, extra limb, missing limb, floating limbs, amputation, Yaeba, photo, deformed, black and white, realism, disfigured, low contrast, long neck</p></blockquote><p>初始分辨率设置为了640*704</p><img src="原图.png" class="lazyload placeholder" data-srcset="原图.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原图" style="zoom:50%;" /><p>#1 高清修复</p><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>先绘制一份低分辨率的图像</p><p>再根据它重绘第二幅高分辨率的图像</p><h2 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h2><p>先在低分辨率的情况下反复抽卡尝试，有满意的图之后，固定随机种子，进行高分辨率修复</p><p>（1）查看图片随机种子，填入种子栏</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110407249.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110407249.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110407249"></p><p>（2）在文生图界面出图设置栏勾选高清修复</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110504309.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110504309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110504309"></p><p>勾选高清修复后会出现两行新的参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110812405.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110812405.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110812405"></p><p>（3）出图参数设置</p><p><strong>1 放大算法</strong>  将低分辨率打回重画的方法，这里我们一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 高清修复采用次数</strong>   维持0不变即可，意味着和原图采样次数一样是20 </p><p><strong>3 重绘幅度</strong>  等图于图生图里的重绘幅度，和原图有多像，一般维持在0.5以下</p><p><strong>4  尺寸设置</strong> 将图片由原始的分辨率放大到多少，</p><p>​放大倍率就是放大几倍</p><p>点击 出图如下</p><img src="高清修复.png" class="lazyload placeholder" data-srcset="高清修复.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="高清修复" style="zoom:33%;" /><p>比较一下 细节</p><img src="image-20230823111953209.png" class="lazyload placeholder" data-srcset="image-20230823111953209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823111953209" style="zoom:67%;" /><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><p>​（1）不会改变画面构图，由随机种子固定即可</p><p>​（2）操作简单</p><p>​（3）稳定克服多人，多头情况</p><p>缺点</p><p>​（1）仍然需要较大的显存，而且能画多大依然受到显存的限制</p><p>​（2）计算速度相对较慢，，耗费较长时间</p><h1 id="2-UpScale-放大脚本"><a href="#2-UpScale-放大脚本" class="headerlink" title="2 UpScale 放大脚本"></a>2 UpScale 放大脚本</h1><p>第一种方法依然受到显存限制，所以但这种方法就不受影响啦</p><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>​将图片打成不同块，每一块分别绘制</p><h2 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h2><p>这是属于图生图的功能</p><p>​这里有一个小技巧，点击图片预览下方的图生图，可以把刚刚文生图生成的图片移动到图生图，同时各种参数设置，提示词，模型都会复制一份</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823211634513.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823211634513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823211634513"></p><p>​（1）点击脚本一栏，选择使用SD放大</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823102859699.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823102859699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823102859699"></p><p>（2）参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823212157442.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823212157442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212157442"></p><p><strong>1 放大算法</strong> 我们选择和1高清修复一样的即可，二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 图块重叠的像素</strong>，原理部分我们讲到，UpScale 是通过打成不同的块进行的，因而块与块之间要缝合需要一定的像素过渡，一般维持默认64即可</p><p><strong>3 缩放系数</strong> 将图片由原始的分辨率放大到多少倍</p><p>点击生成</p><p>比较一下细节</p><p><strong><img src="img\Stable_diffusion\image-20230823212328217.png" class="lazyload placeholder" data-srcset="img\Stable_diffusion\image-20230823212328217.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212328217" style="zoom: 50%;" /></strong></p><h2 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h2><p>优点</p><p>​（1）可以突破内存限制，获得更大的分辨率，速度较快</p><p>​（2）画面精度更高</p><p>缺点</p><p>​（1）分割过程较为不可控</p><p>​（2）操作比较繁琐</p><h1 id="3-附加功能放大"><a href="#3-附加功能放大" class="headerlink" title="3 附加功能放大"></a>3 附加功能放大</h1><p>用于图片后期处理</p><p>用于两种算法放大</p><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>附加功能的放大，相当于重绘幅度为0的Upscale</p><h2 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h2><p>这里也有一个小技巧，点击图片预览下方的添加到附加功能，可以把刚刚文生图生成的图片移动到附加功能一栏中，同时各种参数设置，提示词，模型都会复制一份</p><p>（1）参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823212634383.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823212634383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212634383"></p><p><strong>1 缩放比例</strong>  将图片由原始的分辨率放大到多少倍</p><p><strong>2 Upscale1</strong> ，放大算法 同上面讲到的，一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>3 其他设置</strong>  Upscale2  可见度什么的维持默认即可</p><p>点击生成</p><p>比较一下细节</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823213027789.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823213027789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823213027789"></p><h2 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h2><p> 优点</p><p>​（1）简单，方便，计算快</p><p>​（2）完全不改变图片内容</p><p>缺点</p><p>​（1）细节上不如前两种方法</p><p><a href="https://zhuanlan.zhihu.com/p/623014034">AI绘画教程：如何在stable diffusion中生成高清大图？ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（六）局部重绘</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<p>之前我们熟悉了AI绘画的各类模型，提示词写法，图像放大等技巧。但我们目前所有的操作都是针对整张图片的。</p><p>但是我们有些时候会遇到这样一种情况，就是我们生成的图片整体满意，但是一些细节，如手部绘画不满意，这时候该怎么办呢？打回炉子重新画一遍吗？</p><p>这样可能会面临的一个问题是</p><p>（1）如果本身AI绘画的分辨率比较高，那么意味着再画一次需要很长时间</p><p>（2）更重要的是，增加我们想要的提示词，对提示词做改变后，画面内容可能发现较大的变化</p><p>因而，用我们今天的局部重绘功能就可以很好解决这个问题啦</p><p>当然局部重绘还有更多的发挥空间</p><p>​如删除画面中自己不想要的物品，人物，增添自己想要的人物等等……</p><p>局部重绘是图生图的下属功能</p><h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h1><p>首先在文生图生成一张图片</p><p>![00160-1889848896-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00160-1889848896-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)</p><p>点击图库浏览器里或浏览图下方的局部重绘按钮，就可以跳转到图生图的局部重绘功能</p><h2 id="1-1-步骤1-补充提示词"><a href="#1-1-步骤1-补充提示词" class="headerlink" title="1.1 步骤1 补充提示词"></a>1.1 步骤1 补充提示词</h2><p>局部重绘也依然需要提示词</p><p>比如我们想在这个的基础上让这个女生戴一个帽子，那么我们就要在正向提示词里加上(a hat:1.4) 同时这里一定要给一定的权重加强1.4   否则就不能正常的展示效果<img src="/img%5CStable_diffusion%5Cimage-20230902114649762.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902114649762.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114649762"></p><h2 id="1-2-步骤2-绘制蒙版"><a href="#1-2-步骤2-绘制蒙版" class="headerlink" title="1.2 步骤2 绘制蒙版"></a>1.2 步骤2 绘制蒙版</h2><p>蒙版是什么呢？就是要通过蒙版选定区域告诉模型我们要对哪些区域做处理</p><p>用黑色的画笔在图像上画黑色的蒙版</p><p>右上角画笔一样的按钮<strong>可以调整画笔粗细</strong></p><p>圆圈表示 重新画蒙版</p><p>叉号表示关闭当前图像</p><p><img src="/img%5CStable_diffusion%5Cimage-20230825163450914.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230825163450914.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230825163450914"></p><p>在这里我们要给女生重新加一个帽子，</p><p>需要让模型重新绘制头部上方，因而我们用模板把头部上方画一画即可</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902114938059.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902114938059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114938059"></p><h2 id="1-3-步骤3-参数设置"><a href="#1-3-步骤3-参数设置" class="headerlink" title="1.3 步骤3 参数设置"></a>1.3 步骤3 参数设置</h2><p><strong>重绘幅度</strong>在0.7到0.8之间</p><p><strong>蒙版模糊</strong></p><p>局部重绘使用的就是蒙版来确定绘图的区域，如果只改变蒙版内或者蒙版外的内容，那么边缘处就会突变，很不协调，所以蒙版模糊可以理解成PS中的羽化，用来控制蒙版过渡效果，越大过渡越平滑。</p><p>设置10以下的模糊可以让重绘区域拼接进去更加丝滑</p><p><strong>蒙版模式</strong>  </p><p>选重绘蒙版内容，则会重新绘制黑色蒙版画住的</p><p>选重绘非蒙版内容，就是会重新绘制黑色区域画住以外区域的</p><p><strong>蒙版蒙住的内容</strong> 可以理解为把蒙版交给模型时候的内容</p><p>选原图的话采用原图作为重绘底图，通常选这个就好，AI模型发挥空间较小，会比较遵循原图</p><p>选填充，用蒙版边缘像素填充作为重绘底图，则会让AI模型有较大的发挥空间  ，可以综合对比几种方式</p><p><strong>重绘区域</strong></p><p>选仅蒙版 涉及区域小，绘制速度更快，但由于没有读取全貌，有些时候出图会比较奇怪</p><p>选全图，整张输入</p><p>一般情况建议重绘全图</p><p><strong>边缘预留像素</strong>    充当缓冲带作用，可以让新生成的内容与原图更好的融合在一起（一般25-35就行）</p><p>其他设置基于与文生图内操作一致，选择采样方式、迭代步数等，这里建议在使用局部重绘时，要选择与原图一致的设置，从而可以确保重绘效果。</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902115002095.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902115002095.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902115002095"></p><p>点击生![00154-1538941015-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00154-1538941015-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)成</p><h1 id="2-局部重绘其他应用"><a href="#2-局部重绘其他应用" class="headerlink" title="2.局部重绘其他应用"></a>2.局部重绘其他应用</h1><h2 id="2-1-手绘蒙版"><a href="#2-1-手绘蒙版" class="headerlink" title="2.1 手绘蒙版"></a>2.1 手绘蒙版</h2><p><img src="/img%5CStable_diffusion%5Cimage-20230902123316514.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902123316514.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123316514"></p><p>和第1节讲到的局部重绘类似，不同的是，会融入颜色信息</p><p>可以通过颜色选择器可以选取颜色</p><p>我们这里选取红色，给女生画一个红色的帽子</p><p>这里和第1节的提示词，参数设置都一样，就是选取了红色绘制蒙版而已</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902123616396.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902123616396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123616396"></p><p>点击生成</p><p>![00155-2457917830-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00155-2457917830-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)</p><h2 id="2-2-删除某些东西"><a href="#2-2-删除某些东西" class="headerlink" title="2.2 删除某些东西"></a>2.2 删除某些东西</h2><p>只需要将我们想要删除的东西用蒙版画好</p><p>然后在负面提示词里增加删除的东西</p><p>比如我们想让这个女生摘掉眼镜</p><p>![00179-17401323-A beautiful girl, Wear glasses, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemati](00179-17401323-A beautiful girl, Wear glasses, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemati.png)</p><p>负面提示词里加 戴眼镜</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902153701635.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902153701635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153701635"></p><p><img src="/img%5CStable_diffusion%5Cimage-20230902153720702.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902153720702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153720702"></p><p>点击生成</p><p>![00158-1817286803-A beautiful girl, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinematic sensual, Sha](00158-1817286803-A beautiful girl, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinematic sensual, Sha.png)</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（四）图生图</title>
      <link href="/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/"/>
      <url>/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>前段时间有一个风靡全网的真人转漫画风格，受到了大家的喜欢</p><p>而在SD里，就可以通过图生图来实现类似的效果</p><p>当然图生图还有更好玩的应用，我们一点一点来探索</p><p>首先我们来简单进行一下图生图的这一个实践—真人转动漫</p><h2 id="1-图生图基本界面"><a href="#1-图生图基本界面" class="headerlink" title="1. 图生图基本界面"></a>1. 图生图基本界面</h2><p>和文生图基本界面差不多，多了一个上传图像区</p><h2 id="2-图生图步骤"><a href="#2-图生图步骤" class="headerlink" title=" 2.图生图步骤"></a><img src="/img%5CStable_diffusion%5Cimage-20230817104804853.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230817104804853.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817104804853"> 2.图生图步骤</h2><h3 id="2-1-导入图片"><a href="#2-1-导入图片" class="headerlink" title="2.1 导入图片"></a>2.1 导入图片</h3><p>准备一张真人图像</p><p><img src="/img%5CStable_diffusion%5CSnipaste_2023-08-18_22-20-40.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5CSnipaste_2023-08-18_22-20-40.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-08-18_22-20-40"></p><p>导入有两种方式</p><p>（1）点击上传图像区，打开资源管理器选取</p><p>（2）直接将图片拖拽到上传图像区</p><h3 id="2-2-写提示词"><a href="#2-2-写提示词" class="headerlink" title="2.2 写提示词"></a>2.2 写提示词</h3><p>提示词很重要，也需要提示词的准确</p><p>用自然语言描述一下我们的画面内容，一开始我们可以偷个懒，就写一个</p><blockquote><p>1man即可</p></blockquote><p>再把我们的固定模板加上</p><blockquote><p>正面提示词后添加：<br>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p></blockquote><blockquote><p>负面提示词后添加：<br>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p></blockquote><h3 id="2-3参数设置"><a href="#2-3参数设置" class="headerlink" title="2.3参数设置"></a>2.3参数设置</h3><p> 图生图参数设置和文生图差不多</p><p>有一个比较独特的就是下面的重绘幅度</p><p><strong>重绘幅度</strong>  ，通俗理解就是他跟原图有多像</p><p>一般我们为了实现这种图生图效果，会降低一些重绘幅度，维持在6-8之间即可，太低或太高都不太好</p><p><strong>图像设置宽高</strong>，一般和我们输入图像大小保持一致</p><p>​如果输入图像太大，显存吃不消，那么我们至少保证比例一致，比如原图是3000*3000像素，那么我们就等比例缩放到1024 *1024</p><p>采样方法选择DPM++2Mkarras</p><p>其他选择和图生图一样，可以维持默认不变</p><p><img src="/img%5CStable_diffusion%5Cimage-20230818224818756.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230818224818756.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818224818756"></p><p>点击生成就可以生成</p><p><img src="/123.png" class="lazyload placeholder" data-srcset="/123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="123"></p><p>但是发现差别还是蛮大的，原因是我们内容提示词对人物描述不够</p><p>我们把1man 换成 1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,short hair,Blue jeans</p><p>多了更多的服饰，面部细节等的描述，再点击生成</p><p>![00062-262499971-1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,sho](00062-262499971-1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,sho.png)</p><p>整体会好多了</p><h2 id="3-巧用随机种子"><a href="#3-巧用随机种子" class="headerlink" title="3. 巧用随机种子"></a>3. 巧用随机种子</h2><p>如果我们对这个人物整体很满意了，但是一些细节还想微调，我们就要用到随机种子了</p><p>在图片生成区下方，可以查看随机种子</p><p><img src="/img%5CStable_diffusion%5Cimage-20230818230647705.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230818230647705.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818230647705"></p><p>然后把我们的随机种子从-1改为262499971</p><p>这时候我们点击生成，会发现生成的图片几乎和之前的一模一样，不论你点多少次</p><p>然后这时候我们对自己不满意的提示词进行微调，如让男主穿牛仔裤，看向镜头等，再点击生成即可</p><p>![00074-262499971-1man,(Blue jeans_1.1),(black suits_1.1),Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,](00074-262499971-1man,(Blue jeans_1.1),(black suits_1.1),Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,-1692515162052.png)</p><h2 id="4-拓展应用"><a href="#4-拓展应用" class="headerlink" title="4. 拓展应用"></a>4. 拓展应用</h2><p> 动漫转真人，真人转动漫都是比较好玩的</p><p>当然除了这些，我们还可以把一张本来不是真人的物体，用真人的提示词去进行拟人化</p><p>除此之外还可以</p><p>将随机涂鸦的场景转换为好看的动漫风格图片</p><p>其他关于图生图进阶用法，我们会在另外的文章里讲到</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（三）AI绘画模型基础</title>
      <link href="/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>想要做出好的AI绘画，模型是最重要的，他相当于AI绘画的大脑，决定了AI绘画质量的上限，所以了解AI绘画的各种模型非常重要</p><p>相比于Midjourney，Stable Diffusion<strong>最大的优势就是开源</strong>。</p><p>因而<strong>SD则每时每刻都有人在世界各地训练自己的模型并免费公开共享给全世界的使用者</strong>。当然我们也可以训练自己的专属模型</p><p>提示词+模型+参数设置</p><p>全能型赛博画手</p><p>首先我们来了解一下模型的基本分类</p><h2 id="1-模型基本分类"><a href="#1-模型基本分类" class="headerlink" title="1.模型基本分类"></a>1.模型基本分类</h2><p>具体模型类型有checkpoint、Textual lnversion、Hypernetwork、Aesthetic Gradient、LoRA、LyCORIS、Controlnet、Poses、wildcards等等</p><p>常用的有checkpoint</p><p>哇塞，这么多，那么这些究竟都是什么意思呢？</p><h3 id="1-1-CheckPoint-大模型-底模型-主模型"><a href="#1-1-CheckPoint-大模型-底模型-主模型" class="headerlink" title="1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型"></a>1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型</h3><p>检查点，常玩游戏的朋友肯定不陌生，一般会在一些节点存档</p><p>一个大的模型训练起来是非常费力的，如果每次迭代我们都从头训练那可真实个灾难，因而训练到一定程度我们就给模型存档，生成一个关键点Checkpoint模型，</p><p><strong>常见文件后缀</strong>:后缀ckpt、safetensors（如果都有提供的话建议下载safetensors，下同）</p><p><strong>存放路径</strong>: 根目录\models\Stable-diffusion</p><p><strong>占用存储：</strong> 模型较大，占用3-7GB</p><p>我们这里的根目录都是指我们<strong>webui的最外层的那个文件夹，比如我这里的是stable-diffusion-webui</strong></p><p><strong>使用方法</strong>  将模型移动到根目录\models\Stable-diffusion后，在webui界面点击刷新按钮，再点下拉就可以看到了</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819103854526.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819103854526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819103854526"></p><p>模型推荐</p><p>二次元模型</p><p>​ menia mix  生成动漫</p><p>​AbyssOrangeMix 深源橘</p><p>​counter-feit v2.5  动漫模型</p><p>​dream Shper v5  模型   肖像画 梦幻的插画风格</p><p>真实系模型</p><p>​realistic vision v2.0 现实模型</p><p>​Delibe-rate   比较全能的一个模型</p><p>在本章第二节可以看到如何利用其他网站来筛选自己需要的模型</p><h3 id="1-2-VAE美化模型-变分自编码器"><a href="#1-2-VAE美化模型-变分自编码器" class="headerlink" title="1.2 VAE美化模型&#x2F;变分自编码器"></a>1.2 VAE美化模型&#x2F;变分自编码器</h3><p>从使用来看，我们可以把他粗略的理解为“调色滤镜”  有些时候不加载VAE的情况下，出图就会发灰发白</p><p>有很多比较新的大模型是会将VAE整合到内部的，比如Chilloutmix。如果再加VAE则可能画面效果不会更好，甚至适得其反</p><p>而有的大模型则会有自己适配的VAE，如深渊橘，这里看模型网站上作者的推荐就好</p><p>也有一些适用于大多数模型的VAE</p><p>二次元风格：kf-f8-anime</p><p>写实风格:840000</p><p><strong>常见文件后缀</strong>:后缀ckpt、pt</p><p><strong>存放路径</strong>: 根目录&#x2F;models&#x2F;VAE</p><p><strong>占用存储：</strong> 模型较小，占用0-1个GB</p><p><strong>使用方法</strong>  将模型移动到根目录\models\VAE后，在VAE选项点击刷新按钮，再点下拉就可以看到了</p><h3 id="1-3-HyperNetwork-超网络"><a href="#1-3-HyperNetwork-超网络" class="headerlink" title="1.3 HyperNetwork 超网络"></a>1.3 HyperNetwork 超网络</h3><p>hypernetworks是一个附加到stable diffusion model上的小型网络，用于微调，和embedings类似，不过现在用的也不是很多了，因为它的功能基本可以被smbeddings替代了</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;models&#x2F;hypernetworks</p><p><strong>占用存储：</strong> 模型较小，占用几百MB</p><p><strong>使用方法</strong>  注意HyperNetwork，embeddings这种微调网络和大模型使用方法不同</p><p>（1）将模型放到  根目录&#x2F;models&#x2F;hypernetworks</p><p>（2）首先点击生成按钮下的从左往右数的第三个，然后点击超网络，再点击需要用到的超网络模型，就会在提示词中添加相应的尖括号内容，如本例中的<hypernet></p><p><img src="/img%5CStable_diffusion%5Cimage-20230820103415473.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820103415473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820103415473"></p><h3 id="1-4-embeddings（-Textual-Inversion）-嵌入式向量"><a href="#1-4-embeddings（-Textual-Inversion）-嵌入式向量" class="headerlink" title="1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量"></a>1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量</h3><p>（1）优化画风,</p><p>（2）通过仅使用的几张图像，向模型教授新的概念，比如AI不知道奥特曼，通过embeddigns就可以让AI知道奥特曼长什么样子</p><p>（3）减少提示词的输入，比如EasyNegative这个Embeddings，里面包含了大量的负面词，可以减少你每次打一堆负面词的痛苦，解决AI绘画痛点，如画手等等</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p>模型的切换通过文件名称来触发</p><p><strong>占用存储：</strong> 模型很小，占用几十kB到几百kB</p><p><strong>使用方法:</strong></p><p>（1）将模型放到  根目录&#x2F;embeddings目录下</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击嵌式入，再点击需要用到的嵌入式模型，就会在提示词中添加相应的尖括号内容</p><h3 id="1-5-loRa-低秩适应模型"><a href="#1-5-loRa-低秩适应模型" class="headerlink" title="1.5 loRa 低秩适应模型"></a>1.5 loRa 低秩适应模型</h3><p>进行人物模型的微调，</p><p>让AI学习到一些新的人物概念</p><p><strong>常见文件后缀</strong>: 后缀safesensors</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p><strong>占用存储：</strong> 模型较小，10-200 MB。必须与checkpoint模型一起使用。</p><p><strong>使用方法:</strong> </p><p>（1）将模型放到  根目录&#x2F;models&#x2F;Lora</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击Lora，再点击需要用到的Lora模型，就会在提示词中添加相应的尖括号内容</p><p>除了这些以外还有DreamBooth模型，LyCORIS模型等等，这些模型在模型的进阶用法给大家介绍</p><h2 id="2-下载途径和渠道"><a href="#2-下载途径和渠道" class="headerlink" title="2. 下载途径和渠道"></a>2. 下载途径和渠道</h2><p>SD官方会发布模型</p><p>但是官方这个模型出图风格比较单一，因而我们现在下载使用的大多是私人训练的</p><p>主流下载网站</p><h3 id="2-1-C站"><a href="#2-1-C站" class="headerlink" title="2.1 C站"></a>2.1 C站</h3><p>需要科学上网  C站是最主流的一个AI绘画模型网站了，对于模型都是图像化展示，非常便捷</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105707494.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105707494.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105707494"></p><h4 id="2-1-1-如何筛选到自己需要的模型"><a href="#2-1-1-如何筛选到自己需要的模型" class="headerlink" title="2.1.1 如何筛选到自己需要的模型"></a><strong>2.1.1 如何筛选到自己需要的模型</strong></h4><p><strong>1 通过模型生成内容区分查找  模型栏目上边有一排可以选择的</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111507513.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111507513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111507513"></p><p><strong>2 利用我们第一节讲到的模型类型区分</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111606100.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111606100.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111606100"></p><h4 id="2-1-2-使用技巧"><a href="#2-1-2-使用技巧" class="headerlink" title="2.1.2 使用技巧"></a>2.1.2 使用技巧</h4><p>注意模型的各种信息，包括作者推荐的VAE，分辨率设置，采样方式等等</p><p>如我们点击进入ReV Animated这个模型的下载界面，在模型的介绍界面里有show More</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105040732.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105040732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105040732"></p><p>然后就可以看到作者推荐的VAE啦，提示词prompting啦之类的</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105202493.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105202493.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105202493"></p><p>初学可以使用别人推荐的一些大模型</p><p>[stable diffusion 常用大模型解释和推荐（持续更新ing） - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/631941039#:~:text=stable">https://zhuanlan.zhihu.com/p/631941039#:~:text=stable</a> diffusion 常用大模型解释和推荐（持续更新ing） 1 基础模型（不推荐） SD系列 比如sd-v1-4、sd-v1-5、sd-v2（简写成SD1.5、SD2.0）之类的大模型，这些都是Stable-Diffusion自带的大模型，分别是1.4、1.5和2.0版本。 目前的话1.5版本更好用一些，但是,亚洲美女模型 。 … 4 2.5D%2F数绘风格 PerfectWorld 欧美版的Chilloutmix，主要绘制欧美风格的美女，不过偏2.5D，介于动漫和写实之间。 )</p><h4 id="2-1-3-学习他人作品"><a href="#2-1-3-学习他人作品" class="headerlink" title="2.1.3 学习他人作品"></a>2.1.3 学习他人作品</h4><p>C站除了优秀的模型以外，还会有很多优秀的作品，我们可以学习他们的模型搭配，提示词等等</p><p>点击C站的Images</p><p><img src="/img%5CStable_diffusion%5Cmage-20230820105459668.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cmage-20230820105459668.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105459668"></p><p>点进去以后就可以看到详细的图片生成信息,模型搭配，提示词，采样方式，种子等等</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105538667.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105538667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105538667"></p><h3 id="2-2-HuggingFace"><a href="#2-2-HuggingFace" class="headerlink" title="2.2 HuggingFace"></a>2.2 HuggingFace</h3><p>不需要科学上网，网速较快</p><p><a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105627701.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105627701.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105627701"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（二）AI提示词</title>
      <link href="/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
      <url>/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>Prompts提示词是指用户输入的指导模型生成图像的文本信息，他是我们要告诉AI 我要画什么，怎么画最方便的方式</p><p>可以想象我们是呼风唤雨的魔法师，那么Promts就好比我们的咒语</p><p>不过有些时候我们的咒语不那么灵验，因为我们的AI绘画具有随机性，所以需要多多尝试</p><p>我们知道AI绘画可以图生图，但是即便图生图也会依赖好的提示词</p><p>接下来我们就从提示词规则，分类等来快速入门提示词</p><p>首先我们来来了解提示词基本规则</p><h2 id="1-提示词-基本的规则"><a href="#1-提示词-基本的规则" class="headerlink" title="1.提示词 基本的规则"></a>1.提示词 基本的规则</h2><p>（1）英文书写  可以求助翻译软件</p><p>（2）词组作为单位，不需要主谓宾句子结构</p><p>​比如画一个在阳光下骑车的男孩</p><p>​提示词写为  男孩，骑车，阳光下即可</p><p>（3）提示词分隔符英文逗号，</p><p>（4）提示词可以换行，但每一行结尾要打上分隔符,</p><h2 id="2-提示词分类"><a href="#2-提示词分类" class="headerlink" title="2.提示词分类"></a>2.提示词分类</h2><p>提示词不是一下子写好的，是先有雏形，然后再慢慢微调得到的</p><p>提示词也不是混乱不堪的，优秀的提示词分别包含以下内容，我们可以按照顺序依次填写自己需要的</p><h3 id="2-1内容性提示词"><a href="#2-1内容性提示词" class="headerlink" title="2.1内容性提示词"></a>2.1内容性提示词</h3><p>内容性提示词实际上就是告诉AI绘画我们要画什么</p><p><strong>人类以及主体</strong></p><p>​服饰穿搭 pink dress,</p><p>​发型发色  long hair  black hair</p><p>​五官特点 big eyes,small mouth</p><p>​面部表情  laughing</p><p>​肢体动作  stretching arms</p><p><strong>场景特征</strong></p><p>​室内  indoor</p><p>​室外  outdoor</p><p>​大场景 forest，city</p><p>​小细节 bush, a white flower</p><p><strong>环境光照</strong></p><p>​白天   day</p><p>​黑夜   night</p><p>​特定时段  morning</p><p>​光环境  sunlight</p><p>​天空  blue sky</p><h3 id="2-2-画风艺术派提示词"><a href="#2-2-画风艺术派提示词" class="headerlink" title="2.2 画风艺术派提示词"></a>2.2 画风艺术派提示词</h3><p>​插画风illustration </p><p>​二次元   anime ，comic ，game CG</p><p>​写实系   photo realistic，realistic，photograph</p><h3 id="2-3-画幅视角"><a href="#2-3-画幅视角" class="headerlink" title="2.3 画幅视角"></a>2.3 <strong>画幅视角</strong></h3><p>​距离  close-up,distant</p><p>​人物比例   full body,upper body</p><p>​观察视角   from above,view of back</p><p>​镜头类型  wide angle m Sony A7 III</p><h3 id="2-4画质提示词"><a href="#2-4画质提示词" class="headerlink" title="2.4画质提示词"></a>2.4画质提示词</h3><p>通用高画质</p><p>​best quailty</p><p>​ultra-detailed</p><p>​masterpiece</p><p>​hires</p><p>​8k</p><p>特定高分辨率类型</p><p>​extremely detailed CG unity 8k wallpaper （超精细8k Unity 游戏CG）</p><p>​unreal engine rendered（虚幻引擎渲染）</p><h2 id="3-反向提示词"><a href="#3-反向提示词" class="headerlink" title="3 反向提示词"></a>3 反向提示词</h2><h3 id="3-1-内容性反向提示词"><a href="#3-1-内容性反向提示词" class="headerlink" title="3.1 内容性反向提示词"></a>3.1 内容性反向提示词</h3><p>single background 单一背景</p><p> bad hands 不好的手</p><p>missing fingers 缺少手指</p><p>bad anatomy 身体姿态不良</p><p>long neck 长脖子</p><p>mutated hands 突变的手</p><p>poorly drawn hands 画的不好的手</p><p>poorly drawn face 画的不好的脸</p><p>missing arms 缺少手臂</p><p>missing legs 缺少腿</p><p> extra arms 缺少胳膊</p><p>extra legs 缺少腿</p><h3 id="3-2-画质性反向提示词"><a href="#3-2-画质性反向提示词" class="headerlink" title="3.2 画质性反向提示词"></a>3.2 画质性反向提示词</h3><p>worst quality, 最差质量</p><p>low quality 低质量</p><p>上述大概了解有哪些，我们后续会对于一些人物有一些特定模板可以直接用</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4 实例分析"></a>4 实例分析</h2><p><strong><img src="/img%5CStable_diffusion%5Cimage-20230817101306166.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230817101306166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817101306166"></strong></p><p>正向提示词</p><blockquote><p>&lt;!–swig￼0–&gt;, &lt;!–swig￼1–&gt;,<br> little girl, grey long hair , blue eyes, shirt, hat, hoodie, shoes , headphones, smirk, cute face, head tilt,<br>outdoor, forest,bush,  sunlight,<br>illustration,<br>full body</p></blockquote><p>反向提示词</p><blockquote><p>signature, watermark, username, blurry, missing arms, long neck, humpbacked, bad feet, {bad anatomy},single background, {bad hands},missing fingers,<br>{lowres}, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, artifacts, nsfw,</p></blockquote><p>一般而言，优质出图有一定的固定模板</p><h2 id="5-权重"><a href="#5-权重" class="headerlink" title="5 权重"></a>5 权重</h2><p>观察别人的提示词咒语，会发现有很多的括号</p><h3 id="5-1-方法一"><a href="#5-1-方法一" class="headerlink" title="5.1 方法一"></a>5.1 方法一</h3><p><strong>括号加数字</strong></p><p>​示例：</p><p>​{a white flower :1.5} 调节白花权重为原来1.5倍</p><p>​{white flower:  0.8} 调节白花权重为 0.8倍</p><h3 id="5-2-方法二"><a href="#5-2-方法二" class="headerlink" title="5.2 方法二"></a>5.2 方法二</h3><p><strong>套括号</strong></p><p> 适合于微调</p><p>提示词套圆括号（）</p><p>​每一层圆括号，权重×1.1</p><p>​比如两层圆括号，提示词权重1.1 *1.1&#x3D;1.331</p><p>提示词套大括号{}</p><p>​每一层大括号，权重×1.05</p><p>提示词套方括号[]</p><p>​每一层大括号，权重×0.9</p><p>经验：权重不能太高，最好小于1.5，否则会导致扭曲</p><p>提示词权重分配 进阶语法</p><p>​如混合，迁移，迭代</p><p>后面会给大家介绍</p><h2 id="6-参数"><a href="#6-参数" class="headerlink" title="6.参数"></a>6.参数</h2><p>如果把提示词比作咒语，那么参数是魔杖或者魔导书</p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>理论上采样步数越多画面越清晰，但超过２０步之后，后面的提升不大，增加步数意味着出图时间增长，一般维持在２０到４０之间即可</p><p>以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="7-学习and-技巧"><a href="#7-学习and-技巧" class="headerlink" title="7. 学习and 技巧"></a>7. 学习and 技巧</h2><p>当然知道上面的知识还远远不够，需要多多学习他人写提示词的方式</p><p>写提示词</p><p>翻译大法，插件</p><p>利用AI工具  AI绘画提示词生成器，AI词语加速器</p><p>选择性  抄作业    openart.ai     arthub.ai</p><h3 id="7-1-辅助写提示词的网站"><a href="#7-1-辅助写提示词的网站" class="headerlink" title="7.1 辅助写提示词的网站"></a>7.1 辅助写提示词的网站</h3><p>（1）AI绘画提示词生成器</p><p><a href="http://www.atoolbox.net/Tool.php?Id=1101">AI绘画提示词生成器 - 一个工具箱 - 好用的在线工具都在这里！ (atoolbox.net)</a></p><p>（2）AI 词汇加速器</p><p><a href="https://ai.dawnmark.cn/">AI词汇加速器 AcceleratorI Prompt (dawnmark.cn)</a>权重设置</p><p>使用这些工具像是经历一个更方便的过程，但思路不要被他索限制</p><p>（3）词图</p><p><a href="https://www.prompttool.com/NovelAI">词图PromptTool - AI绘画</a></p><p>（4）AI创造者</p><p><a href="https://ai-creator.net/arts">AI creator - AI Creator|AI Art gallery | 创作者AI (ai-creator.net)</a></p><h3 id="7-2-学习他人优秀作品"><a href="#7-2-学习他人优秀作品" class="headerlink" title="7.2 学习他人优秀作品"></a>7.2 学习他人优秀作品</h3><p>有很多网站会放出优秀作品，其中的作者也会分享自己的prmpts，可供我们学习</p><p>（1） openart.ai   </p><p>​里面有很多基于sd官方模型和欧美模型的生成的作品</p><p>​<a href="https://openart.ai/home">Home | OpenArt</a></p><p>  （2）arthub.ai</p><p>​里面更多一些二次元和亚洲风的作品</p><p><a href="https://arthub.ai/">Arthub.ai: Discover, Upload and Share AI Generated Art</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（一）AI绘画quickly入门</title>
      <link href="/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><p>​在2012年，就有很多的学者对图像生成展开了研究，但在那时候，因为算法，数据，算力等各方面原因，生成的图像过于“抽象” ，可以称他为灵魂画手，直到最近两年，AI产出的图像内容在质量上和准确度上渐渐地变得更高，同时由于一些辅助装备，如ControlNet等让AI绘画可控性更高，也更受到大家的重视。</p><p>​现在的主流的AI绘画模型，主要运用了扩散Diffusion模型，他很人类绘画相比差异很大，不是起稿，勾线，描边，上色等步骤按部就班完成的，他采取了一个独特的方式</p><p>首先它将图片通过增加噪声的方式进行“扩散”，也就是让他变得更模糊，当内容模糊之后，我们就可以理解为有更大的空间让它自由发挥了，AI也是如此，但是在训练它的过程中，它可以学习到一种重要的能力，就是逐步恢复这种杂乱的噪声为真实图像</p><p>而如果在训练的过程中我们给AI 一些限制条件等，AI就可以按我们限制条件去恢复生成我们想要的图像了</p><h2 id="2-主流方式"><a href="#2-主流方式" class="headerlink" title="2.主流方式"></a>2.主流方式</h2><p><strong>Midjourney，DALL E等方式</strong></p><p>​（1）出图额度需要购买会员（换句话说就是需要付费）直接租价格比较贵，可以去租用共享账号</p><p>​（2）较容易出比较高质量的图</p><p>​（3）模型部署在云端，不需要本地电脑配置较高</p><p><strong>Stable Diffusion</strong></p><p>​（1）是一款免费的软件，可以无限制出图</p><p>​（2）但是有一定的上手门槛，出图质量需要较多的调控才能达到满意的效果，因而我们这系列教程主要围绕stable diffusion</p><p>​（3）部署在本地，比较吃电脑配置，显卡内存（也可以部署在GPU服务器）</p><p>​（4）但是由于开源，依托强大的开源社区，收获非常多的活跃用户，可以进行个性化的训练，个性化程度较高</p><h2 id="3-配置要求"><a href="#3-配置要求" class="headerlink" title="3.配置要求"></a>3.配置要求</h2><h3 id="3-1-显卡方面"><a href="#3-1-显卡方面" class="headerlink" title="3.1 显卡方面"></a>3.1 显卡方面</h3><p><strong>显卡品牌型号</strong> N卡（英伟达的独立显卡）首选，目前也支持A卡，但是速度较N卡慢</p><p>不同品牌型号，意味着显卡的算力不同，进而影响着出图的速度</p><p>查看自己的显卡品牌型号的方法如下链接  AI应用\Stable_Diffusion\image-20230814163822829.png</p><p><a href="https://zhuanlan.zhihu.com/p/462233007">分享几种查看本机显卡类型的方法~~ - 知乎 (zhihu.com)</a></p><p>查到以后可以对照下表 ，下表是不同型号N卡出一张512*512分辨率的图片，迭代步数为100步的时间 </p><p><img src="/img%5CStable_diffusion%5Cimage-20230814163822829.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814163822829.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815210656999"></p><p>图片来源 B站 Nenly同学</p><p><strong>显卡内存</strong>  最少8GB能玩，16GB及格，上不封顶，越高玩的越爽        内存主要影响着出图分辨率，模型大小等</p><p><strong>硬盘空间</strong>  最少有60GB以上的硬盘空间，因为我们需要下载很多模型，而一个模型往往都有几个GB</p><h2 id="4-基本界面"><a href="#4-基本界面" class="headerlink" title="4.基本界面"></a>4.基本界面</h2><p>下面界面是加了一些插件之后的，如中文插件，图库浏览器，如果你使用的是一些大佬的整合包，那么一般他们都会帮助你安装好，但是如果没有也无所谓，我们会在之后给大家讲解插件的安装</p><p><img src="/img%5CStable_diffusion%5Cimage-20230814164648622.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814164648622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164648622"></p><h3 id="4-1-模型设置区"><a href="#4-1-模型设置区" class="headerlink" title="4.1 模型设置区"></a>4.1 模型设置区</h3><p>左上角用来更换模型</p><p><img src="/img%5CStable_diffusion%5Cimage-20230814164736337.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814164736337.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164736337"></p><p>点击下拉箭头查看并且选择模型</p><p>模型需要我们提前下载并且保存到    根目录&#x2F;models&#x2F;Stable-diffusion文件夹下</p><p>当我们保存模型到上述文件夹下后，点击蓝色的刷新按钮，刷新模型，再点击下拉箭头就可以看到我们的模型了</p><h3 id="4-2-菜单栏区域"><a href="#4-2-菜单栏区域" class="headerlink" title="4.2 菜单栏区域"></a>4.2 菜单栏区域</h3><p><img src="/img%5CStable_diffusion%5Cimage-20230814165333774.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814165333774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814165333774"></p><p>一些基本功能</p><p>最常用的两个 文生图，图生图</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>文生图</td><td>由prompts提示词生成图片</td></tr><tr><td>图生图</td><td>由已有的图片+提示词生成图片</td></tr><tr><td>图库浏览器（后安装的插件）</td><td>查看生成的图片</td></tr><tr><td>Tag 反推</td><td>由图片反推提示词prompts</td></tr><tr><td>设置</td><td>进行一些设置操作</td></tr><tr><td>扩展</td><td>进行扩展安装管理等操作</td></tr></tbody></table><p>其他我们用到的时候再介绍</p><h3 id="4-3-提示词区"><a href="#4-3-提示词区" class="headerlink" title="4.3 提示词区"></a>4.3 提示词区</h3><p>最关键的一个区域，也就是我们念咒语的地方，这里用英语撰写（可以用翻译软件）</p><p><strong>正向提示词</strong>  希望画面出现的内容，一般我们会有一些固定的提示词，如（杰作masterpiece, 最高质量best quality，高细节）特定模型也会有特定的让画面质量变高的正向提示词</p><p><strong>反向提示词</strong>  不希望画面出现的内容，如（丑陋的，多手指的）</p><p>之后会给大家专门总结，到时候直接复制粘贴即可</p><p>提示词区右边的生成下边有五个小图标，相当于一些快捷键，从左到右依次为</p><p><img src="/img%5CStable_diffusion%5Cimage-20230815211951592.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230815211951592.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815211951592"></p><table><thead><tr><th>图标</th><th>作用</th></tr></thead><tbody><tr><td>箭头</td><td>复原上次生成图片的提示词（自动记录）</td></tr><tr><td>垃圾桶</td><td>清空当前所有提示词</td></tr><tr><td>红色日出</td><td>打开其他模型选择界面如Embedding，HypernetWork的选择，这些模型后面会单独讲到</td></tr><tr><td>记事薄</td><td>应用选择的风格模板到当前提示词，就是着五个小图标下面那个风格模板选项</td></tr><tr><td>保存按钮</td><td>保存当前的正反向提示词</td></tr></tbody></table><h3 id="4-4-出图设置区"><a href="#4-4-出图设置区" class="headerlink" title="4.4 出图设置区"></a>4.4 出图设置区</h3><p>如图</p><img src="img\Stable_diffusion\image-20230814165739102.png" class="lazyload placeholder" data-srcset="img\Stable_diffusion\image-20230814165739102.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img\Stable_diffusion\image-20230814165739102" style="zoom: 67%;" /><p><strong>从上到下，左到右依次介绍</strong></p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>之前讲原理的时候，模型将噪声一步一步恢复到真实图片，此参数控制这些去噪步骤的数量。通常越高越好，但在一定程度上，我们使用的默认值是25个步骤。以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="5-文生图基本操作流程"><a href="#5-文生图基本操作流程" class="headerlink" title="5.文生图基本操作流程"></a>5.文生图基本操作流程</h2><p>我们可能一下子了解不了这么多，大家可能都看困了，那么我们来亲自来出一张图，体验一下基本的过程，加深印象</p><h3 id="5-1-选用模型，撰写提示词"><a href="#5-1-选用模型，撰写提示词" class="headerlink" title="5.1 选用模型，撰写提示词"></a>5.1 选用模型，撰写提示词</h3><p>在左上角模型选取，选择深渊橘模型</p><p><strong>写提示词</strong></p><p><strong>画面内容</strong> 用自己的语言描述一个画面出来</p><p>如  一个女生在城市里骑着自行车，阳光洒在她的身上，但是提示词不认中文打开翻译软件，翻译即可</p><p>A girl rides a bicycle in the city, and the sunlight  shines on her</p><p>但仅有这个远远不够，不相信？给你看一下这样<strong>图片直出 有多离谱</strong></p><p>点击生成，喀嚓，生成如下</p><p>![00061-202973728-A girl rides a bicycle in the city and the sunlight  shines on her_b7c2db5a94e11e2b3e236598b41eaad053a308d7](00061-202973728-A girl rides a bicycle in the city and the sunlight  shines on her_b7c2db5a94e11e2b3e236598b41eaad053a308d7.png)</p><p>惨不忍睹，所以还需要加一些正面对画面质量这些约束的咒语</p><p><strong>在正向提示框加入</strong></p><p>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p><p><strong>反向提示框加入</strong></p><p>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p><h3 id="5-2-进行出图设置"><a href="#5-2-进行出图设置" class="headerlink" title="5.2 进行出图设置"></a>5.2 进行出图设置</h3><p>我们就将采样方式设置为 DPM++ 2M</p><h3 id="5-3-再次出图！"><a href="#5-3-再次出图！" class="headerlink" title="5.3 再次出图！"></a>5.3 再次出图！</h3><p>![00068-300861399-A girl rides a bicycle in the city, and the sunlight  shines on her_SFW, (masterpiece_1,2), best quality, masterpiece, highres,](00068-300861399-A girl rides a bicycle in the city, and the sunlight  shines on her_SFW, (masterpiece_1,2), best quality, masterpiece, highres,.png)</p><p>不能说有多好，但至少比刚才好了一些，当然后续还会介绍更多技巧提升画面质量</p><p>所以我们要意识到一点， stable diffusion 出一张好图是不容易的，这也是为什么显卡这些的重要性，它可以让我们低成本试错</p><h3 id="5-4-保存"><a href="#5-4-保存" class="headerlink" title="5.4 保存"></a>5.4 保存</h3><p>点击图库浏览器，可以查看生成的图片</p><p>想把他导出来</p><p>右键，另存为即可</p><p>或者找到根目录下的outputs文件夹</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/2020/09/14/categories/index/"/>
      <url>/2020/09/14/categories/index/</url>
      
        <content type="html"><![CDATA[<p>这里有我写过的相关的系列的文章，欢迎系统阅读！<br>如果对你有任何问题，可以给我反馈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/2020/09/14/tags/index/"/>
      <url>/2020/09/14/tags/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分类器整体</title>
      <link href="/2020/09/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/"/>
      <url>/2020/09/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图像表示"><a href="#1-图像表示" class="headerlink" title="1 图像表示"></a>1 图像表示</h2><ul><li>基础像素表示</li><li>全局特征表示 如GIST    比较适合风景类，室内场景，城市建筑。要依赖所有像素，对于如遮挡一类问题就不太适合了</li><li>局部特征表示 如GIST</li></ul><p>2012年前，就要找到一个很好的特征，但对于神经网路而言是无所谓的</p><h2 id="2-分类模型"><a href="#2-分类模型" class="headerlink" title="2 分类模型"></a>2 分类模型</h2><p>我们学习神经网络在学些什么？</p><p>其实就是在学</p><ol><li>这每一类分类器的优势，适用于哪些场合</li><li>这每一类分类器的原理，从而我们对于分类器做出合理的调整来解决具体问题</li></ol><p>常见分类器</p><ul><li>近邻分类器</li><li>贝叶斯分类器</li><li>线性分类器</li><li>支撑向量机分类器</li><li>神经网络分类器</li><li>随机森林</li><li>Adaboost<br>sd</li></ul><h2 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3 损失函数"></a>3 损失函数</h2><p>常见的损失函数</p><ul><li>0-1 损失</li><li>多类支撑向量机损失</li><li>交叉熵损失</li><li>L1损失</li><li>L2损失</li></ul><h2 id="4-优化方法"><a href="#4-优化方法" class="headerlink" title="4 优化方法"></a>4 优化方法</h2><p>一阶方法</p><ul><li>梯度下降</li><li>随机梯度下降</li><li>小批量随机梯度下降</li></ul><p>二阶方法</p><ul><li>牛顿法</li><li>BFGS</li><li>L-BFGS</li></ul><p>训练过程本身</p><ul><li>数据集划分</li><li>数据预处理</li><li>数据增强</li><li>欠拟合与过拟合</li><li>超参数调整</li><li>模型集成<img src="/img%5C1.jpg" class="lazyload placeholder" data-srcset="/img%5C1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1"></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
