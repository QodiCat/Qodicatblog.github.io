<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库系统（六）数据库规范</title>
      <link href="/2023/12/06/Computer_system/Database_system/5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/"/>
      <url>/2023/12/06/Computer_system/Database_system/5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-好的关系设计的特征"><a href="#1-好的关系设计的特征" class="headerlink" title="1 好的关系设计的特征"></a>1 好的关系设计的特征</h1><p>好的设计</p><p>​要避免冗余</p><p>​要避免更新、删除或者插入异常</p><p>那么为了在设计中进行好的设计</p><p>就应该合理的分解表格</p><p>但是有些时候分解会造成一些不好的影响——会产生有损分解或者无损分解</p><p>所什么是无损分解，什么是有损分解？</p><p><strong>判断方式一</strong></p><p>对于关系R，分解为R1和R2</p><p>讲两个分解后的表R1，R2做自然连接，如连接后和原来表R相等，则是无损分解。</p><p>如果自然连接后产生了原理表R没有的元组，则为有损分解</p><p><strong>判断方式二</strong></p><p>对于关系R，分解为R1和R2</p><p>如果R1和R2的交集是R1或者R2其中之一的超键则为无损分解，否则为有损分解</p><h1 id="2-函数依赖关系"><a href="#2-函数依赖关系" class="headerlink" title="2 函数依赖关系"></a>2 函数依赖关系</h1><p>函数依赖  Functional Dependencies，就是初中高中学习的判断一个对应关系是否为函数</p><p>很简单，就是一个x对应唯一一个y</p><p>需要先着重理解两个概念</p><p><strong>平凡函数依赖</strong>  Trivial Functional Dependencies</p><p>如果x-&gt;y，即y是x的函数，同时y又是x的子集，那么就说x到y是平凡函数依赖</p><p>平凡的含义就是显而易见的，为什么叫显而易见呢？子集我们可以理解为信息的一部分，信息相对原来变少了，那么因为知道更多的信息肯定可以推出更少的信息的，所以这个x-》y的函数依赖关系是显而存在的</p><p>举这样一个例子</p><p>（学生ID，姓名）-&gt;（姓名）</p><p>其中x是（学生ID，姓名），y是（姓名）</p><p>那么如果知道了学生ID，姓名，肯定可以得到唯一的姓名</p><p><strong>非平凡函数依赖</strong></p><p>而如果y不是x的子集，那么就不那么明显了，所以是非平凡函数依赖</p><p>再理解两个概念，部分函数依赖和完全函数依赖</p><p>理解部分函数依赖和完全函数依赖</p><p><strong>部分函数依赖（Partial Functional Dependency）</strong>（候选码）： 部分函数依赖是指在关系中，</p><p>比如x-&gt;y的函数依赖，y只依赖x的一部分，那么则是部分函数依赖，x还可以再拆分</p><p>举个例子，假设有一个包含以下属性的关系表：</p><ul><li>学生ID（StudentID）</li><li>课程号（CourseID）</li><li>学生姓名（StudentName）</li></ul><p>（学生ID，课程号）是可以推出学生姓名的</p><p>而只有学生ID也可以推出决定学生姓名，所以可以继续拆分，为部分函数依赖，换句话说x的子集也能推出决定右边</p><p><strong>完全函数依赖（Full Functional Dependency）</strong>（超码）：完全函数依赖是指在关系中，</p><p>比如x-&gt;y的函数依赖，y依赖x的全部，那么则是全部函数依赖，x不可以再拆分</p><p>换句话说x的子集不能推出决定右边</p><p>包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）<br>不包含在任何候选码中的属性称为非主属性（Nonprime attribute）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231111114502265.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231111114502265.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231111114502265"></p><p>总结来看：我们更期望非平凡函数依赖和完全函数依赖</p><p><strong>函数依赖的闭包</strong> Closure of Functional Dependencies</p><p>函数依赖闭包表示为$F^+$</p><p>函数依赖的闭包是一个属性集合，它包含了一个给定的属性集合关于另一个属性集合的所有可能依赖，所有的可能的函数关系</p><p>如何求函数依赖的闭包</p><p>利用</p><p><strong>Armstrong’s Axioms 阿姆斯特朗公理</strong></p><p>阿姆斯特公理有三条</p><ol><li>自反率（Reflexivity Axiom）： 如果X是一个属性集合，那么X的任何子集都可以推出X，表示为X → X。这意味着一个属性集合的所有子集都具有相同的函数依赖。</li><li>扩展律（Augmentation Axiom）： 如果X → Y，并且Z是一个属性集合，那么XZ → YZ。这个公理表示如果一个属性集合X决定另一个属性集合Y，那么在X的基础上添加属性Z也会决定Y。</li><li>传递律（Transitivity Axiom）： 如果X → Y和Y → Z，那么X → Z。这个公理表示如果一个属性集合X决定另一个属性集合Y，同时Y又决定另一个属性集合Z，那么X也会决定Z。</li></ol><p>另外的</p><ol><li><p>Union Rule（并集规则）： Union Rule 允许我们将两个函数依赖合并成一个更大的函数依赖。规则表述如下：</p><p>如果 X → Y1 和 X → Y2，那么 X → (Y1 ∪ Y2)。</p><p>这意味着如果属性集合 X 决定属性集合 Y1，同时 X 也决定属性集合 Y2，那么 X 也决定属性集合 (Y1 ∪ Y2)，也就是 Y1 和 Y2 的并集。</p></li><li><p>Splitting Rule（拆分规则）： Splitting Rule 允许我们拆分函数依赖，将一个函数依赖分成两个更小的函数依赖。规则表述如下：</p><p>如果 X → (Y1 ∪ Y2)，那么 X → Y1 和 X → Y2。</p><p>这意味着如果属性集合 X 决定属性集合 (Y1 ∪ Y2)，那么 X 也分别决定属性集合 Y1 和属性集合 Y2。这可以用于将一个大的函数依赖分解成多个小的函数依赖。</p></li><li><p>Pseudotransitivity Rule（伪传递规则）： Pseudotransitivity Rule 允许我们在两个已知的函数依赖关系之间推导出一个新的函数依赖。规则表述如下：</p><p>如果 X → Y1 和 Y1Z → Y2，那么 XZ → Y2。</p><p>这意味着如果属性集合 X 决定属性集合 Y1，同时 Y1Z 决定属性集合 Y2，那么属性集合 XZ 也决定属性集合 Y2。这个规则有点类似于传递性，但不完全相同，因此称为伪传递规则。</p></li></ol><p>通过上面的，我们可以求得一个函数依赖关系的闭包，我从网上找到了一道题，但感觉求这个意义不大</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228170252613.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228170252613.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228170252613" style="zoom:50%;" /><h1 id="3-Normal-Forms-规范形式"><a href="#3-Normal-Forms-规范形式" class="headerlink" title="3 Normal Forms 规范形式"></a>3 Normal Forms 规范形式</h1><h2 id="3-1-一二三范式"><a href="#3-1-一二三范式" class="headerlink" title="3.1 一二三范式"></a>3.1 一二三范式</h2><h3 id="3-1-1-基本概念"><a href="#3-1-1-基本概念" class="headerlink" title="3.1.1 基本概念"></a>3.1.1 基本概念</h3><p>规范形式（Normalization Forms，通常缩写为NF）是数据库设计中的一组标准，用于确保数据库表的结构满足一定的标准，以提高数据的一致性、避免数据冗余，并提高数据库性能。最常见的规范形式包括第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。</p><ol><li><strong>第一范式（1NF）</strong>：<ul><li>第一范式要求数据库表中的每个列都包含不可分割的、原子的数据，也就是每个单元格只包含一个值。此外，表中的每个行都应具有唯一的标识，通常通过一个主键来实现。1NF消除了重复的列和组合列。</li></ul></li><li><strong>第二范式（2NF）</strong>：<ul><li>第二范式要求在1NF的基础上，确保非主键属性完全依赖于主键。这意味着非主键属性不会部分依赖主键，也就是没有部分函数依赖。如果存在部分函数依赖，需要将表进行拆分，以确保每个非主键属性都依赖于整个主键。通常，2NF适用于具有复合主键的表。</li></ul></li><li><strong>第三范式（3NF）</strong>：<ul><li>第三范式要求在2NF的基础上，消除传递依赖。传递依赖指的是非主键属性依赖于主键以外的非主键属性。如果一个非主键属性依赖于另一个非主键属性，而这个属性又依赖于主键，就存在传递依赖。为了满足3NF，需要将数据库表进行拆分，以确保每个非主键属性只依赖于主键。</li></ul></li></ol><p>实际上3NF达到的效果就是 尽可能保证 非主键属性完全依赖于主建且只依赖于主键</p><p>规范形式的目标是减少数据冗余、提高数据一致性，并简化数据库结构，以便更容易维护和查询数据。虽然1NF、2NF和3NF是最常见的规范形式，但还有更高级别的规范形式，如巴斯－科德范式（BCNF）和第四范式（4NF），它们进一步强化了数据库设计的要求。</p><p>总结</p><p>第一范式：简单说 列不能再分</p><p>第二范式：简单说 建立在第一范式基础上，消除部分依赖</p><p>第三范式：简单说 建立在第二范式基础上，消除传递依赖。</p><p>BCNF是对3NF的改进，消除了对主键子集的依赖</p><h3 id="3-1-2-判断是否满足3NF"><a href="#3-1-2-判断是否满足3NF" class="headerlink" title="3.1.2 判断是否满足3NF"></a>3.1.2 判断是否满足3NF</h3><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228173731436.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228173731436.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228173731436"></p><h2 id="3-2-BCNF"><a href="#3-2-BCNF" class="headerlink" title="3.2 BCNF"></a>3.2 BCNF</h2><h3 id="3-2-1-基本概念"><a href="#3-2-1-基本概念" class="headerlink" title="3.2.1 基本概念"></a>3.2.1 基本概念</h3><p><code>Boyce-Codd Normal Form</code>（巴斯-科德范式（BCNF））是<code>Third Normal Form</code> 的一种扩展，因此有时候也被称为<code>3.5范式</code>。</p><ul><li>Boyce-Codd Normal Form（巴斯-科德范式）</li><li>在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）</li><li>巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。</li></ul><h3 id="3-2-2-判断是否满足BCNF"><a href="#3-2-2-判断是否满足BCNF" class="headerlink" title="3.2.2 判断是否满足BCNF"></a>3.2.2 判断是否满足BCNF</h3><p>判断每一个是否是超码，有一个不是就不是</p><p>a is a superkey for R</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171850258.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171850258.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228171850258"></p><p>因为Sno→Sdept中Sno不是超码<br>Sdept→Mname中Sdept不是超码</p><h3 id="3-2-3-分解得到BCNF"><a href="#3-2-3-分解得到BCNF" class="headerlink" title="3.2.3 分解得到BCNF"></a>3.2.3 分解得到BCNF</h3><p>怎么分解得到呢？</p><p>对于x-&gt;y</p><p>分解为x并y和R-（y-x）</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171802264.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228171802264.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228171802264" style="zoom:80%;" /><h1 id="4-属性集闭包和正则覆盖"><a href="#4-属性集闭包和正则覆盖" class="headerlink" title="4 属性集闭包和正则覆盖"></a>4 属性集闭包和正则覆盖</h1><h2 id="4-1-属性集闭包求法"><a href="#4-1-属性集闭包求法" class="headerlink" title="4.1 属性集闭包求法"></a>4.1 属性集闭包求法</h2><p>ps：可以理解为X+表示所有X可以决定的属性</p><p>求取属性集闭包的步骤：</p><p>设要求的闭包属性集是Y，把Y初始化为X.<br>检查函数依赖集F中的每个函数依赖A-&gt;B,如果属性集A中的所有属性都在Y中，而B中有属性不在Y中，则将其加入到Y中。<br>重复第二步，直到没有属性可以添加到Y中为止。最后得出的Y就是X+。<br><em>例子：</em>设有关系模式R（M,N,X,Y,Z）其依赖集F&#x3D;{M-&gt;H,H-&gt;Z,Y-&gt;Z,N-&gt;Y,Z-&gt;M}。求M+,MH+<br>第一步：设要求的闭包属性集是Y，把Y初始化为X.<br>令X&#x3D;{M},我们先看M-&gt;H,由于函数依赖M-&gt;H左边的所有属性都在X中，而右边H不在X中，所以可以把H添加到X 中，此时X&#x3D;{M，H}</p><p>然后按照顺序我们再看H-&gt;Z，我们不难发现函数依赖H-&gt;Z左边的所有属性都在X中,右边的属性Z又不在X中，仍旧添加，这时X&#x3D;{M，H，Z}</p><p>下一个</p><p>Y-&gt;Z，可以发现Y属性不在X中，条件不满足<br>N-&gt;Y，可以发现N属性不在X中，条件不满足<br>Z-&gt;M,Z属性在X中条件满足，但右边M也在X中条件不满足。</p><p>属性判断完 ，那么属性M的闭包：M+&#x3D;MHZ。</p><h2 id="4-2-属性集闭包应用"><a href="#4-2-属性集闭包应用" class="headerlink" title="4.2 属性集闭包应用"></a>4.2 属性集闭包应用</h2><h3 id="4-2-1-测试某个属性集是否为超键"><a href="#4-2-1-测试某个属性集是否为超键" class="headerlink" title="4.2.1 测试某个属性集是否为超键"></a>4.2.1 测试某个属性集是否为超键</h3><p>他的闭包如果包含所有属性，则为超集</p><h3 id="4-2-2-测试一个属性是否无关属性"><a href="#4-2-2-测试一个属性是否无关属性" class="headerlink" title="4.2.2 测试一个属性是否无关属性"></a>4.2.2 测试一个属性是否无关属性</h3><p>右边多余</p><p>如果前面的属性集闭包可以包括后面的，即可以删除无关的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228172420876.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231228172420876.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231228172420876"></p><p>左边多余</p><p>还可以计算函数依赖闭包，测试函数依赖是否成立</p><p><a href="https://blog.csdn.net/qq_40177015/article/details/111590534">范式判断的三个步骤以及各个范式标准(1NF,2NF,3NF,BCNF,4NF)_如何判断1nf2nf3nf和bcnf-CSDN博客</a></p><h2 id="4-3正则覆盖Canonical-Cover"><a href="#4-3正则覆盖Canonical-Cover" class="headerlink" title="4.3正则覆盖Canonical Cover"></a>4.3正则覆盖Canonical Cover</h2><p>一.<strong>使用合并律将所有左部相同的函数依赖合并成一个</strong></p><p>设有一函数依赖集F，其中有{A→B，A→E，……}，则将这两个函数依赖合并为{A→BE，……}</p><p>二.<strong>在合并后的函数依赖集中寻找一个无关属性，将它删除</strong></p><p>重复一二，直到每个元素都不是无关元素，无法再删，故解得正则覆盖</p><p>例题可以参考 </p><p><a href="https://blog.csdn.net/weixin_44356079/article/details/108341351">正则覆盖的求法与判断属性是否冗余-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（五）数据库设计</title>
      <link href="/2023/12/05/Computer_system/Database_system/4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/12/05/Computer_system/Database_system/4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/633814658">ER 图是什么？这一篇让你搞懂 ER 图！ - 知乎 (zhihu.com)</a></p><p>数据库设计核心就是</p><p>1 理解用户需求</p><p>2 使用E-R关系模型，绘制E-R图</p><p>3 将E-R关系模型转换为数据库表</p><p>本节核心在第二部分到第三部分</p><h1 id="1-实体关系模型-ER模型ER-model"><a href="#1-实体关系模型-ER模型ER-model" class="headerlink" title="1 实体关系模型 ER模型ER model"></a>1 实体关系模型 ER模型ER model</h1><h2 id="1-1-E-R模型结构"><a href="#1-1-E-R模型结构" class="headerlink" title="1.1 E-R模型结构"></a>1.1 E-R模型结构</h2><p>E-R模型实际上是由多个实体集（含有不同属性）和联系集组成</p><h3 id="1-1-1-实体和实体集"><a href="#1-1-1-实体和实体集" class="headerlink" title="1.1.1 实体和实体集"></a>1.1.1 实体和实体集</h3><p><strong>实体 Entity</strong>    是一个物体，客观存在并且相互区别</p><p>​比如一个学生，一个公司</p><p><strong>实体集合 Entity Sets</strong> 具有相同属性的实体的集合</p><p>​比如一群学生，一系列公司</p><h3 id="1-1-2-属性"><a href="#1-1-2-属性" class="headerlink" title="1.1.2 属性"></a>1.1.2 属性</h3><p><strong>属性 Attributes</strong></p><p>​比如ID，姓名，这些属性能够区别不同的实体</p><p>​就好比我们每个人都有自己的特征，这些特征区分了不同的实体</p><p>除了基本属性还有如下一些属性概念需要了解</p><p><strong>简单属性 Simple 和复合属性 composite</strong></p><ul><li>简单属性：不可再拆分，如数学成绩是一个简单属性</li><li>复合属性：可以再拆分，即属性的嵌套组合，如名字这个属性可以拆分为姓这个属性和名这个属性</li></ul><p><strong>单值属性 Single-valued和多值属性  multi-valued</strong></p><ul><li>单值属性：即只能是一个的属性，如一个人性别值只能是一个男或女 （排除个别特殊现象哈哈哈）</li><li>多值属性：即可能有多个值的属性，如电话号码可以有多个</li></ul><p><strong>派生属性  Derived attributes</strong> </p><p>​可以从一个已知的属性的值推理出来，比如知道出生可以退出年龄</p><p>​所以年龄就是一个派生属性</p><p><strong>描述属性 descriptive attributes</strong></p><p>描述属性一般都是给关系集合的，</p><p>如学生实体集合Student和考试实体集合section通过take（参加）这一个关系集合联系起来，那么take这个关系集合可以用grade成绩这一属性来描述</p><h3 id="1-1-3-关系集合"><a href="#1-1-3-关系集合" class="headerlink" title="1.1.3 关系集合"></a>1.1.3 关系集合</h3><p><strong>关系 Relationship</strong>  在一些实体中的关系</p><p><strong>关系集合 Relationship Sets</strong>  相同类型的关系的集合</p><p>关系集合往往要建立多个实体集的关系</p><p><strong>递归关系集合 Recursive relationship set</strong> </p><p>​同一实体集以不同的角色多次参与关系集。</p><p><strong>二元关系</strong></p><p>​只包含两个实体集的关系</p><p><strong>非二元关系集合</strong></p><p>​含超过两个实体集的关系</p><h2 id="1-2-ER关系图绘制"><a href="#1-2-ER关系图绘制" class="headerlink" title="1.2 ER关系图绘制"></a>1.2 ER关系图绘制</h2><p>E-R diagram  ER关系图</p><h3 id="1-2-1-实体集绘制"><a href="#1-2-1-实体集绘制" class="headerlink" title="1.2.1 实体集绘制"></a>1.2.1 实体集绘制</h3><p>1 矩形表示一个实体集，矩形上方写实体集的名字</p><p>2 实体集的属性一个一个列在矩形框内，用下横线标识主键</p><p>举例如下 Student表的关系图绘制</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111215170.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111215170.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221111215170"></p><h3 id="1-2-2-关系集绘制"><a href="#1-2-2-关系集绘制" class="headerlink" title="1.2.2 关系集绘制"></a>1.2.2 关系集绘制</h3><p>1 用一个菱形方块代表关系集，连接多个实体集矩形</p><p>举例如下 advisor代表一个关系集</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111620929.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221111620929.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221111620929"></p><p>2 上面讲到描述性属性，用虚线表示，如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221112506608.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221112506608.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221112506608"></p><p>上面我们讲完了实体集的一些初步介绍，接下来重点讲其中一些部分</p><h1 id="2-映射基数-Mapping-Cardinalities"><a href="#2-映射基数-Mapping-Cardinalities" class="headerlink" title="2  映射基数 Mapping Cardinalities"></a>2  映射基数 Mapping Cardinalities</h1><p>Mapping Cardinalities 映射基数    表示另一个实体可以通过关系集与之关联的实体数。</p><p>有以下几种类型</p><p>一对一，一对多，多对一，多对多</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231217192825529.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231217192825529.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231217192825529"></p><h2 id="2-1-映射基数类型"><a href="#2-1-映射基数类型" class="headerlink" title="2.1 映射基数类型"></a>2.1 映射基数类型</h2><h3 id="2-1-1-一对一"><a href="#2-1-1-一对一" class="headerlink" title="2.1.1 一对一"></a>2.1.1 一对一</h3><p>一对一 one to one：一个导师最多指导一个学生，一个学生最多被一个导师指导。说明导师可以不指导学生，学生也可以单干。</p><p>绘制E-R图如下 左右各一个箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113358521.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113358521.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113358521"></p><h3 id="2-1-2-一对多"><a href="#2-1-2-一对多" class="headerlink" title="2.1.2 一对多"></a>2.1.2 一对多</h3><p>一对多 one to many：一个导师可以指导任意多个学生，一个学生至多被一个导师指导。</p><p>绘制E-R图如下 只有one的那一侧有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113429002.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113429002.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113429002"></p><h3 id="2-1-3-多对一"><a href="#2-1-3-多对一" class="headerlink" title="2.1.3 多对一"></a>2.1.3 多对一</h3><p>多对一 many to one：一个导师至多指导一个学生，一个学生可以被任意个导师指导。</p><p>绘制E-R图如下 只有one的那一侧有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143036766.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143036766.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221143036766"></p><h3 id="2-1-4-多对多"><a href="#2-1-4-多对多" class="headerlink" title="2.1.4 多对多"></a>2.1.4 多对多</h3><p>多对多 many to many：一个导师可以指导任意学生，一个学生可以被任意多个导师指导。<br>说明导师可以不指导学生，也可以指导好些个。学生可以单干，也可以多拜几个师傅</p><p>绘制E-R图如下两侧都没有箭头</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113506699.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113506699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113506699"></p><p>总结：one指向的那一侧是箭头-&gt;</p><p>对于以上的各种关系，每一个advisor关系集合的超键都由各个实体集合的主键并集组成</p><p>但是超键却不太一样，一般选择many那一侧的主键做关系集合的主键</p><p>多对多</p><ul><li>主键和超键相同</li></ul><p>一对多</p><ul><li>多的那一侧，当做主键</li></ul><p>一对一</p><ul><li>任何一侧都可以当做主键</li></ul><h2 id="2-2-全部或部分参与约束"><a href="#2-2-全部或部分参与约束" class="headerlink" title="2.2 全部或部分参与约束"></a>2.2 全部或部分参与约束</h2><p>Total and Partial Participation 全部或部分参与</p><p>如下图所示，绘制E-R图时候 双线代表全部，单线代表部分</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113951144.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221113951144.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221113951144"></p><p>学生一侧是全部，含义代表每一个学生必须有一个指导老师</p><p>导师一侧是部分，含义代表有些老师指导学生，有些老师不指导学生</p><h2 id="2-3-最小最大基数约束"><a href="#2-3-最小最大基数约束" class="headerlink" title="2.3 最小最大基数约束"></a>2.3 最小最大基数约束</h2><p>在之前的基础上，可以加数量上的范围约束</p><p>E-R关系图上用双点表示, *表示无限制</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小值..最大值</span><br></pre></td></tr></table></figure><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221114723404.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221114723404.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221114723404"></p><p>含义如下</p><p>左侧老师一侧：0..* 代表一个指导老师能够指导0个或者更多个学生，没有上限</p><p>右侧学生一侧：1..1 代表一个学生至少1 个老师，至多也只有1个指导老师</p><p>超键是都有的</p><p>但主键根据情况不同而不同</p><p>比如</p><p>+ </p><h1 id="3-弱实体集"><a href="#3-弱实体集" class="headerlink" title="3 弱实体集"></a>3 弱实体集</h1><p>他的存在依赖于另一个实体集（被依赖的那个称作标识实体集identifying entity sets）</p><p>比如 考试这个存在就是依赖于课程的存在，所以课程实体集叫做标识实体集identifying entity sets，考试这个实体集叫做弱实体集Weak Entity Sets</p><p>E-R图中，用双框矩形表示，关系集合由双框菱形组成，虚线代表辨别属性</p><p>如下图所示</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143918389.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221143918389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221143918389"></p><p>该关系集合sec_course  的主键由标识实体集的主键和弱实体集的辨别属性（即虚线画出来的）一起构成</p><p>弱实体集那一侧一定是全部total participation</p><h1 id="4-ER模型转换为关系模式Relation-Schema"><a href="#4-ER模型转换为关系模式Relation-Schema" class="headerlink" title="4 ER模型转换为关系模式Relation Schema"></a>4 ER模型转换为关系模式Relation Schema</h1><p>初步解决</p><h2 id="4-1-强实体集表示"><a href="#4-1-强实体集表示" class="headerlink" title="4.1 强实体集表示"></a>4.1 强实体集表示</h2><p>对于强实体集而言有着简单的属性，直接转即可</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145145498.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145145498.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145145498"></p><p>对于强实体集有着复合属性，转换后成为一个一个简单属性（复合属性不会出现在其中）</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145301321.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145301321.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145301321"></p><p>对于多值属性而言如电话号码，我们再创建一个新的表</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145336791.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145336791.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145336791"></p><p>派生属性不要出现在表中，直接计算得到</p><h2 id="4-2-弱实体集表示"><a href="#4-2-弱实体集表示" class="headerlink" title="4.2 弱实体集表示"></a>4.2 弱实体集表示</h2><p>弱实体集形成新的表包含标识实体集的主键和它自己的属性</p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145718330.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145718330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145718330"></p><h2 id="4-3-关系集合表示"><a href="#4-3-关系集合表示" class="headerlink" title="4.3 关系集合表示"></a>4.3 关系集合表示</h2><p><strong>多对多</strong></p><p>两个实体集的主键+他自己的描述属性</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145851411.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221145851411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221145851411"></p><p>多对一</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151001627.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151001627.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151001627"></p><p>优化如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151014043.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151014043.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151014043"></p><p>一对一</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151038725.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151038725.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151038725"></p><p>优化如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151058298.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231221151058298.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231221151058298"></p><h1 id="5-实体关系设计"><a href="#5-实体关系设计" class="headerlink" title="5 实体关系设计"></a>5 实体关系设计</h1><p>问题一：假设一个部分可能有许多不同的分配。</p><p>解决：使用多值复合属性赋值</p><p>问题二：假设有关于作业的其他信息，例如最高分或截止日期</p><p>解决：将叶属性添加到分配属性</p><p>但是问题二有冗余问题</p><p>将赋值模型建模为由部分标识的弱实体集</p><h1 id="6-扩展E-R特征"><a href="#6-扩展E-R特征" class="headerlink" title="6 扩展E-R特征"></a>6 扩展E-R特征</h1><h2 id="6-1-IS-A-继承"><a href="#6-1-IS-A-继承" class="headerlink" title="6.1 IS-A 继承"></a>6.1 IS-A 继承</h2><p>Person可以经过Specialization（特化）称为两个小的如学生也是雇员</p><p>实体集可以包括实体的子分组，这些实体在某种程度上与集中的其他实体不同。</p><p>较低级别的实体集继承（inheritance）了较高级别实体集的所有属性和关系参与。</p><p>多重继承 简单继承</p><p>例如 人员集包括子组——员工集和学生集</p><p>重叠（Overlapping）——一个实体可能属于多个专用实体集，约束要求一个实体可以属于多个较低级别的实体集如，一个人可能既是学生也是雇员</p><p>不相交（Disjointness）——一个实体最多必须属于一个专用实体集，约束要求一个实体只能属于一个较低级别的实体集，如一个人只能是雇员里的前台柜员或者秘书之一</p><p>通过架构表示 IS-A 关系</p><p>方式一</p><p>​建立一个高水平实体集的架构，建立一个低水平的架构。通过外键建立两个练习</p><p>缺点：获取有关的信息，一个员工需要访问两个关系（低级架构和高级架构）</p><p>方式二</p><p>​使用所有本地属性和继承属性为每个实体集形成架构</p><p>缺点：冗余</p><p>用聚合的方式</p><p>使用聚合 – 可以将聚合实体集视为单个单元，而不考虑其内部结构的细节。</p><p>聚合是一种抽象，通过该抽象，将关系视为更高级别的实体</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（四）中级和进阶SQL</title>
      <link href="/2023/12/04/Computer_system/Database_system/3-2%E4%B8%AD%E7%BA%A7%E5%92%8C%E8%BF%9B%E9%98%B6SQL/"/>
      <url>/2023/12/04/Computer_system/Database_system/3-2%E4%B8%AD%E7%BA%A7%E5%92%8C%E8%BF%9B%E9%98%B6SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="1-中级"><a href="#1-中级" class="headerlink" title="1 中级"></a>1 中级</h1><h2 id="1-1-Join表达式"><a href="#1-1-Join表达式" class="headerlink" title="1.1 Join表达式"></a>1.1 Join表达式</h2><p><a href="https://blog.csdn.net/dingjianmin/article/details/92009385">inner join、outer join、right join、left join 之间的区别_left inner join outer join 区别-CSDN博客</a></p><p>natural join 在所有共同属性上做等值连接，然后再投影去掉重复值</p><p>Inner join  在on的条件上做等值连接 或者叫join</p><p>outer join（外连接）又可以分为 left join，right join</p><p>cross join（笛卡尔积） 又叫full join（全连接）左连接和右连接的并集</p><p>和之前数据库关系代数那里讲的是一样的</p><p>加条件用on</p><h2 id="1-2-View-虚表"><a href="#1-2-View-虚表" class="headerlink" title="1.2 View 虚表"></a>1.2 View 虚表</h2><p>创建一个虚拟表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v <span class="keyword">as</span> <span class="operator">&lt;</span>query expression<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中v是新表的表名，<query expression>对于原表的一个SQL查询</p><p>一但创建就可以在后面继续使用</p><p>我们之前讲过with as，虽然他看起来可以实现和view一样的效果，但实际上view是全局的，之后也可以调用，而with as是局部的，之后就不能继续调用了。</p><p>对于 更新View</p><p>会遇到很多问题</p><p>一个问题，就是更新之后View虚拟表，要映射回原本的表，</p><p>大多数 SQL 实现只允许在简单视图上进行更新</p><p>插入的话会是原表会是null</p><h2 id="1-3-完整性限制constraint"><a href="#1-3-完整性限制constraint" class="headerlink" title="1.3 完整性限制constraint"></a>1.3 完整性限制constraint</h2><p>完整性约束可防止对数据库造成意外损坏。</p><p>常见的一些限制</p><p>非空限制</p><p>独一限制</p><p>大于限制等等</p><p>比如如下一些限制实现</p><p>An instructor name cannot be null.<br>No two instructors can have the same instructor ID.<br>Every department name must have a matching department name in the department relation.<br>The salary of an instructor must be greater than $29000.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table instructor</span><br><span class="line">(ID varchar (5),</span><br><span class="line">name varchar (20) not null,</span><br><span class="line">dept_name varchar (20),</span><br><span class="line">salary numeric (8,2) check (salary &gt; 29000),</span><br><span class="line">primary key (ID),</span><br><span class="line">foreign key (dept_name) references department);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如会在插入的时候遇到</p><h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2 进阶"></a>2 进阶</h1><h2 id="2-1-数据库触发器trigger"><a href="#2-1-数据库触发器trigger" class="headerlink" title="2.1 数据库触发器trigger"></a>2.1 数据库触发器trigger</h2><p>触发器是一种特殊的<code>存储过程</code>。但触发器没有输入和输出参数，因而不能被显示调用。它作为语句的执行结果自动引发，而存储过程则是通过存储过程名称被直接调用。</p><p>触发器 可以自动执行一些内容，加强数据的完整性约束和业务规则等</p><p> 比如在插入一个语句后，我判断他是否完整！</p><p>触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 触发器可以从 DBA_TRIGGERS ，USER_TRIGGERS 数据字典中查到。SQL3的触发器是一个能由系统自动执行对数据库修改的语句。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231227140119379.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231227140119379.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231227140119379"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（三）SQL语句全解析</title>
      <link href="/2023/12/03/Computer_system/Database_system/3-1SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/12/03/Computer_system/Database_system/3-1SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SQL表内类型"><a href="#1-SQL表内类型" class="headerlink" title="1 SQL表内类型"></a>1 SQL表内类型</h1><p>char(n)  固定长度n的字符</p><p>varchar（n）  最大长度n的可变字符</p><p> 比如我char(20) 的一个元素值为“vs”则占用20字节，如果varchar（20）的一个元素值为”vs”，则占用字节为2</p><p>int   整形</p><p>smallint   小整形</p><p>numeric（p,d ）   固定小数点位数，特定精度 如 numeric(3,1) 支持 44.5</p><p>float  </p><p>double</p><h1 id="2-SQL增删改语句"><a href="#2-SQL增删改语句" class="headerlink" title="2 SQL增删改语句"></a>2 SQL增删改语句</h1><h2 id="2-1-创建表-create"><a href="#2-1-创建表-create" class="headerlink" title="2.1 创建表 create"></a>2.1 创建表 create</h2><p>语法</p><p>注意不要丢掉分号</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">budget <span class="type">numeric</span> (<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">primary</span> key(dept_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>指定主键</strong></p><p>primary key(dept_name)</p><p><strong>指定非空属性</strong></p><p>dept_name varchar(20)  not null </p><p><strong>制定外键</strong></p><p>foreign key (name) references instructor</p><h2 id="2-2-删除表-drop"><a href="#2-2-删除表-drop" class="headerlink" title="2.2 删除表 drop"></a>2.2 删除表 drop</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r;</span><br></pre></td></tr></table></figure><p>删除原本表</p><h2 id="2-3-表中添加属性-alter…-add"><a href="#2-3-表中添加属性-alter…-add" class="headerlink" title="2.3 表中添加属性 alter… add"></a>2.3 表中添加属性 alter… add</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> r <span class="keyword">add</span> A D;</span><br></pre></td></tr></table></figure><p>为表添加A D属性</p><h2 id="2-4-添加新的元组信息-insert…into…"><a href="#2-4-添加新的元组信息-insert…into…" class="headerlink" title="2.4 添加新的元组信息 insert…into…"></a>2.4 添加新的元组信息 insert…into…</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructors <span class="keyword">values</span>(&quot;10211&quot;,&quot;Simith&quot;,&quot;Biology&quot;)</span><br></pre></td></tr></table></figure><h2 id="2-5-删除表所有元组-delete-from-…"><a href="#2-5-删除表所有元组-delete-from-…" class="headerlink" title="2.5 删除表所有元组  delete from …"></a>2.5 删除表所有元组  delete from …</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p>删除元组，但表还在</p><h2 id="2-6-更改元组-update"><a href="#2-6-更改元组-update" class="headerlink" title="2.6 更改元组  update"></a>2.6 更改元组  update</h2><p>示例：给收入低于 70000 的教师加薪 5%</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">70000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-查询语句"><a href="#3-查询语句" class="headerlink" title="3 查询语句"></a>3 查询语句</h1><p><strong>查询结构</strong></p><p>select 属性</p><p>from 表</p><p>where  谓词条件</p><p>多个表的时候，需要加表名.属性区分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, instructor.dept_name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name<span class="operator">=</span> department.dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><p>1 SQL语句<strong>大小写不敏感</strong>  name&#x3D;NAME</p><p>2 选择结果可能会包含<strong>重复</strong>的结果</p><p>使用distinct<strong>去除重复</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>3 使用*<strong>查询全部</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor;</span><br></pre></td></tr></table></figure><p>4 选择中可以包括<strong>运算表达式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">as</span> monthly_salary  </span><br><span class="line"><span class="keyword">from</span> instructor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>表示选择工资除以12后选择出来</p><p>5  <strong>where谓词</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>  <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">70000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name, instructor.dept_name, building</span><br><span class="line"><span class="keyword">from</span> instructor, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> department.dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-重命名"><a href="#4-重命名" class="headerlink" title="4 重命名"></a>4 重命名</h1><h2 id="4-1-为什么用"><a href="#4-1-为什么用" class="headerlink" title="4.1 为什么用"></a>4.1 为什么用</h2><p><strong>as</strong></p><p>1 在相同的关系中比较元组</p><p>示例：查找 Comp.Sci 部门中薪水高于至少一名讲师的所有讲师的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2 将长的名字改短</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.name, S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, teaches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID<span class="operator">=</span> S.ID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 结果属性修改名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.name <span class="keyword">as</span> instructor_name, S.course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, teaches <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.ID<span class="operator">=</span> S.ID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-字符操作"><a href="#5-字符操作" class="headerlink" title="5 字符操作"></a>5 字符操作</h1><h2 id="5-1-寻找匹配"><a href="#5-1-寻找匹配" class="headerlink" title="5.1 寻找匹配"></a>5.1 寻找匹配</h2><p><strong>like</strong></p><p><strong>%</strong> 子字符串匹配</p><p><strong>__</strong> 匹配任何字符串</p><p>|| 运算符用于附加两个字符串</p><p>举例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Intro%&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string beginning <span class="keyword">with</span> “Intro”.</span><br><span class="line"><span class="string">&#x27;%Comp%&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string containing “Comp” <span class="keyword">as</span> a substring.</span><br><span class="line"><span class="string">&#x27;_ _ _&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string <span class="keyword">of</span> exactly three characters.</span><br><span class="line"><span class="string">&#x27;_ _ _ %&#x27;</span> <span class="keyword">matches</span> <span class="keyword">any</span> string <span class="keyword">of</span> <span class="keyword">at</span> least three characters.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><p>1 大小写敏感</p><p>2 转义字符区分%</p><p>Match the string “100%”<br>            like ‘100 %‘  </p><h2 id="5-2-function"><a href="#5-2-function" class="headerlink" title="5.2 function"></a>5.2 function</h2><p>Trim用来 移除字符串后面的空格</p><h1 id="6-生序降序"><a href="#6-生序降序" class="headerlink" title="6 生序降序"></a>6 生序降序</h1><p><strong>order</strong>关键字</p><p><strong>desc 降序</strong></p><p><strong>asc升序</strong></p><p>示例1：按字母顺序列出物理系的所有教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例2：按薪水和姓名列出讲师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>, name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p><strong>between</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">and</span> salary <span class="operator">&gt;=</span> <span class="number">90000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-联合操作"><a href="#7-联合操作" class="headerlink" title="7 联合操作"></a>7 联合操作</h1><h2 id="7-1-并集Union"><a href="#7-1-并集Union" class="headerlink" title="7.1 并集Union"></a>7.1 并集Union</h2><p>可以直接自动消除重复，不像选择子句。</p><p>例子1 ：查找 2017 年秋季或 2018 年春季开设的课程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"> <span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们想要保留所有重复值</p><p>用union all</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"> <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-2-交集-INTERSECT"><a href="#7-2-交集-INTERSECT" class="headerlink" title="7.2 交集 INTERSECT"></a>7.2 交集 INTERSECT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-3-差集-EXCEPT"><a href="#7-3-差集-EXCEPT" class="headerlink" title="7.3 差集 EXCEPT"></a>7.3 差集 EXCEPT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> course_id  </span><br><span class="line"> <span class="keyword">from</span> section</span><br><span class="line"> <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-4-对于空值补充"><a href="#7-4-对于空值补充" class="headerlink" title="7.4 对于空值补充"></a>7.4 对于空值补充</h2><p>1 任何包含Null的表达式返回为Null</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="operator">+</span> <span class="keyword">null</span>  <span class="keyword">returns</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>2 任何包含Null的比较返回的值是未知的</p><p>例 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="operator">&lt;</span> <span class="keyword">null</span>  <span class="keyword">or</span>  <span class="keyword">null</span> <span class="operator">&lt;&gt;</span> <span class="keyword">null</span>   <span class="keyword">or</span>   <span class="keyword">null</span> <span class="operator">=</span> <span class="keyword">null</span>  <span class="keyword">returns</span> <span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>3 对于布尔运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> : (<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">unknown</span>)  <span class="operator">=</span> <span class="literal">unknown</span>,  </span><br><span class="line">  (<span class="literal">false</span> <span class="keyword">and</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">false</span>,</span><br><span class="line">      (<span class="literal">unknown</span> <span class="keyword">and</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line"><span class="keyword">or</span>: (<span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">true</span>)   <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line"> <span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">false</span>)  <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line">    (<span class="literal">unknown</span> <span class="keyword">or</span> <span class="literal">unknown</span>) <span class="operator">=</span> <span class="literal">unknown</span></span><br><span class="line"><span class="keyword">not</span>:  <span class="operator">=</span><span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>空值，未知检测</p><p>示例：查找工资为空的所有教师。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="keyword">null</span><span class="operator">/</span> <span class="literal">unknown</span></span><br></pre></td></tr></table></figure><p>都是用is的，注意不能用&#x3D;来替代is 在null的情况下</p><h1 id="8-聚合函数"><a href="#8-聚合函数" class="headerlink" title="8 聚合函数"></a>8 聚合函数</h1><p>Average: avg<br>Minimum: min<br>Maximum: max<br>Total: sum<br>Count: count</p><p>示例：查找计算机科学系教师的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-1-group-by"><a href="#8-1-group-by" class="headerlink" title="8.1 group by"></a>8.1 group by</h2><p>group by是一个限定函数，意味着在这种情况下，限定在哪里的一个范围内进行比较寻找</p><p>比如下面的例子，要找到每一个部门的平均值</p><p>示例:查找每个部门讲师的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-2-having"><a href="#8-2-having" class="headerlink" title="8.2 having"></a>8.2 having</h2><p>having相当于要加一个限定条件</p><p>示例：查找平均工资大于42000的所有部门的名称和平均工资</p><p>having相当于就是给Group加一个条件，比如在这个范围内大于42000的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span> (salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span> (salary) <span class="operator">&gt;</span> <span class="number">42000</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-Nested-Subqueries-嵌套子查询"><a href="#9-Nested-Subqueries-嵌套子查询" class="headerlink" title="9 Nested Subqueries 嵌套子查询"></a>9 Nested Subqueries 嵌套子查询</h1><h2 id="9-1-Set-Membership"><a href="#9-1-Set-Membership" class="headerlink" title="9.1 Set Membership"></a>9.1 Set Membership</h2><p>in 和not in</p><p>示例： 查找所有姓名为“莫扎特”或“爱因斯坦”的教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">in</span>(&quot;Mozart&quot;,&quot;Einstein&quot;)</span><br></pre></td></tr></table></figure><p>示例：查找已参加 ID 为 10101 的教师教授的课程部分的（不同）学生总数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span> (<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, sec_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span>  (<span class="keyword">select</span> course_id, sec_id, semester, <span class="keyword">year</span></span><br><span class="line">                                 <span class="keyword">from</span> teaches</span><br><span class="line">                                 <span class="keyword">where</span> teaches.ID<span class="operator">=</span> <span class="number">10101</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-2-Set-Comparison"><a href="#9-2-Set-Comparison" class="headerlink" title="9.2 Set Comparison"></a>9.2 Set Comparison</h2><p>SQL also allows &lt; some, &lt;&#x3D; some, &gt;&#x3D; some, &#x3D; some, and &lt;&gt; some<br>定义： y &lt; some (X) : y小于X中任一元素，则结果为true</p><p>比较</p><p>some 只要一个满足即可</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114912021.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114912021.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231211114912021"></p><p>all 所有满足</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114933982.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231211114933982.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231211114933982"></p><h2 id="9-3-exist-or-not-exists"><a href="#9-3-exist-or-not-exists" class="headerlink" title="9.3 exist or not exists"></a>9.3 exist or not exists</h2><p>exists 它的作用是检查子查询是否返回结果。如果子查询返回至少一行数据（即至少存在一个满足条件的匹配项），那么”EXISTS”返回TRUE，否则返回FALSE。</p><p>示例: 查找学过生物系所有课程的学生（ID、姓名）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( (<span class="keyword">select</span> course_id</span><br><span class="line">                                 <span class="keyword">from</span> course</span><br><span class="line">                                 <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>)</span><br><span class="line">                               <span class="keyword">except</span></span><br><span class="line">                                 (<span class="keyword">select</span> T.course_id</span><br><span class="line">                                   <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">                                   <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-4-with-as"><a href="#9-4-with-as" class="headerlink" title="9.4 with as"></a>9.4 with as</h2><p>临时的关系，一会儿的查询用到</p><p>示例: 查找预算最高的所有部门</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max_budget (<span class="keyword">value</span>) <span class="keyword">as</span>       </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">max</span>(budget)</span><br><span class="line">    <span class="keyword">from</span> department)</span><br><span class="line"><span class="keyword">select</span> department.name</span><br><span class="line"><span class="keyword">from</span> department, max_budget</span><br><span class="line"><span class="keyword">where</span> department.budget <span class="operator">=</span> max_budget.value;</span><br></pre></td></tr></table></figure><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>答案在最后</p><p>1 This Query can be replaced by which one of the following?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, course_id</span><br><span class="line">FROM instructor, teaches</span><br><span class="line">WHERE instructor_ID= teaches_ID;</span><br></pre></td></tr></table></figure><p>a) Select name,course_id from teaches,instructor where instructor_id&#x3D;course_id;<br>b) Select name, course_id from instructor natural join teaches;<br>c) Select name, course_id from instructor;<br>d) Select course_id from instructor join teaches;</p><p>2 In the SQL given above there is an error . Identify the error.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employee WHERE dept_name=&quot;Comp Sci&quot;;</span><br></pre></td></tr></table></figure><p>a) Dept_name<br>b) Employee<br>c) “Comp Sci”<br>d) From</p><p>Explanation: For any string operations single quoted(‘) must be used to enclose.</p><p>3 Which one of the following has to be added into the blank to select the dept_name which has Computer Science as its ending string?<br>a) %<br>b) _<br>c) ||<br>d) $</p><p>4 If we want to retain all duplicates, we must write ________ in place of union.<br>a) Union all<br>b) Union some<br>c) Intersect all<br>d) Intersect some</p><p>5  _____ clause is an additional filter that is applied to the result.<br>a) Select<br>b) Group-by<br>c) Having<br>d) Order by</p><p>6 A _____ indicates an absent value that may exist but be unknown or that may not exist at all.<br>a) Empty tuple<br>b) New value<br>c) Null value<br>d) Old value</p><p>7 Using the ______ clause retains only one copy of such identical tuples.<br>a) Null<br>b) Unique<br>c) Not null<br>d) Distinct</p><p>8  In an employee table to include the attributes whose value always have some value which of the following constraint must be used?<br>a) Null<br>b) Not null<br>c) Unique<br>d) Distinct</p><p>9   If the attribute phone number is included in the relation all the values need not be entered into the phone number column. This type of entry is given as<br>a) 0<br>b) –<br>c) Null<br>d) Empty space</p><p>10 Aggregate functions are functions that take a ___________ as input and return a single value.<br>a) Collection of values<br>b) Single value<br>c) Aggregate value<br>d) Both Collection of values &amp; Single value</p><p>11 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT __________</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE dept name= ’Comp. Sci.’;</span><br></pre></td></tr></table></figure><p>Which of the following should be used to find the mean of the salary ?<br>a) Mean(salary)<br>b) Avg(salary)<br>c) Sum(salary)<br>d) Count(salary)</p><p>12 All aggregate functions except _____ ignore null values in their input collection.<br>a) Count(attribute)<br>b) Count(*)<br>c) Avg<br>d) Sum</p><p>13 </p><p>A Boolean data type that can take values true, false, and________<br>a) 1<br>b) 0<br>c) Null<br>d) Unknown</p><p>14</p><p>Which of the following is used to find all courses taught in both the Fall 2009 semester and in the Spring 2010 semester .<br>a)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT course id</span><br><span class="line">FROM SECTION AS S</span><br><span class="line">WHERE semester = ’Fall’ AND YEAR= 2009 AND</span><br><span class="line">EXISTS (SELECT *</span><br><span class="line">FROM SECTION AS T</span><br><span class="line">WHERE semester = ’Spring’ AND YEAR= 2010 AND</span><br><span class="line">S.course id= T.course id);</span><br></pre></td></tr></table></figure><p>b)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE salary &gt; SOME (SELECT salary</span><br><span class="line">FROM instructor</span><br><span class="line">WHERE dept name = ’Biology’);</span><br></pre></td></tr></table></figure><p>c)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT (DISTINCT ID)</span><br><span class="line">FROM takes</span><br><span class="line">WHERE (course id, sec id, semester, YEAR) IN (SELECT course id, sec id, semester, YEAR</span><br><span class="line">FROM teaches</span><br><span class="line">WHERE teaches.ID= 10101);</span><br></pre></td></tr></table></figure><p>d)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(SELECT course id</span><br><span class="line">FROM SECTION</span><br><span class="line">WHERE semester = ’Spring’ AND YEAR= 2010)</span><br></pre></td></tr></table></figure><p>15</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT dept_name, ID, avg (salary)</span><br><span class="line">FROM instructor</span><br><span class="line">GROUP BY dept_name;</span><br><span class="line">This statement IS erroneous because</span><br></pre></td></tr></table></figure><p>a) Avg(salary) should not be selected<br>b) Dept_id should not be used in group by clause<br>c) Misplaced group by clause<br>d) Group by clause is not valid in this query</p><p>答案</p><p>1-5  B C A A  C   6-10 C D B C  </p><p>11- 15  B B D A B</p><p>对exit比较模糊</p><p>从Nested -2 开始只做后五道题</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（二）关系代数</title>
      <link href="/2023/12/02/Computer_system/Database_system/2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/12/02/Computer_system/Database_system/2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单张表运算"><a href="#1-单张表运算" class="headerlink" title="1 单张表运算"></a>1 单张表运算</h1><h2 id="1-1-选择-select"><a href="#1-1-选择-select" class="headerlink" title="1.1 选择 select"></a>1.1 选择 select</h2><p>选择就是从一个表中选择满足条件的一些元组</p><p>“Predicate” 可以翻译为 “谓词” 或者 “断言”。在数据库和计算机科学的上下文中，谓词通常是用来描述条件或断言的术语，用于筛选数据或控制程序的执行流程。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101604316.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101604316.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101604316"></p><p>选择的条件可以 是表达式</p><p>可以包括等于，大于小于，不等于等等</p><p>当有多个条件时，可以通过and，or等连接</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101756697.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101756697.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101756697"></p><p>还可以连接两个属性</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205219240.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205219240.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205219240"></p><h2 id="1-2-投影-project"><a href="#1-2-投影-project" class="headerlink" title="1.2  投影 project"></a>1.2  投影 project</h2><p>投影可以理解为选择某些属性的值（注意去掉重复的，如下图例子</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101936020.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924101936020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924101936020"></p><p>允许算术表达式，如下面的例子，会计算salary&#x2F;12的值</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205609680.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205609680.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205609680"></p><p>关系代数运算可以组合成一个关系代数表达式</p><p>如下面的例子，可以发现这里的参数是一个表达式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205737774.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209205737774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209205737774"></p><h1 id="2-多张表之间运算"><a href="#2-多张表之间运算" class="headerlink" title="2 多张表之间运算"></a>2 多张表之间运算</h1><h2 id="2-1-笛卡尔积-Cartesian-product"><a href="#2-1-笛卡尔积-Cartesian-product" class="headerlink" title="2.1 笛卡尔积 Cartesian-product"></a>2.1 笛卡尔积 Cartesian-product</h2><p>前面表的第一行依次和后面表的每一行连接</p><p>前面表的第二行依次和后面表的每一行连接</p><p>……</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102145234.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102145234.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102145234"></p><p>当然这样得到的结果可能是不合理的，所以我们可以在这个的基础上进行一些操作，选出符合要求的</p><p>自然引出我们下面的一种操作叫Theta连接</p><h2 id="2-2-Theta连接-操作-Theta-join"><a href="#2-2-Theta连接-操作-Theta-join" class="headerlink" title="2.2  Theta连接 操作 Theta-join"></a>2.2  Theta连接 操作 Theta-join</h2><p>先笛卡尔积，再选出符合要求θ的</p><p>Theta-Join 操作是数据库中的一种关联操作，它不仅仅基于相等的条件来关联两个表，而是允许使用任何满足特定谓词（通常是一个比较运算符，如小于、大于、等于等）的条件来关联表中的行。这个谓词通常用θ（希腊字母Theta）来表示，因此得名 Theta-Join。<img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102429670.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102429670.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102429670"></p><h2 id="2-3-自然连接操作-natural-join"><a href="#2-3-自然连接操作-natural-join" class="headerlink" title="2.3 自然连接操作 natural-join"></a>2.3 自然连接操作 natural-join</h2><p>自然连接依赖于表之间的隐式连接条件，这些条件是基于表的列名相匹配的（找两个表中相同的列名）。具体来说，自然连接将两个表中列名相同的列用作连接条件，并且只返回这些列的一份副本。</p><p>——只有两个表都有的元素才会被链接</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102507760.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230924102507760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230924102507760"></p><p>举例如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223518297.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223518297.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223518297"></p><p>注意这里会产生悬浮元组，即没有对应一样的元组</p><p>所以就产生了下面的一种连接方式</p><h2 id="2-4-外连接"><a href="#2-4-外连接" class="headerlink" title="2.4  外连接"></a>2.4  外连接</h2><p>把悬浮元组保存在结果表中，在其他属性上填NULL</p><p>右外连接：保留右边表中的悬浮元组</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223630637.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223630637.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223630637"></p><p>左外连接：保留左边表中的悬浮元组</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223645041.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930223645041.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930223645041"></p><h2 id="2-5-并union，交Set-Intersection，差运算Set-Difference"><a href="#2-5-并union，交Set-Intersection，差运算Set-Difference" class="headerlink" title="2.5 并union，交Set-Intersection，差运算Set Difference"></a>2.5 并union，交Set-Intersection，差运算Set Difference</h2><p>使用并运算条件</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p>举例</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224051965.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224051965.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224051965"></p><p>交运算</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p>举例</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224114274.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224114274.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224114274"></p><p>差运算</p><p>1 两个表必须有相同的属性</p><p>2  属性域必须兼容（对于每个 i，输入关系的第 i 个属性的类型必须相同）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224159418.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224159418.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224159418"></p><h2 id="2-6-除法-Division"><a href="#2-6-除法-Division" class="headerlink" title="2.6 除法 Division"></a>2.6 除法 Division</h2><p>除操作是同时从行和列角度进行运算</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225613708.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225613708.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225613708"></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225711834.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225711834.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225711834"></p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3 其他"></a>3 其他</h1><h2 id="3-1-赋值操作-Assignment"><a href="#3-1-赋值操作-Assignment" class="headerlink" title="3.1 赋值操作 Assignment"></a>3.1 赋值操作 Assignment</h2><p>为了方便，简化表达式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224341845.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224341845.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224341845"></p><h2 id="3-2-重命名-Rename"><a href="#3-2-重命名-Rename" class="headerlink" title="3.2 重命名 Rename"></a>3.2 重命名 Rename</h2><p>对表达式的结果或者表等重命名</p><p>两种表达形式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224900175.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224900175.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224900175"></p><p>举例</p><p>可以方便复用一个表</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224921443.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930224921443.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930224921443"></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225152778.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930225152778.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230930225152778"></p><p>对于查询，可能有多种表达形式，他们的结果是一样的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/2023/12/02/about/index/"/>
      <url>/2023/12/02/about/index/</url>
      
        <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><p>博主: Qodicat<br>AI算法应用爱好者<br>与世界大战三百回合不服输的少年~<br>喜欢探索美食，以及一切有趣充满活力的事物！<br>爱好跑步、羽毛球、滑板、游泳、读书、看电影、做美食、剪辑funny视频<br>喜欢可爱的小动物~</p><h3 id="a-bit-技能"><a href="#a-bit-技能" class="headerlink" title="a bit 技能"></a>a bit 技能</h3><p>Stable Diffusion,Midjourney等AIGC应用<br>AI算法，包括传统卷积神经网络，Transformer，扩散模型<br>模型微调，模型调参等<br>前端语言开发，嵌入式开发</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><p>云FPGA平台开发<br>星与安卓APP开发<br>Diana-Coding Vscode插件开发<br>社会实践队前端网页开发</p><h3 id="平台账号"><a href="#平台账号" class="headerlink" title="平台账号"></a>平台账号</h3><div style="display: flex;"><span class='btn center cool-2'><a class="button" href='https://github.com/QodiCat' title='Github'><i class='fa-brands fa-github-alt'></i>Github</a></span><span style="width:5px;"></span><span class='btn center cool-2'><a class="button" href='https://blog.csdn.net/Q52099999?spm=1010.2135.3001.5343' title='CSDN'><i class='fa-brands fa-CSDN'></i>CSDN</a></span></div><h3 id="我喜欢的一些书籍"><a href="#我喜欢的一些书籍" class="headerlink" title="我喜欢的一些书籍"></a>我喜欢的一些书籍</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E9%9D%92%E9%93%9C%E8%91%B5%E8%8A%B1/8891559"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-52-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《青铜葵花》</span><span class="desc">温暖了我一个冬天</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E7%A5%9E%E7%A7%98%E5%B2%9B/3094497?fromtitle=%E5%A4%96%E5%9B%BD%E6%96%87%E5%AD%A6%E5%90%8D%E8%91%97%EF%BC%9A%E7%A5%9E%E7%A7%98%E5%B2%9B&fromid=5685499"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/0151085c87ed81a801214168838477.jpg@1280w_1l_2o_100sh.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《神秘岛》</span><span class="desc">凡尔纳yyds</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%8B%A6%E5%84%BF%E6%B5%81%E6%B5%AA%E8%AE%B0/80000"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-51-04.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《苦儿流浪记》</span><span class="desc">小时候读的印象最深的一本书</span></div></a><a class="site-card" href="https://zhuanlan.zhihu.com/p/150729443"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_21-53-54.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">《撒哈拉的故事》</span><span class="desc">只能说泰裤辣</span></div></a></div><h3 id="我喜欢的一些电影"><a href="#我喜欢的一些电影" class="headerlink" title="我喜欢的一些电影"></a>我喜欢的一些电影</h3><div class="site-card-group"><a class="site-card" href="https://baike.baidu.com/item/%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E/27198"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-42-52.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">三傻大脑宝莱坞</span><span class="desc">打破刻板印象</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%BB%E5%8A%A8%E5%91%98/27212"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-43-44.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">机器人总动员</span><span class="desc">暖心</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E9%A9%AF%E9%BE%99%E9%AB%98%E6%89%8B/10650780?fromModule=disambiguation"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-45-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-45eb5749949e7f90a5c788f9bc5721ef_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">驯龙高手</span><span class="desc">可爱的宠物？</span></div></a><a class="site-card" href="https://baike.baidu.com/item/%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E/5358"><div class="img"><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/Snipaste_2023-12-03_22-46-50.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="info"><img src="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-8bb491487280587026cd576b224ca91e_1440w.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/><span class="title">让子弹飞</span><span class="desc">背后暗藏玄机</span></div></a></div><!-- ### 其他<div class="link-group"><div class="tagLink"><a class="link-card" title="项目一" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目一</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目二" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目二</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目三" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目三</p><p class="url">http://www.baidu.com</p></div></a></div><div class="tagLink"><a class="link-card" title="项目四" href="http://www.baidu.com"><span class="link-card-backdrop" style="background-image: url(https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp)"></span><div class="left"><img src="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-970dd5538f106dd6be064c4eafc01c36_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"/></div><div class="right"><p class="text">项目四</p><p class="url">http://www.baidu.com</p></div></a></div></div> --><!-- ### 我的游戏<div class="gallery ">              <p><img src="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/v2-abb2c12e9fbe8dda1993f7cd5d149159_b.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="王者荣耀"><br><img src="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-980e050a09c4157e45bb8fdd419f9847_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="和平精英"></p>            </div> --><h3 id="我的相册"><a href="#我的相册" class="headerlink" title="我的相册"></a>我的相册</h3><p>不定时掉落一些回忆</p><div class="tag-plugin post-swiper-container" width="fill"><div class="swiper-wrapper"><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">苏州~金鸡湖畔</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/479da3fd2ffb596b95aa2f411e94ca2.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">微软~Promt大会</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/81723041eb7fc632101661526fed932.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">讯飞星火~开发者会议</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/8d33b15cd9c08a8de1d30a96fe8d6b4.jpg"></a></div><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">探索的好吃的！</p><img no-lazy class="swiper-slide-img" src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/Blog/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20231203-223736.jpg"></a></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div><h3 id="未来进行时"><a href="#未来进行时" class="headerlink" title="未来进行时"></a>未来进行时</h3><p>大学生活正在向前，进度条已经百分之60啦，冲冲冲！！！</p><div style="display: grid;  grid-template-columns: 50% 50%;  grid-template-rows: 30px 30px;  grid-column-gap: 20px"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-success"  style="width: 60%" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"><p>完成时</p></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统（一）概述</title>
      <link href="/2023/12/01/Computer_system/Database_system/1%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/12/01/Computer_system/Database_system/1%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据库的一些基础概念"><a href="#1-数据库的一些基础概念" class="headerlink" title="1 数据库的一些基础概念"></a>1 数据库的一些基础概念</h1><h2 id="1-1-数据库和数据库管理系统"><a href="#1-1-数据库和数据库管理系统" class="headerlink" title="1.1 数据库和数据库管理系统"></a>1.1 数据库和数据库管理系统</h2><p>A <strong>database-management system</strong> (<strong>DBMS</strong>) is a collection of interrelated data and a set of programs to access those data. </p><p>It is a powerful tool for managing large amount of data efficiently and allowing data to persist safely.</p><p><strong>Database</strong> refers to a collection of data that is managed by a DBMS</p><p>数据库是一组相关数据的集合，而数据库管理系统（DBMS）是管理、维护和操作这些数据的软件系统。简单来说，数据库是数据的集合，而DBMS是用来管理和操作这些数据的工具。</p><h2 id="1-2-关系模式和关系实例"><a href="#1-2-关系模式和关系实例" class="headerlink" title="1.2 关系模式和关系实例"></a>1.2 关系模式和关系实例</h2><p>关系模式（Relation Schema）和关系实例Relation Instance是关系型数据库中的两个不同但相关的概念。</p><p>A relation schema (关系模式) consists of a list of attributes and their corresponding domains.It defines the structure of the table, but does not include any actual data.</p><p>关系模式（Relation Schema）是指关系型数据库中表格的结构，包括表格的名称、列名、数据类型、主键和外键等。它定义了表格的结构，但并不包含任何实际的数据。关系模式通常通过CREATE TABLE语句来定义。</p><p>A relation instance (关系实例) is a set of tuples over a relation schema</p><p>关系实例（Relation Instance）是指关系模式中表格中的具体数据，也就是表格中的行和列。它是关系模式的一个具体实例，包括表格中的所有数据。关系实例可以通过SELECT语句来检索和查询。</p><p>例如，假设我们有一个关系模式为“学生（Student）”，包括学生编号（Student ID）、姓名（Name）、年龄（Age）和性别（Gender）等列。那么，关系实例就是表格中的具体数据，如学生编号为001、姓名为张三、年龄为20岁、性别为男性等。</p><h2 id="1-3-数据库模式和数据库实例"><a href="#1-3-数据库模式和数据库实例" class="headerlink" title="1.3 数据库模式和数据库实例"></a>1.3 数据库模式和数据库实例</h2><p>数据库模式（Database Schema）是数据库的结构图，它描述了数据库中各个表、列、主键、外键等的结构和关系。也就是说，数据库模式定义了数据库中数据的逻辑结构，包括表格、关系、约束和索引等元素。它是一个静态概念，不会发生变化，除非进行数据库结构的修改。</p><p>Database schema (数据库模式) – is the logical structure of the database</p><p>数据库实例（Database Instance）是指在计算机内存中运行的数据库，它是数据库在运行时的状态。也就是说，数据库实例包含了数据库中所有数据的副本以及处理这些数据的进程和线程。每个数据库实例都有自己的内存空间和处理器资源，可以独立地进行处理和管理。</p><p>Database instance (数据库实例) – is a snapshot of the data in the database at a given instant in time. </p><h1 id="2-数据库组织形式"><a href="#2-数据库组织形式" class="headerlink" title="2 数据库组织形式"></a>2 数据库组织形式</h1><h2 id="2-1-数据采用文件的缺点"><a href="#2-1-数据采用文件的缺点" class="headerlink" title="2.1  数据采用文件的缺点"></a>2.1  数据采用文件的缺点</h2><p>1 获得数据很困难，得为每一个潜在的程序写代码程序</p><p>Difficulty in accessing data</p><p>2 数据丢失或者不一致</p><p>Data redundancy and inconsistency</p><p>3 完整性问题</p><p>Integrity problem</p><p>4 并发访问，或者操作到一半的时候可能会出现程序崩掉，这时候数据库可能会把前面未完整执行的进行执行</p><p>Concurrent-access problem </p><p>5 安全访问问题</p><p>Security problem</p><p>6 操作原子性问题</p><p>Atomicity problem </p><h2 id="2-2-使用数据库管理系统的-优点"><a href="#2-2-使用数据库管理系统的-优点" class="headerlink" title="2.2  使用数据库管理系统的 优点"></a>2.2  使用数据库管理系统的 优点</h2><p> 主要是两方面</p><p>​便于查询和修改数据</p><p>​便于确定数据逻辑结构</p><p>​支持大量数据</p><p>​访问控制</p><p>​原子性操作</p><p>即事务是原子的。原子性是指事务中的所有操作被视为一个单独、不可分割的操作，要么全部执行成功，要么全部失败回滚，不会出现部分执行的情况。</p><p>这意味着，如果一个事务包含多个操作，如果其中任何一个操作失败，整个事务就会回滚，回到原始状态，所有的操作都会取消。这种方式可以确保数据的一致性和完整性，避免了数据损坏或错误的情况。</p><h1 id="3-关系型数据库特点"><a href="#3-关系型数据库特点" class="headerlink" title="3  关系型数据库特点"></a>3  关系型数据库特点</h1><ol><li>数据以表格（表）的形式存储，其中每个表包含行和列，每个表有独一无二的名称</li><li>表之间可以建立关系，通过外键（foreign key）实现表之间的连接。</li><li>数据库使用结构化查询语言（SQL）进行查询和操作。</li><li>关系型数据库通常支持事务处理和数据完整性控制。</li></ol><h1 id="4-三个层次的数据抽象Data-Abstraction"><a href="#4-三个层次的数据抽象Data-Abstraction" class="headerlink" title="4 三个层次的数据抽象Data Abstraction"></a>4 三个层次的数据抽象Data Abstraction</h1><p>Logical level：users can see all tables and how they are related</p><p>比如数据表的组织方式</p><p>Physical level: describe how data is stored in a file.</p><p>比如某一个内容占据多少字节等等</p><p>View level: users can see the tables within the scope of their requirements and permissions.</p><p>比如教师可以看到教师的数据表，而学生只能看到学生的数据表</p><h1 id="5-超键、候选码、主码、外码"><a href="#5-超键、候选码、主码、外码" class="headerlink" title="5 超键、候选码、主码、外码"></a>5 超键、候选码、主码、外码</h1><p><strong>超键</strong></p><p>在关系型数据库中，<strong>超键（Superkey）</strong>是能够唯一标识一个关系中元组的一组属性集合。简单来说，超键是可以唯一区分关系模式中不同元组的一组属性。</p><p>超键具有以下特点：</p><ol><li>超键必须是唯一的，即在关系模式中没有两个元组具有相同的超键值。</li><li>超键可以包含一个或多个属性。</li><li>超键可以是候选键（Candidate Key）的超集，也可以是包含主键（Primary Key）的超键。</li></ol><p>注意这里是超键的每一个子集都一样</p><p>ID，ID2，姓名，年龄，性别</p><p><strong>候选码</strong></p><p>​最小的超键，可以有多个</p><p><strong>主码</strong></p><p>​从候选码里选出来，唯一的一个  主码是数据库表中的一个字段或一组字段，用于唯一标识表中的每一行记录。</p><p>主码是数据库表中唯一标识记录的字段或字段集合，每个表只能有一个主码。候选码也是具有唯一性的字段或字段集合，但一个表可以有多个候选码，其中一个通常会被选择为主码。主要区别在于主码是表的主要标识符，而候选码是备选的唯一标识符。</p><p>写一个关系模式，将主键用下划线画出来，且一般在其他元素前</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231130203407360.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231130203407360.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231130203407360"></p><p>写出他的关系模式</p><p>注意这里，用 两个才能唯一区别building, room number同时画下划线</p><p><strong>外码</strong></p><p>“参照关系”和”被参照关系”是用来描述表之间关系的术语，它们涉及到外码（Foreign Key）和主码（Primary Key）之间的联系。以下是它们的解释：</p><ol><li><p>参照关系（Referencing Relationship）：</p><ul><li>“参照关系”指的是包含外码（Foreign Key）的表，该外码引用另一张表的主码（Primary Key）或候选码（Candidate Key）。</li><li>在参照关系中，外码字段存储了关联表的键值，它用于确立两个表之间的关联。</li><li>表示为：表A包含一个外码字段，该字段引用了表B的主码或候选码，这时表A就与表B存在参照关系。</li></ul></li><li><p>被参照关系（Referenced Relationship）：</p><ul><li>“被参照关系”指的是包含主码或候选码的表，该表的键值被外码字段引用，从而使其他表可以与它建立关联。</li><li>在被参照关系中，一个表的主码或候选码通常被其他表的外码引用，这表明它在其他表中作为关联的目标。</li><li>表示为：表B的主码或候选码被表A的外码引用，这时表B就与表A存在被参照关系。</li></ul></li></ol><p>例如，考虑以下两个表：Customers（客户）和Orders（订单）。Customers 表的 CustomerID 字段是主码，而 Orders 表的 CustomerID 字段是外码。这种情况下：</p><ul><li>Customers 表是被参照关系表，因为它的主码（CustomerID）被 Orders 表的外码字段（CustomerID）引用，允许订单表与客户表建立关联，以指示哪些客户下了哪些订单。</li><li>Orders 表是参照关系表，因为它包含了外码字段（CustomerID），该字段引用了客户表的主码（CustomerID），用于建立订单表与客户表之间的关联。</li></ul><p>总之，参照关系和被参照关系描述了表之间的关联，外码与主码之间的关系非常重要，它们有助于维护数据完整性，并允许查询和检索相关数据</p><p>一个关系数据库由多个表组成，每个表有自己独一无二的名字</p><p>一个表通常内概念有 属性，元组，分量</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209203747546.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231209203747546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231209203747546"></p><p>概念</p><p>属性的域（domain）：属性允许的值的集合，比如年龄这个属性，允许的值是正整数</p><p>r 的所有属性的域都应该是原子的。什么原子的？域的元素被认为是不可分割的单元</p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（十）运输层下</title>
      <link href="/2023/11/24/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/24/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h1><h2 id="4-1-邮件系统概述"><a href="#4-1-邮件系统概述" class="headerlink" title="4.1 邮件系统概述"></a>4.1 邮件系统概述</h2><p>邮件系统往往由三个主要组成构件，这就是用户代理，邮件服务器以协议</p><p>其中用户代理往往被浏览器所替代了，现在很少人用专门的用户代理程序了</p><p><strong>用户代理</strong> 就是用户与电子邮件系统的接口，大多数情况下他就是运行在用户计算机中的一个程序，用户代理向用户提供了一个很友好的接口（目前主要是图形界面）来发送和接收邮件。用户代理往往需要四个功能，撰写，显示，处理和通信</p><p><strong>邮件服务器</strong>  往往是既充当客户又充当服务器</p><p><strong>协议</strong>  协议主要由邮件发送协议（如SMTP）和邮件读取协议（如POP3）组成</p><p>电子邮件地址格式</p><p><code>用户名@邮件服务器域名</code>  如  <a href="mailto:&#x71;&#x6f;&#100;&#x69;&#x63;&#97;&#116;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#x71;&#x6f;&#100;&#x69;&#x63;&#97;&#116;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a></p><h2 id="4-2-邮件传输协议SMTP"><a href="#4-2-邮件传输协议SMTP" class="headerlink" title="4.2 邮件传输协议SMTP"></a>4.2 邮件传输协议SMTP</h2><p>本质上是发送命令</p><p>它的工作流程可分为几个关键步骤：</p><ol><li><strong>连接建立</strong>：SMTP客户端（通常是电子邮件客户端）开始与SMTP服务器（通常是邮件发送者的邮件服务器）建立连接。这通常通过端口25进行。使用命令如<code>HELO</code>（或<code>EHLO</code>）来识别发送者。</li><li><strong>邮件发送</strong>：建立连接后，SMTP客户端会请求发送邮件。这涉及到一系列命令，用于指定发件人（<code>MAIL FROM</code>），收件人（<code>RCPT TO</code>），以及开始邮件内容的传输（<code>DATA</code>）。在<code>DATA</code>命令之后，客户端开始传输邮件的实际内容，包括邮件的头部（如主题，发送者，接收者信息）和正文。</li><li><strong>连接释放</strong>：邮件发送后，客户端发送<code>QUIT</code>命令以关闭连接。</li></ol><h2 id="4-3-邮件发送协议POP3"><a href="#4-3-邮件发送协议POP3" class="headerlink" title="4.3 邮件发送协议POP3"></a>4.3 邮件发送协议POP3</h2><p>邮局协议版本3（POP3）是一种用于从远程邮件服务器检索电子邮件的标准协议。它被设计为简单、有效，主要用于支持离线邮件处理。POP3允许电子邮件客户端下载服务器上的邮件，并通常在下载后从服务器上删除这些邮件。</p><p>它的工作流程可分为几个关键步骤</p><ol><li><strong>连接</strong>：POP3客户端（如电子邮件应用程序）与POP3服务器（通常是邮件服务提供商的服务器）通过TCP&#x2F;IP网络建立连接。这通常使用端口110，或995（用于加密连接）。</li><li><strong>用户认证</strong>：一旦建立连接，POP3客户端需要通过发送用户名和密码对自己进行认证。通常使用<code>USER</code>和<code>PASS</code>命令来完成这一过程。</li><li><strong>检索邮件列表</strong>：认证成功后，客户端可以请求邮件列表，通常使用<code>LIST</code>命令。这个命令让客户端知道邮箱中有多少邮件以及它们的大小。</li><li><strong>下载邮件</strong>：客户端使用<code>RETR</code>命令来下载单个邮件。邮件被下载到本地设备上，客户端可以决定是否在下载后从服务器上删除邮件。</li><li><strong>删除邮件</strong>：如果客户端决定删除邮件，它会使用<code>DELE</code>命令。通常，邮件不会立即从服务器上删除，而是在客户端发送<code>QUIT</code>命令、结束会话时才删除。</li><li><strong>退出</strong>：客户端使用<code>QUIT</code>命令结束会话。这个命令告诉服务器可以释放与此会话相关的所有资源，并执行任何待处理的邮件删除操作。</li></ol><h1 id="5-动态主机配置协议DHCP"><a href="#5-动态主机配置协议DHCP" class="headerlink" title="5 动态主机配置协议DHCP"></a>5 动态主机配置协议DHCP</h1><p>为了让协议软件可以移植，协议软件的编写者不会把所有的细节都固定在源代码中，他们会将其参数化，使得很多台计算机可以使用同一个经过编译的二进制代码</p><p>在协议软件中给这些参数赋值的动作叫做协议配置</p><p>例如，连接到互联网的计算机协议软件需要配置的有 IP地址，子网掩码，默认路由IP地址，域名服务器IP地址等</p><p>但是人工配置又很不方便，所以目前采用自动协议配置方法，用动态主机配置协议DHCP，提供了一种即插即用的联网方式，当一台计算机加入新的网络和获取新的IP地址时，不用手工参与</p><h1 id="6-简单网络管理协议SNMP"><a href="#6-简单网络管理协议SNMP" class="headerlink" title="6 简单网络管理协议SNMP"></a>6 简单网络管理协议SNMP</h1><p>网络管理包括对硬件，软件和人力的使用综合协调，以便对于网络资源进行监视，测试，配置，分析和评价控制这样就能以合理的价格满足网络的需求</p><p>简单网络管理协议（Simple Network Management Protocol，SNMP）是一种用于管理和监控网络设备的标准协议。它允许网络管理员通过远程方式获取有关网络设备的信息、配置设备参数、监控设备性能并执行远程管理操作。</p><ol><li><p>SNMP的历史：<br>SNMP最早由IETF（Internet Engineering Task Force）于1988年开发，最初的版本是SNMPv1。后续发展了SNMPv2c和SNMPv3，分别于1993年和1998年发布。SNMPv3是目前广泛使用的版本，它提供了更强的安全性和认证功能。</p></li><li><p>SNMP的组成：<br>SNMP由三个主要组成部分组成：</p><ul><li>SNMP管理站（Management Station）：通常是网络管理员使用的计算机或应用程序，用于远程管理和监控网络设备。</li><li>SNMP代理（Agent）：运行在网络设备上的软件，负责收集设备信息、响应管理站的请求以及执行管理操作。</li><li>MIB（Management Information Base）：是一个层次化的数据库，存储了关于网络设备的信息。MIB是SNMP的核心，它定义了可以监控和管理的对象，这些对象有唯一的标识符（OID，Object Identifier）。</li></ul></li><li><p>SNMP通信方式：<br>SNMP使用UDP协议进行通信，通常使用161端口进行管理站到代理的通信（SNMP的Trap消息则使用162端口）。通信的基本过程如下：</p><ul><li>管理站向代理发送请求消息（Get、Set、GetNext等）。</li><li>代理响应请求，并返回相应的数据或执行请求的操作。</li><li>管理站根据响应数据进行相应的管理操作。</li></ul></li><li><p>SNMP消息类型：<br>SNMP定义了不同类型的消息，包括：</p><ul><li>Get：管理站请求代理返回指定OID的数据。</li><li>Set：管理站请求代理修改指定OID的数据。</li><li>GetNext：管理站请求代理返回比指定OID大的下一个数据。</li><li>Trap：代理主动发送通知消息给管理站，用于报告事件或警告。</li></ul></li><li><p>SNMP版本和安全性：<br>SNMPv1和SNMPv2c在安全性方面存在问题，因为它们在通信中使用明文社区字符串（Community String），容易受到攻击。SNMPv3引入了更强的安全性功能，包括消息加密、认证和访问控制，以确保通信的机密性和完整性。</p></li><li><p>SNMP的用途：<br>SNMP广泛用于监控和管理各种网络设备，包括路由器、交换机、防火墙、服务器、打印机等。它允许管理员实时监控设备性能、收集数据、执行配置更改和故障排除。</p></li></ol><p>总之，SNMP是一种用于网络管理和监控的标准协议，它提供了一种方便的方式来远程管理和监视网络设备，使网络管理员能够及时响应和解决问题，以确保网络的正常运行。通过SNMP，管理员可以获取设备的状态信息、配置参数和性能数据，从而提高网络的可靠性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（九）应用层</title>
      <link href="/2023/11/23/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/11/23/Computer_system/Net/6%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>之前我们讲运输层的时候已经讲了运输层可以给不同进程之间通信，但我们还需要应用层原因是，许多 应用需要多个进程之间相互配合完成，所以应用层进程用来约束这些配合！</p><p>每个应用层协议用来解决一个问题</p><p>应用层的许多协议都是基于客户服务器方式  客户是请求方，服务器是服务提供方</p><p>最重要内容</p><p>1 域名系统DNS——从域名解析出IP地址</p><p>2 万维网和HTTP协议，以及万维网的两种不同的信息搜索引擎</p><p>3 电子邮件的传输过程，SMTP协议和POP3协议，IMAP协议使用的场合</p><p>4 动态主机配置协议DHCP的特点</p><p>5 网络管理的三个组成部分</p><p>6 系统调用和应用编程接口的基本概念</p><p>7 P2P文件系统</p><h1 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1 域名系统DNS"></a>1 域名系统DNS</h1><h2 id="1-1-域名vsIP？"><a href="#1-1-域名vsIP？" class="headerlink" title="1.1 域名vsIP？"></a>1.1 域名vsIP？</h2><p>为什么给人们用域名？方便记忆，如baidu.com就比一串的IP好记</p><p>为什么给机器用IP？IP长度固定，方便机器处理</p><p>初期的时候，由于主机个数比较少，所以一台机器的hosts文件列出所有的域名和IP的对应关系，需要转换时查表即可。</p><p>目前计算机网络理论上也可以把所有的域名和IP的对应关系放到一个服务器中，但是问题是</p><p>1 地球上计算机过多，该服务器负荷太大</p><p>2 如果这台服务器出现问题，会导致整体的网络的瘫痪</p><p>所以提出树状结构的命名方法，并采用分布式的域名系统DNS（分布式就是分散的意思）这样即便某一台计算机出了问题，也不会导致整体出现问题</p><h2 id="1-2-域名结构"><a href="#1-2-域名结构" class="headerlink" title="1.2 域名结构"></a>1.2 域名结构</h2><p>域名一般由标号组成，标号间通过.分割</p><p>顶级域名，二级域名，三级域名……</p><p>顶级域名一般有</p><ul><li>国家顶级域名 如cn表示中国，us表示美国，uk表示英国等等</li><li>通用顶级域名 如com表示公司企业，org表示非盈利组织</li><li>基础结构域名 arpa 用于反向域名解析</li></ul><p>更高级的域名负责管理下属的域名</p><p>比如我国中国cn顶级域名下划分了41个二级域名（分为类别域名7个和行政区域名34个）</p><h2 id="1-3-域名到IP的解析过程"><a href="#1-3-域名到IP的解析过程" class="headerlink" title="1.3 域名到IP的解析过程"></a>1.3 域名到IP的解析过程</h2><p>先来了解域名服务器，即存放域名和IP对应的服务器</p><p><strong>域名服务器</strong></p><p>一个服务器所负责管辖的范围叫做区</p><p>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有节点必须是联通的，每一个区设置相应的权限域名服务器用来保存该区中所有的主机的域名到IP地址的映射</p><h3 id="域名服务器类型"><a href="#域名服务器类型" class="headerlink" title="域名服务器类型"></a>域名服务器类型</h3><p><strong>根域名服务器</strong></p><p>​最重要的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址,不管是哪一个本地域名服务器，在无法解析的时候，就首先求助于根域名服务器</p><p>  在因特网上有13个不同IP地址的根域名服务器，从a到m</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129195554528.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231129195554528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="根域名服务器分布地址"></p><p><strong>顶级域名服务器</strong>（TLD服务器）</p><p>​这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答</p><p><strong>权限域名服务器</strong></p><p>​负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应当找哪一个权限域名服务器</p><p><strong>本地域名服务器</strong></p><p>​每一个因特网服务器提供者ISP，或一个大学，都可以拥有一个本地域名服务器</p><p>为了提高域名服务器的可靠性，一般把数据复制到几个域名服务器来保存</p><p>域名解析这个过程是在多个域名服务器上的多个域名服务程序共同完成的</p><p>大概过程如下</p><p>某一个应用程序请求某域名的IP  –》 生成DNS请求报文，发送给本地的域名服务器  –》如果本地可以查到的话，则返回回答报文，查不到的话就向其他域名服务器请求直到找到为止</p><p>解析过程</p><p>主机向本地域名服务器查询采用递归查询 </p><p>本地服务器向根域名服务器查询采用迭代查询</p><p>名字的高速缓存，存放最近用到的</p><p>记录集合</p><p>mx记录</p><p>ns记录</p><p>ptr记录</p><h1 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2 文件传送协议"></a>2 文件传送协议</h1><h2 id="2-1-FTP-文件传输协议"><a href="#2-1-FTP-文件传输协议" class="headerlink" title="2.1 FTP 文件传输协议"></a>2.1 FTP 文件传输协议</h2><p>FTP是使用最广的文件传输协议</p><p>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存取权限</p><p>匿名访问通过anonymous实现</p><p>文件的传送并非很简单，原因是不同计算机厂商研制出的文件系统多达数百种，差别很大。主要体现在 </p><p>1 计算机存储数据的格式不同</p><p>2 文件目录结构和文件命名规定不同</p><p>3 存取功能的命令不同</p><p>4 访问控制方法不同</p><p>所以我们的FTP核心就是要减少或消除在不同操作系统下处理文件的不兼容性</p><p>FTP使用客户服务器方式</p><p>FTP使用两个TCP连接，一个用于控制（21端口），一个用于数据传送（20端口），因而需要两个端口号，所以数据连接和控制连接不会乱</p><p>使用两个端口的另外好处是</p><p>1 使协议更加简单和实现</p><p>2 在传输文件时还可以利用控制连接</p><h2 id="2-2-NFS-协议"><a href="#2-2-NFS-协议" class="headerlink" title="2.2 NFS 协议"></a>2.2 NFS 协议</h2><p>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定位置开始读写数据</p><p>NFS可以使用户只复制一个大文件中的很小的片段</p><p>端口2049</p><h2 id="2-3-简单文件传送协议-TFTP"><a href="#2-3-简单文件传送协议-TFTP" class="headerlink" title="2.3 简单文件传送协议 TFTP"></a>2.3 简单文件传送协议 TFTP</h2><p>特点</p><p>1 很小易于实现</p><p>2 由于很小所以TFTP只支持文件传输而不支持交互， TFTP没有一个庞大的命令集合</p><p>3 每次传输的数据有512字节，组成一个文件块，对块进行编号，从1开始，支持ASCLL码或二进制传送，可对文件进行读或写，使用很简单的首部</p><p>工作</p><p>1 很像停止等待协议，每发送完一个文件块就等待对方确认，收不到确认就重复发送PDU</p><p>2  TFTP端口号是69</p><p>三种协议比较</p><table><thead><tr><th>协议</th><th>特点</th></tr></thead><tbody><tr><td>FTP</td><td>交互式，存取权限，建立副本</td></tr><tr><td>NFS</td><td>交互式，存取权限，无副本</td></tr><tr><td>FTFP</td><td>没有交互式，不进行身份验证</td></tr></tbody></table><p>远程终端协议TRLNET</p><h1 id="3-万维网WWW"><a href="#3-万维网WWW" class="headerlink" title="3 万维网WWW"></a>3 万维网WWW</h1><p>万维网是一个分布式的超媒体系统，它是超文本系统的扩充</p><p>万维网将大量的信息分布在整个互联网</p><p>要核心解决几个问题</p><p>1 怎样标志分别分布在整个互联网的万维网文档——用URL</p><p>2 用什么样的协议实现万维网上的各种连接——用HTTP</p><p>3 怎样使得不同作者创作不同风格的万维网文档，都能在互联网上各种主机显示 使用HTML</p><p>4 怎么样使得用户能够方便找到需要的资源——用搜索工具</p><p>接下来分别探讨下面的问题</p><h2 id="3-1-统一资源定位符URL"><a href="#3-1-统一资源定位符URL" class="headerlink" title="3.1 统一资源定位符URL"></a>3.1 统一资源定位符URL</h2><p>统一资源定位符是用来表示互联网资源的位置和获得的方法</p><p>一般组成如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议:// 主机名:端口/路径</span><br></pre></td></tr></table></figure><p>协议就是通过何种方式获得该万维网文档</p><p>主机名就是存放文档主机的域名</p><p>其中端口往往被省略，因为对于特定协议，有些端口都是默认的，比如HTTP协议默认端口号为80</p><p>所以往往是如下的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议://主机名/路径</span><br></pre></td></tr></table></figure><p>很多时候都把前面的协议省去了，只保留了主机名</p><p>比如  baidu.com</p><p>完整应该是 <a href="http://baidu.com/">http://baidu.com</a></p><h2 id="3-2-超文本传送协议HTTP"><a href="#3-2-超文本传送协议HTTP" class="headerlink" title="3.2 超文本传送协议HTTP"></a>3.2 超文本传送协议HTTP</h2><p>定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传输给浏览器</p><p>HTTP协议是无连接，无记忆状态的协议</p><p>无连接即不会提前建立连接</p><p>无状态协议，这意味着每个HTTP请求都是独立的，服务器不会在多次请求之间保留任何关于客户端的状态信息。每个HTTP请求都被视为一个独立的交互，服务器不会记住之前的请求或会话信息。</p><h3 id="3-2-1-HTTP工作流程"><a href="#3-2-1-HTTP工作流程" class="headerlink" title="3.2.1 HTTP工作流程"></a>3.2.1 HTTP工作流程</h3><p>如下</p><p>1 每个万维网网点都有一个服务器进程，它不断监听TCP端口80，以便发现是否有浏览器向它发送链接建立请求</p><p>2 监听到后，建立连接，浏览器向万维网服务器发出请求，服务器返回请求页面做相应。完成任务后，TCP就被释放了</p><p>对于早期的HTTP协议 HTTP&#x2F;1.0，请求一个万维网文档耗费时间是文档传输时间加上两倍往返时间RTT（一个RTT用于建立TCP连接，另一个RTT用于请求和接收万维网文档）</p><p>这是它的一个缺点</p><p>因而HTTP&#x2F;1.1 很好解决了这个问题，它使用了持续连接的方法，就是说万维网服务器在相应之后的一段时间依然保持这个连接</p><p>后来又提出升级版本 HTTP&#x2F;2，将服务器的相应也变成了并行的，同时可以复用TCP连接的请求，</p><p>为了加快请求相应速度，往往会用到代理服务器，即将最近的一些请求和相应放到本地磁盘中 </p><h3 id="3-2-2-HTTP报文结构"><a href="#3-2-2-HTTP报文结构" class="headerlink" title="3.2.2 HTTP报文结构"></a>3.2.2 HTTP报文结构</h3><p>HTTP两类报文</p><p>1 请求报文——从客户到服务器发送请求报文</p><p>2 相应报文——从服务器到客户的回答</p><p>HTTP请求报文由客户端发送给服务器，用于请求特定资源或执行特定操作。它通常包括以下部分：</p><ul><li><p><strong>请求行（Request Line）：</strong> 包含了HTTP方法、请求的URI和HTTP协议版本。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure><p>以下是一些常见的HTTP请求方法：</p><ol><li><strong>GET</strong>：用于请求服务器发送指定资源的内容。GET请求通常用于获取数据，不应该对服务器端数据产生影响。GET请求的参数通常附在URL的查询字符串中。</li><li><strong>POST</strong>：用于向服务器提交数据，通常用于创建新资源。POST请求将数据包含在请求体中，而不是URL中。</li><li><strong>PUT</strong>：用于请求服务器更新或替换指定的资源，通常用于更新已存在的资源。PUT请求将数据包含在请求体中，并且通常会覆盖原始资源。</li><li><strong>DELETE</strong>：用于请求服务器删除指定的资源。DELETE请求用于删除服务器上的资源。</li><li><strong>PATCH</strong>：用于对资源进行部分更新。与PUT不同，PATCH只更新资源的一部分，而不是整个资源。</li><li><strong>HEAD</strong>：类似于GET请求，但服务器只返回响应头部信息，而不返回实际内容。通常用于获取资源的元数据或检查资源是否存在。</li><li><strong>OPTIONS</strong>：用于获取服务器支持的HTTP方法和资源的信息。客户端可以使用OPTIONS请求来了解服务器允许哪些方法和资源访问。</li><li><strong>TRACE</strong>：用于测试与服务器之间的连接，客户端发送一个TRACE请求，服务器返回请求的内容，以便客户端可以查看请求在传输过程中是否被修改。</li><li><strong>CONNECT</strong>：通常用于创建与服务器的网络连接，通常用于代理服务器。</li></ol></li><li><p><strong>请求头部（Request Headers）：</strong> 包含了一系列的键值对，用于传递关于请求的信息，如User-Agent、Host、Accept等。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html</span><br></pre></td></tr></table></figure></li><li><p><strong>空行（Blank Line）：</strong> 请求行和请求头之间有一个空行，用于分隔请求头部和请求体。</p></li><li><p><strong>请求体（Request Body）：</strong> 可选的部分，通常用于POST请求等情况，包含了要发送给服务器的数据。</p></li></ul><ol><li><strong>HTTP响应报文结构：</strong></li></ol><p>HTTP响应报文由服务器发送给客户端，用于回复客户端的请求。它通常包括以下部分：</p><ul><li><p><strong>状态行（Status Line）：</strong> 包含了HTTP协议版本、状态码和状态描述。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><ol><li>HTTP状态码根据其首位数字分为五大类，每个类别都表示了不同的意义。这五大类是：<ol><li><strong>1xx（Informational，信息性状态码）</strong>：这些状态码表示请求已被接收，正在处理或者需要进一步的操作。这些状态码通常不会在实际应用中经常见到，而更多用于HTTP协议的通信过程中。</li><li><strong>2xx（Successful，成功状态码）</strong>：这些状态码表示请求已成功被服务器接受、理解并处理。最常见的是200 OK，表示成功处理了请求。</li><li><strong>3xx（Redirection，重定向状态码）</strong>：这些状态码表示客户端需要采取额外的操作来完成请求。通常用于重定向到其他URL以获取请求的资源。</li><li><strong>4xx（Client Error，客户端错误状态码）</strong>：这些状态码表示客户端发送的请求有错误，无法被服务器理解或处理。最常见的是404 Not Found，表示请求的资源不存在。</li><li><strong>5xx（Server Error，服务器错误状态码）</strong>：这些状态码表示服务器在处理请求时发生了错误。最常见的是500 Internal Server Error，表示服务器内部发生了错误。</li></ol></li></ol></li><li><p><strong>响应头部（Response Headers）：</strong> 类似于请求头部，包含了一系列的键值对，用于传递关于响应的信息，如Server、Content-Type、Content-Length等。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1234</span><br></pre></td></tr></table></figure></li><li><p><strong>空行（Blank Line）：</strong> 状态行和响应头之间有一个空行，用于分隔响应头部和响应体。</p></li><li><p><strong>响应体（Response Body）：</strong> 包含了服务器返回的实际数据，例如HTML页面、JSON数据等。</p></li></ul><h3 id="3-2-3-HTTP服务器存放用户信息"><a href="#3-2-3-HTTP服务器存放用户信息" class="headerlink" title="3.2.3 HTTP服务器存放用户信息"></a>3.2.3 HTTP服务器存放用户信息</h3><p>之前讲到HTTP是无状态的，即不会保留客户端信息，但有些时候，服务器需要记住用户的信息，比如一个顾客要购买多件物品放入购物车，以便集中结账</p><p>这时候需要用到Cookie</p><p>工作流程如下：</p><ol><li><p><strong>创建Cookie：</strong> 服务器在HTTP响应中通过<code>Set-Cookie</code>头部字段创建Cookie，并将其发送到客户端浏览器。Cookie包含一个键值对，通常是一个名称和一个值，以及一些其他属性，如过期时间、域名、路径等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: username=johndoe; expires=Sat, 31 Dec 2023 23:59:59 GMT; path=/; domain=example.com; secure; HttpOnly</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，服务器创建了一个名为<code>username</code>的Cookie，它的值是<code>johndoe</code>，并设置了过期时间、路径、域名等属性。</p></li><li><p><strong>存储Cookie：</strong> 一旦浏览器接收到Cookie，它会将Cookie存储在本地的Cookie存储中。这个存储通常是浏览器的内存或磁盘中的一个文件。</p></li><li><p><strong>发送Cookie：</strong> 当浏览器向同一服务器发出后续HTTP请求时，它会将与该服务器相关的Cookie附加到请求的<code>Cookie</code>头部字段中。这使得服务器能够识别用户并访问之前存储的信息。</p></li><li><p><strong>服务器读取Cookie：</strong> 服务器在收到HTTP请求时，会检查请求的<code>Cookie</code>头部字段以获取相关的Cookie信息。这允许服务器识别用户，并根据需要执行特定的操作，如验证用户身份、提供个性化内容等。</p></li><li><p><strong>更新Cookie：</strong> 服务器可以在HTTP响应中更新或修改Cookie的内容，以便在客户端的下一次请求中反映这些更改。例如，服务器可以更新Cookie的过期时间或值。</p></li></ol><h2 id="3-3-超文本标记语言HTML"><a href="#3-3-超文本标记语言HTML" class="headerlink" title="3.3 超文本标记语言HTML"></a>3.3 超文本标记语言HTML</h2><p>他不是协议，只是一种语言</p><p>HTML的基本概述：</p><ol><li><strong>标记语言：</strong> HTML是一种标记语言，它使用一系列的标签（标记）来描述文档的结构和内容。标签通常由尖括号<code>&lt; &gt;</code>包围，如<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>等。</li><li><strong>超文本：</strong> HTML的全名是”Hypertext Markup Language”，其中的”Hypertext”表示超文本。HTML允许文档中的内容之间建立超链接，用户可以通过点击链接来导航到其他页面或资源。</li><li><strong>结构：</strong> HTML文档通常由多个部分组成，包括<code>&lt;!DOCTYPE&gt;</code>声明、<code>&lt;html&gt;</code>元素、<code>&lt;head&gt;</code>元素（包含文档的元数据信息）、<code>&lt;title&gt;</code>元素（指定页面标题）、<code>&lt;body&gt;</code>元素（包含页面的主要内容）等。</li><li><strong>元素和属性：</strong> HTML由各种不同类型的元素组成，每个元素有其特定的含义和用途。元素可以包含其他元素，形成嵌套结构。元素通常具有属性，用于提供有关元素的额外信息。例如，<code>&lt;a&gt;</code>元素用于创建超链接，它可以包含<code>href</code>属性，指定链接的目标URL。</li><li><strong>文本内容：</strong> HTML用于定义文本内容，包括标题、段落、列表、表格、图像等。通过HTML标签，可以将文本格式化、分段、组织和呈现。</li><li><strong>样式和布局：</strong> HTML通过标签定义文档的结构和内容，但通常需要使用CSS（Cascading Style Sheets）来定义页面的样式和布局。CSS允许开发人员控制文本和元素的外观，包括颜色、字体、大小、间距等。</li><li><strong>交互性：</strong> HTML也可以与JavaScript一起使用，以实现页面的交互性和动态行为。JavaScript可以通过DOM（Document Object Model）访问和操作HTML元素，使用户能够与页面交互。</li></ol><h2 id="3-4-搜索工具"><a href="#3-4-搜索工具" class="headerlink" title="3.4 搜索工具"></a>3.4 搜索工具</h2><p>搜索引擎是一种用于查找和检索互联网上的信息的计算机程序或工具。它们允许用户输入关键词或查询，并返回与这些关键词相关的网页、文档、图片、视频和其他多媒体内容的搜索结果列表。搜索引擎在互联网上广泛使用，是人们获取信息、解决问题和进行研究的重要工具。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（八）运输层下</title>
      <link href="/2023/11/22/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/22/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="3-运输层主要协议-TCP-概述"><a href="#3-运输层主要协议-TCP-概述" class="headerlink" title="3 运输层主要协议 TCP 概述"></a>3 运输层主要协议 TCP 概述</h1><h2 id="3-1-TCP概述-特点"><a href="#3-1-TCP概述-特点" class="headerlink" title="3.1 TCP概述 特点"></a>3.1 TCP概述 特点</h2><p>TCP是面向连接的运输协议</p><ul><li>每一条TCP只能有两个端点，点对点</li><li>提供可靠的全双工交付</li><li>面向字节流，但占用很多资源</li><li>不提供广播和多播服务</li></ul><p>所以从某种意义来说</p><p>UDP是一种更加有效的工作方式</p><p>TCP面向流的概念</p><p>把字节写入发送缓冲，加上TCP首部构成TCP报文段，从接收缓存读取字节，到接收方</p><h2 id="3-2-TCP连接"><a href="#3-2-TCP连接" class="headerlink" title="3.2 TCP连接"></a>3.2 TCP连接</h2><p>TCP的连接端点叫做套接字（端口号拼接到IP地址构成了套接字）</p><p>套接字socket&#x3D;（IP地址：端口号） 如(192.268.2.2:80)</p><p>对于要实现传送，可靠传送，拥塞控制等，某些状态信息是必要的。从发送方主机和接收方主机上预留的资源，中间系统不必为主机预留资源</p><h2 id="RSVP资源预留协议"><a href="#RSVP资源预留协议" class="headerlink" title="RSVP资源预留协议"></a>RSVP资源预留协议</h2><p>是在终端和路由器之间进行业务质量参数协商的信令协议</p><p>商量预留带宽和缓冲区的大小</p><p>双向资源预留</p><p>TCP可靠传输明白数据分组中的序号代表发送的起始位置，确认号</p><h1 id="4-TCP可靠传输"><a href="#4-TCP可靠传输" class="headerlink" title="4 TCP可靠传输"></a>4 TCP可靠传输</h1><h2 id="4-1-可靠传输工作原理"><a href="#4-1-可靠传输工作原理" class="headerlink" title="4.1 可靠传输工作原理"></a>4.1 可靠传输工作原理</h2><h3 id="4-1-1-停止等待协议"><a href="#4-1-1-停止等待协议" class="headerlink" title="4.1.1 停止等待协议"></a>4.1.1 停止等待协议</h3><p>就是每发送完一个分组就停止发送，等待对方确认，在收到确认之后再发送下一个分组</p><p>全双工通信的双方既是发送方也是接收方</p><p>假设我们发送方是A，接收方是B</p><p>发送消息$M_0,M_1……$</p><p><strong>无差错情况</strong></p><p>即A发送，B确认后正常返回确认信息</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142255828.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142255828.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p><strong>出现差错</strong></p><p>出现差错有两种情况</p><p>情况一：发送信息没有到达接收方B，接收方B自然不会向发送方A传输确认信息</p><p>情况二：接收方B检测出了错误，直接丢弃，也不会给发送方A传输确认信息</p><p>那么A怎么判断是否出现差错呢？就是通过<strong>超时重传</strong>（设置一个超时计时器） 等一段时间如果没有收到确认信息，则认为传输差错，重传</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142847341.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220142847341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p><strong>确认丢失和确认迟到</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220143104496.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231220143104496.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图示"></p><p>这种情况发生在接收方向发送方发送确认信息的时候，确认信息丢失</p><p>导致A以为B没有正确收到，就会导致重复发送M信息，然后B收到重复的M之后，处理是</p><p>第一步 丢弃重复的M </p><p>第二步 向A再发送确认信息</p><p>停止等待协议优点是简单</p><p>缺点是信道利用率太低</p><p>采用了流水线式的传输</p><h3 id="4-1-2-连续ARQ协议"><a href="#4-1-2-连续ARQ协议" class="headerlink" title="4.1.2 连续ARQ协议"></a>4.1.2 连续ARQ协议</h3><p>连续ARQ协议会设置一个滑动窗口，窗口内部的是可以进行发送的，发送方每收到一个确认，就把发送窗口向前移动一个分组的位置。</p><p>接收方一般都采用累积确认方法，也就是说不必逐个发送确认，而是收到几个分组之后，对按序到达的最后一个分组发送确认（这就表示到目前为止所有分组发送都正确的）</p><p>优点是：容易实现</p><p>缺点是：不能向发送方及时反映接收方收到的消息</p><h2 id="4-2-TCP可靠通信的具体实现"><a href="#4-2-TCP可靠通信的具体实现" class="headerlink" title="4.2 TCP可靠通信的具体实现"></a>4.2 TCP可靠通信的具体实现</h2><p>具体实现方式之前，先了解TCP报文段首部格式</p><p>TCP面向字节流，但是传输单元是报文段</p><p>一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项</p><h3 id="4-2-1-以字节为单位的滑动窗口"><a href="#4-2-1-以字节为单位的滑动窗口" class="headerlink" title="4.2.1 以字节为单位的滑动窗口"></a>4.2.1 以字节为单位的滑动窗口</h3><p>首先对于发送方有一个发送窗口，接收方有一个接收窗口</p><p>发送方根据接收方传来的确认号与自己的发送窗口大小构建窗口或者移动窗口</p><p>接收方不断确认，然后按序交付给高层</p><h3 id="4-2-2-超时重传时间的选择"><a href="#4-2-2-超时重传时间的选择" class="headerlink" title="4.2.2 超时重传时间的选择"></a>4.2.2 超时重传时间的选择</h3><p>$RTO&#x3D;(1-\alpha)RTO+\alpha RTT$</p><p>前面我们讲到TCP发送方在规定时间没有收到则要进行重传</p><p>重传时间的选择是非常复杂的</p><p>TCP采用了一种自适应的算法</p><p>它记录一个报文段发送出去的时间，以及收到相应的确认的时间。这两个时间之差就是**报文段往返时间$RTT$**，为了结果更加平滑，引入了加权平均往返时间$RTT_s$</p><p>每测量一个新的RTT样本，进行一次重新的计算</p><p>$新RTT_S&#x3D;(1-a)×(旧的RTT_S)+a×(新的RTT样本)$</p><p>a是一个常数，一般选择0.125</p><p>最后我们的超时重传时间RTO应略大于上面得出的加权平均往返时间$RTT_S$</p><p>实际计算</p><p>$RTO&#x3D;RTT_S+RTT_D$</p><p>$RTT_D$是RTT的偏差加权平均值</p><h3 id="4-2-3-选择确认SACK"><a href="#4-2-3-选择确认SACK" class="headerlink" title="4.2.3 选择确认SACK"></a>4.2.3 选择确认SACK</h3><p>还有一个问题，就是如果收到的报文没有差错，只是未按序号，中间还缺少一些</p><p>那么能否只传输缺少的数据，而不传输已经正确到达的</p><p>是可以的，选择确认就是一种可行的处理方法SACK</p><p>这个SACK是可以选择的，双方通信可以约定好，如果使用的话会造成更大开销</p><h1 id="5-TCP的流量控制"><a href="#5-TCP的流量控制" class="headerlink" title="5 TCP的流量控制"></a>5 TCP的流量控制</h1><p>一般来说，我们总是希望数据传输的快一些，但是如果发送方数据传输过快，那么接收方就来不及接收而造成数据丢失，所以需要流量控制——让发送方的发送速率不要太快，让接收方来得及接收</p><h2 id="5-1-滑动窗口实现"><a href="#5-1-滑动窗口实现" class="headerlink" title="5.1 滑动窗口实现"></a>5.1 滑动窗口实现</h2><p>实际就是通过如果发送方发现发过去会导致丢失，那么则减小滑动窗口的大小</p><ol><li><strong>糊涂窗口综合征</strong>：当发送方和接收方对滑动窗口的大小以及如何控制它的方式存在一些不一致或不清晰的理解时，就会出现糊涂窗口综合征。这可能导致以下问题：<ul><li><strong>窗口过小</strong>：如果接收方认为滑动窗口太小，无法有效利用可用的带宽，可能会导致数据传输速度变慢，从而浪费了网络资源。</li><li><strong>窗口过大</strong>：如果发送方认为滑动窗口可以更大，但接收方不能及时处理或确认所有数据包，就会导致拥塞和丢包问题。</li><li><strong>滑动窗口不同步</strong>：如果发送方和接收方之间的窗口大小或滑动窗口控制逻辑不一致，可能会导致数据包的重传和混淆，从而使网络性能下降。</li></ul></li><li><strong>解决方法</strong>：要解决糊涂窗口综合征，需要确保发送方和接收方之间对于窗口大小和滑动窗口控制的方式达成一致。这可以通过更好地协调和调整滑动窗口参数，以及在网络中实施拥塞控制策略来实现。</li></ol><p>$最大吞吐量&#x3D;\frac{窗口大小}{RTT}$</p><p>注意需要统一单位 最大吞吐量是bit&#x2F;s </p><p>所以窗口大小&#x3D;字节数*8   RTT要转换为s</p><h1 id="6-TCP拥塞控制"><a href="#6-TCP拥塞控制" class="headerlink" title="6 TCP拥塞控制"></a>6 TCP拥塞控制</h1><h2 id="6-1-拥塞控制一般原理"><a href="#6-1-拥塞控制一般原理" class="headerlink" title="6.1 拥塞控制一般原理"></a>6.1 拥塞控制一般原理</h2><p>当对网络中的某一资源的需求大于网络能够提供的资源时，则会产生拥塞，导致网络性能变坏，因而要进行拥塞控制</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231107164703168.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231107164703168.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="拥塞控制所起的作用图示"></p><h2 id="6-2-拥塞控制的方法"><a href="#6-2-拥塞控制的方法" class="headerlink" title="6.2 拥塞控制的方法"></a>6.2 拥塞控制的方法</h2><h3 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1 慢开始"></a>1 慢开始</h3><p>拥塞窗口用来反映当前网络的这个拥塞情况，越大说明越拥塞</p><p>​用来确定网络的负载能力，核心由小到大逐渐增大拥塞窗口数值</p><p>​初始拥塞窗口cwnd的设置：</p><p>​旧规定，先把初始拥塞窗口cwnd设置为1到2个发送方最大报文段SMSS的数值</p><p>​新的RFC 5681 把初始拥塞窗口cwnd设置为不超过2到4个SMSS数值</p><p>慢开始门限</p><p>拥塞窗口控制方法：</p><p>​在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值</p><p>使用慢开始算法后，没经过一个传输轮次，拥塞窗口cwnd就加倍</p><p>一个传输轮次所经历的时间就是往返时间RTT。传输轮次更加强调：把拥塞窗口cwnd所允许发送的报文段都连续</p><p>设置一个慢开始门限ssthresh，</p><p>当cwnd&lt;ssthresh 使用慢开始算法</p><p>当cwnd&gt;ssthresh 改为使用拥塞避免算法</p><h3 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2 拥塞避免"></a>2 拥塞避免</h3><p>​让拥塞窗口缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口+1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长</p><p>因此，在拥塞避免阶段就有点“加法增大”特点</p><p>当出现拥塞的时候，减少分组数</p><h3 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3 快重传"></a>3 快重传</h3><p>让对方尽早知道发生了个别报文段的丢失</p><p>快重传算法首先要求接收方不要等待自己发送数据才进行捎带确认，而不是立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</p><p>当发送方一连收到三个重复确认，就知道接收方确实没有收到报文段，因而立即进行重传</p><h3 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4 快恢复"></a>4 快恢复</h3><p>当发送方一连收到三个重复确认，不认为此时发生了拥堵</p><p>因而不执行慢开始算法，而是执行快恢复算法</p><h3 id="主动队列管理AQM"><a href="#主动队列管理AQM" class="headerlink" title="主动队列管理AQM"></a>主动队列管理AQM</h3><p>就是不要等到路由器的队列长度已经达到最大值的时候才不得不丢弃后面到达的分组，这样就太被动了</p><p>应当在队列长度到达某个值得警惕的数值时，就主动丢弃到达的分组</p><h1 id="7-TCP运输连接管理"><a href="#7-TCP运输连接管理" class="headerlink" title="7 TCP运输连接管理"></a>7 TCP运输连接管理</h1><h2 id="7-1-TCP的建立"><a href="#7-1-TCP的建立" class="headerlink" title="7.1 TCP的建立"></a>7.1 TCP的建立</h2><p>​TCP建立的过程叫做握手</p><p>​握手需要再客户和服务器之间交换三个TCP报文段，称之为三报文段握手</p><p>​采用三报文段握手主要为了防止已失效的连接请求报文段突然又传送到了，因而产生错误</p><h2 id="7-2-TCP的连接释放"><a href="#7-2-TCP的连接释放" class="headerlink" title="7.2 TCP的连接释放"></a>7.2 TCP的连接释放</h2><p>​四次握手</p><p>​为什么四次，核心原因就是因为全双工的原因！</p><p>TCP的有限状态机</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（七）运输层上</title>
      <link href="/2023/11/21/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2023/11/21/Computer_system/Net/5%20%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运输层概述"><a href="#1-运输层概述" class="headerlink" title="1 运输层概述"></a>1 运输层概述</h1><h2 id="1-1-运输层存在的意义"><a href="#1-1-运输层存在的意义" class="headerlink" title="1.1 运输层存在的意义"></a>1.1 运输层存在的意义</h2><p>之前我们讲网络层的时候，已经可以将信息从一个主机传递到另一个主机了。</p><p>那么为什么我们还需要运输层呢？</p><p>是因为我们两个主机通信的时候，大多数情况是两个主机不同的进程在通信，比如我们浏览器访问需要一个进程，发邮件又需要一个进程。很多时候这些进程都是并行通信的。那么网络层是无法区分的，实际的区分通信的不同进程就交给了运输层，这也是运输层的重要作用——复用和分用</p><p>当然除了复用和分用，运输层还提供一些其他的功能如差错检测等</p><p>应用层不同进程的报文通过不同的端口向下交付到运输层</p><p>运输层提供应用进程的逻辑通信——逻辑通信的意思是：运输层之间的通信好像是沿着水平方向传送数据，但事实上这两个运输层之间并没有一条水平方向的物理连接</p><p>所以总结来看</p><p>网络层和运输层的区别</p><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信</p><h2 id="1-2-运输层协议概述"><a href="#1-2-运输层协议概述" class="headerlink" title="1.2 运输层协议概述"></a>1.2 运输层协议概述</h2><p>运输层主要有两个不同的运输协议</p><p> TCP和UDP</p><p>他们各自的PDU（运输协议单元如下）</p><p>UDP：它的PDU是TCP报文段</p><p>TCP：它的PDU是UDP报文段或用户数据报</p><p>那么实际中运输层如何区分不同的进程呢？通过抽象了端口号这种方式</p><p>由此可见，两个计算机中的进程需要对方的IP地址，还要知道对方的端口号（为了找到对方计算机中的应用程序）</p><p>不同端口号代表不同进程。</p><p>设计者们对端口号做了如下一些规定</p><h2 id="1-3-主要端口号"><a href="#1-3-主要端口号" class="headerlink" title="1.3 主要端口号"></a>1.3 主要端口号</h2><p>两大类端口</p><p>（1）服务端使用的端口号</p><p>又分为两大类</p><p><strong>熟知端口</strong>，数值一般为0~1023</p><p>​熟知端口号用来指派给TCP&#x2F;IP最重要的一些程序，如下图所示</p><p><strong>登记端口</strong>，数值为1024~49151</p><p>​没有数值端口使用的，使用的话必须登记</p><p>（2）客户端使用的端口号</p><p><strong>短暂端口号</strong>，数值49152~65535</p><p>​仅在客户端进程运行时动态选择，因此又叫做短暂端口号</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106172846757.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106172846757.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="常用熟知端口"><br>下面分别讨论UDP和TCP</p><p>其中UDP比较简单</p><h1 id="2-运输层主要协议-UDP"><a href="#2-运输层主要协议-UDP" class="headerlink" title="2 运输层主要协议 UDP"></a>2 运输层主要协议 UDP</h1><p>UDP只在IP数据报上增加了很少一点的功能，即端口功能和差错检测的功能</p><h2 id="2-1-UDP的特点"><a href="#2-1-UDP的特点" class="headerlink" title="2.1 UDP的特点"></a>2.1 UDP的特点</h2><ol><li>UDP是一种无连接协议</li></ol><ul><li>提供无连接服务  传送数据前不需要先建立连接</li><li>不提供可靠交付   对方的运输层在收到UDP报文后，不需要给出任何确认</li></ul><ol start="2"><li>尽最大努力交付</li><li>没有拥塞控制</li><li>UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>对于应用层的报文，不合并不拆分，多长就都发送</li><li>UDP首部开销较小</li></ol><h2 id="2-2-UDP首部格式"><a href="#2-2-UDP首部格式" class="headerlink" title="2.2 UDP首部格式"></a>2.2 UDP首部格式</h2><p>UDP首部很简单就八个字节，由四个字段组成，每个字段长度都是2字节</p><ol><li>源端口  </li><li>目的端口</li><li>长度   数据报长度，最小值是8</li><li>检验和    检测传输中是否有错</li></ol><h2 id="2-3-UDP工作流"><a href="#2-3-UDP工作流" class="headerlink" title="2.3 UDP工作流"></a>2.3 UDP工作流</h2><p>如果接收方UDP发现报文端口号不正确，就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</p><p>对于UDP的差错检测，和IP数据报检测方法类似</p><ol><li><p>首先，将UDP首部中的检验和字段置为0，以便进行计算。</p></li><li><p>将UDP伪首部添加到UDP数据包前面。伪首部包含了一些IP层的信息，用于计算检验和。伪首部的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Source IP Address (32 bits)</span><br><span class="line">Destination IP Address (32 bits)</span><br><span class="line">Reserved (8 bits, 值为0)</span><br><span class="line">Protocol (8 bits, UDP的协议值为17)</span><br><span class="line">UDP Length (16 bits, UDP首部+UDP数据的总长度)</span><br></pre></td></tr></table></figure><p>伪首部中的字段分别是源IP地址、目标IP地址、保留字段、协议字段（UDP的协议值为17）和UDP长度字段。这些字段一起构成了伪首部。</p></li><li><p>将UDP伪首部的各字段以及UDP首部和UDP数据中的所有16位字（如果数据不是16位的倍数，需要填充0使其满足16位字的条件）进行按位求和。这意味着将它们视为16位整数，将它们相加，如果结果溢出，则将溢出部分加到总和的末尾。</p></li><li><p>取总和的反码（将所有位取反，1变为0，0变为1），并将结果存储在UDP首部的检验和字段中。</p></li><li><p>发送方将带有计算后的检验和字段的UDP数据包发送到目标主机。</p></li><li><p>接收方在收到UDP数据包后，重复以上步骤，计算接收方的检验和。</p></li><li><p>接收方将计算得到的检验和与UDP首部中的检验和字段进行比较。如果它们匹配，说明数据包未损坏；如果不匹配，说明数据包可能已损坏或被篡改，接收方可以选择丢弃这个数据包。</p></li></ol><p>总之，UDP检验和用于检测UDP数据包在传输过程中的完整性，但它不提供数据包的可靠传输和重传机制。如果检验和不匹配，接收方可以选择忽略数据包或向上层报告错误，但UDP本身不会进行重传。这是与TCP不同的地方，TCP提供了可靠的数据传输和重传机制。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（六）网络层下</title>
      <link href="/2023/11/20/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/20/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="5-IPv6"><a href="#5-IPv6" class="headerlink" title="5 IPv6"></a>5 IPv6</h1><p>由于IPv4不够用了，所以后面用了范围更大的IPv6</p><p>主要变化如下</p><p>1 将地址从IPbv4的32位变到了128位</p><p>2 扩展的地址层次结构</p><p>3 更加灵活的首部格式</p><h2 id="5-1-组成"><a href="#5-1-组成" class="headerlink" title="5.1 组成"></a>5.1 组成</h2><p>由两大部分组成，即基本首部和后面的有效载荷（有效载荷允许有多个扩展首部）</p><h2 id="5-2-IPv6地址"><a href="#5-2-IPv6地址" class="headerlink" title="5.2 IPv6地址"></a>5.2 IPv6地址</h2><p>由于IPv6很大很大，所以原本的点分十进制也不够方便了</p><p>所以现在IPb6使用冒号十六进制法</p><p>比如如下：</p><p>68E6:8C64:0000:0000:0:1180:960A:FFFF</p><p>对于连续的零可以进行压缩表示，用双冒号替代</p><p>FF05:0:0:0:0:0:0:B3</p><p>如上面可以压缩为FF05::B3</p><p>为了不发生歧义，一个地址规定只能使用一次零压缩</p><p>本地链接单播地址 由fe90打头</p><p>本地连接单播地址就是二层地址，不能跨路由器通信</p><h2 id="5-3-从IPv4向IPv6过渡"><a href="#5-3-从IPv4向IPv6过渡" class="headerlink" title="5.3 从IPv4向IPv6过渡"></a>5.3 从IPv4向IPv6过渡</h2><p>介绍两种过渡方法</p><h3 id="5-3-1-双协议栈"><a href="#5-3-1-双协议栈" class="headerlink" title="5.3.1 双协议栈"></a>5.3.1 双协议栈</h3><p>双协议栈是指完全过渡到IPv6之前，一部分主机或路由器同时装有IPv4和IPv6这两种协议栈</p><p>在和IPv4主机通信的时候采用IPv4，在和IPv6主机通信的时候采用IPv6</p><p>但是这种过渡方式代价太大，需要安装两套协议，所以提出下面的隧道技术</p><h3 id="5-3-2-隧道技术"><a href="#5-3-2-隧道技术" class="headerlink" title="5.3.2 隧道技术"></a>5.3.2 隧道技术</h3><p>隧道技术核心就是在IPv6进入网络前 进行封装为IPv4帧传输，这样接收方接收到IPv6数据报后再解析IPv6数据报</p><p>隧道技术实际上也会用到双协议栈，只不过只在入网和出网的时候安装两个就行，中途的主机都不需要安装</p><h1 id="6-因特网的路由选择协议"><a href="#6-因特网的路由选择协议" class="headerlink" title="6 因特网的路由选择协议"></a>6 因特网的路由选择协议</h1><p>路由选择核心就是讨论转发表中的路由是怎么得出来的</p><p>理想的路由算法要尽可能</p><p>正确完整，简单，稳定且公平</p><p>对于路由选择协议，按照是否自适应调整可以划分为静态路由选择策略和动态路由选择策略</p><p>其中</p><ul><li>静态路由选择策略——即非自适应路由选择，简单开销小，人工配置每一条路由</li><li>动态路由选择策略——即自适应路由选择，开销大，实现较为复杂，但是可以很好适应网络状态变化</li></ul><p>我们可以把互联网划分为许多较小的自治系统AS，自治系统内部可以使用自己的路由选择协议，然后整体又可以连接到整个互联网上</p><p>那么在自治系统内部的使用的协议又叫做内部网关协议IGP，如RIP，OSPF</p><p>源主机和目的主机不在同一个自治系统叫做外部网关协议EGP，如BGP-4</p><h2 id="6-1-内部网关协议RIP"><a href="#6-1-内部网关协议RIP" class="headerlink" title="6.1 内部网关协议RIP"></a>6.1 内部网关协议RIP</h2><p>了解路由选择协议，核心要解决三个问题——和哪些路由器交换信息？交换什么信息？在什么时候交换信息？</p><p>对于RIP而言</p><p>1 交换的对象是：只和相邻的路由器交换信息</p><p>2 交换的信息是：自己现在的路由表</p><p>3 交换的时间是：按照固定时间间隔交换信息，每隔30s</p><p>路由表更新的原则是 距离向量算法</p><p>看下面的例子</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082452887.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082452887.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算更新例题" style="zoom:33%;" /><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082513161.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025082513161.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="路由表更新" style="zoom:33%;" />总结来看<p>首先是否是新信息</p><p>再看下一跳是否相同，这两种情况直接更新</p><p>如果下一跳不同的话比较距离</p><p>优点 开销较小，实现简单 </p><p>缺点 限制了网络规模，使用最大距离为15。同时好消息传递的快，坏消息传递的慢！！网络出故障后的传播时间很慢</p><h2 id="6-2-内部网关协议-OSPF"><a href="#6-2-内部网关协议-OSPF" class="headerlink" title="6.2 内部网关协议 OSPF"></a>6.2 内部网关协议 OSPF</h2><p>上述的RIP缺点是不能适用于较大规模的自治系统</p><p>所以使用OSPF，通过复合度量选择路由</p><p>同样回答三个问题——和哪些路由器交换信息？交换什么信息？在什么时候交换信息？</p><p>对于RIP而言</p><p>1 交换的对象是：和所有该区域的路由器交换</p><p>2 交换的信息是：自己现在的路由表</p><p>3 交换的时间是：按照固定时间间隔交换信息，每隔30s</p><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><p>1 带宽是主要考虑的因素</p><p>2 使用的是洪泛法，就是路由器通过输出端口向所有路由器发送信息</p><p>3 所有路由器最终建立链路状态数据库，全网范围内一致，因而克服了RIP的缺点（RIP只知道相邻的）保证了更新过程中收敛的快</p><p>同时为了能让他应用于更大规模的网络</p><p>进行了区域的划分</p><p>每次只需要对该（主干）区域做洪泛即可，因而也只需要知道主干区域的完整拓扑结构即可</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025084129538.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231025084129538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IP数据报" style="zoom:33%;" /><p>ＯＳＰＦ有五种类型</p><p>​1 问候分组 确定是否可达</p><p>​2 数据库描述分组  达到数据库的同步</p><p>​3 链路状态请求  新情况下的同步</p><p>​4 链路状态更新</p><p>​5 链路状态确认</p><h2 id="6-3-外部网关协议-BGP"><a href="#6-3-外部网关协议-BGP" class="headerlink" title="6.3 外部网关协议 BGP"></a>6.3 外部网关协议 BGP</h2><p>使得前面的自治系统连为一个整体！！！</p><p>力求寻找较好的路由，不要兜圈子即可，不用最短的</p><p>内部的路由器建立iBGP连接，而内部和外部直接建立eBGP连接</p><p>BGP发言人，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人</p><h3 id="6-3-1-路由选择"><a href="#6-3-1-路由选择" class="headerlink" title="6.3.1 路由选择"></a>6.3.1 路由选择</h3><p>1本地偏好值最高的路由优先选择</p><p>2 使用具有AS跳数最少的选择</p><p>3 使用热土豆路由算法</p><p>BGP-4使用四种报文</p><p>​1 打开</p><p>​2 更新</p><p>​3 保活</p><p>​4 <em>通知</em></p><h2 id="6-4-路由器组成"><a href="#6-4-路由器组成" class="headerlink" title="6.4 路由器组成"></a>6.4 路由器组成</h2><h3 id="6-4-1-基本了解"><a href="#6-4-1-基本了解" class="headerlink" title="6.4.1 基本了解"></a>6.4.1 基本了解</h3><p>讲完了路由选择，接下来讲解路由器</p><p>路由器是一种典型的网络层设备，具有多个输入端口和多个输出端口的专用计算机~</p><p>路由器是互联网中的关键设备</p><p>路由器的<strong>主要任务</strong>是：</p><p>​转发分组</p><p>路由器的<strong>主要作用</strong>是：</p><p>​联通不同的网络（如不同VLAN，不同的IP子网，不同的局域网和广域网）</p><p>​选择信息传送的线路（即通过选路来转发分组）</p><p>​选择通畅快捷的近路，能大大提高通信速度，减轻网络系统负荷</p><p>一个2端口的路由器，冲突域和广播域的个数分别是：2，1</p><h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2 结构"></a>6.4.2 结构</h3><p>控制平面和数据平面</p><p>控制平面</p><p>​控制平面是数据网络中做出转发决定的元素，比如路由协议，选路策略和网络设备上运行这些协议的软硬件资源等</p><p>​控制平面做出的决定包括：该把数据包发往哪条路径转发、是否要用多条路径转发同一个数据流</p><p>数据平面</p><p>​数据平面是执行控制平面决定的部分，包括数据封装协议，网络协议的高速转发芯片等</p><p>控制平面和数据平面分离</p><p>SDN采用控制平面和数据平面分离，实现灵活部署</p><p>典型路由器结构分为</p><p>路由选择部分</p><p>分组转发部分</p><p>交换结构</p><p>路由器关键部件，常用的交换方式 </p><p>通过存储线，通过总线，通过纵横结构</p><h1 id="7-IP多播"><a href="#7-IP多播" class="headerlink" title="7 IP多播"></a>7 IP多播</h1><p>目的：更好支持一对多通信，可以大大节约网络资源</p><p>一对多通信：一个源点发送到许多个终点。例如，实时信息的交付（如新闻，股市行情等）</p><p>核心就是把多次的单播变成可复制的多播</p><p>IP多播可以分为两种</p><p>1 只在本局域网上进行硬件多播</p><p>2 在互联网的范围进行多播</p><p>前一种硬件多播，比较简单但也比较重要，先讲这个</p><h2 id="7-1-硬件多播"><a href="#7-1-硬件多播" class="headerlink" title="7.1 硬件多播"></a>7.1 硬件多播</h2><p>在48位的多播地址中，前25位都固定不变，后23位可以用作多播</p><h2 id="7-2-IP多播需要三种协议"><a href="#7-2-IP多播需要三种协议" class="headerlink" title="7.2  IP多播需要三种协议"></a>7.2  IP多播需要三种协议</h2><h3 id="7-2-1-IGMP协议"><a href="#7-2-1-IGMP协议" class="headerlink" title="7.2.1 IGMP协议"></a>7.2.1 IGMP协议</h3><p>使得路由器知道多播组成员信息</p><p>IGPM是本地使用的一个范围</p><p>IGMP使用IP数据报传输报文</p><p><strong>主要两个功能</strong></p><p>​让主机加入多播组</p><p>​IGMP 报告和查询 维护 多播组转发表</p><p>IGMP工作可以分为<strong>两个阶段</strong></p><p>  第一：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP报文，申明自己是该组的成员</p><p>本地的多播路由器收到IGMP报文后，将组员关系转发给因特网上的其他多播路由器</p><p>第二：因为组员关系是动态的，因此本地多播路由器要周期性探寻本地局域网上的主机，以便知道这些主机继续是组的成员</p><p>只知道 有哪些多播组成员还是不够的</p><p>还要知道怎么到达对应的成员，这就涉及到多播路由选择协议</p><h3 id="7-2-2-多播路由选择协议"><a href="#7-2-2-多播路由选择协议" class="headerlink" title="7.2.2 多播路由选择协议"></a>7.2.2 多播路由选择协议</h3><p><strong>转发多播数据报使用的方法</strong></p><p>1 洪泛与剪除</p><p>​这种方法适用于较小的多播组，直接广播（洪泛）</p><p>​如果发现某个路由器的下游树枝没有该多播组成员，那么则直接剪除</p><p>2 隧道技术</p><p>​这种方法适合于多播组在地理上很分散的情况</p><p>3 基于核心的发现技术</p><p>​这种方法的多播组使用范围比较广</p><p>​对每一个多播组指定一个核心路由器，给出它的单播地址</p><h1 id="8-虚拟专用网络VPN"><a href="#8-虚拟专用网络VPN" class="headerlink" title="8 虚拟专用网络VPN"></a>8 虚拟专用网络VPN</h1><p>有些时候内部网络的某些主机并不需要连到互联网中，只需要和内部网络的其他网络通信即可，这时候便没必要再给他们全球独一无二的地址了</p><p>那么网络设计者们便在IP地址中划分了一部分作为本地地址（不和全球地址产生冲突）</p><p>本地地址或者叫专用地址</p><p>最经典的是192.168打头的</p><p>还有一种类型的VPN，就是远程接入VPN，核心是建立VPN隧道</p><h2 id="8-1-网络地址转换方法NAT"><a href="#8-1-网络地址转换方法NAT" class="headerlink" title="8.1 网络地址转换方法NAT"></a>8.1 网络地址转换方法NAT</h2><p>如果某些分配了本地IP地址的计算机忽然想连上互联网</p><p>一个可行分办法就是用网络地址转换NAT方式</p><p>至少有一个有效的外部全球IP地址</p><h3 id="NAT的工作原理："><a href="#NAT的工作原理：" class="headerlink" title="NAT的工作原理："></a>NAT的工作原理：</h3><p>NAT的基本原理是将内部设备的私有IP地址和端口号映射到单个或多个公共IP地址的一组唯一端口上。这样，当内部设备发送请求时，路由器会将请求从内部IP地址和端口号转换为公共IP地址和不同的端口号，以确保响应的数据包能够正确返回到请求的设备。</p><p>NAT有几种不同的方式来实现这种映射：</p><ol><li><strong>静态NAT</strong>：在静态NAT中，管理员手动配置内部IP地址和端口号与外部IP地址的映射。这些映射是固定的，通常用于服务器或特定应用程序的端口转发。</li><li><strong>动态NAT</strong>：在动态NAT中，NAT路由器动态地将内部设备的，私有IP地址映射到可用的公共IP地址，通常从一个IP地址池中选择。这种方式允许多个设备共享几个公共IP地址。</li><li><strong>PAT（端口地址转换）</strong>：PAT是一种特殊的NAT形式，它使用单个公共IP地址，但使用不同的端口号来区分内部设备。这是最常见的NAT形式，通常用于家庭网络和小型企业。</li></ol><h3 id="NAT的优点"><a href="#NAT的优点" class="headerlink" title="NAT的优点"></a>NAT的优点</h3><ul><li><strong>安全性提高</strong>：NAT可以隐藏内部网络结构，因为外部网络只能看到NAT设备的公共IP地址。这增加了网络的安全性，因为攻击者难以确定内部设备的真实IP地址。</li><li><strong>IPv4地址节省</strong>：由于IPv4地址短缺，NAT允许多个设备使用同一个公共IP地址，从而节省了IPv4地址资源。</li><li><strong>简化管理</strong>：NAT允许多个设备通过一个公共IP地址访问互联网，简化了网络管理。</li></ul><h1 id="9-MPLS多协议标签交换"><a href="#9-MPLS多协议标签交换" class="headerlink" title="9 MPLS多协议标签交换"></a>9 MPLS多协议标签交换</h1><p>为了增加IP数据报的转发速度，引入了MPLS</p><p>MPLS并没有取代IP</p><p>多协议标签交换（Multiprotocol Label Switching，MPLS）是一种在计算机网络中用于数据传输的高效且灵活的技术。MPLS通过在数据包头部添加标签（Label）来对数据进行标记和转发，从而改善了数据包的路由、流量工程和服务质量。以下是MPLS的主要特点和工作原理的介绍：</p><h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ol><li><strong>标签交换</strong>：MPLS通过在数据包头部添加一个短的标签来标识数据包，而不是基于传统的IP路由表来进行转发。这个标签可以在网络中的路由器之间快速交换，从而提高了数据包的转发速度。</li><li><strong>流量工程</strong>：MPLS允许网络管理员根据网络流量的需求来管理路由和优化网络性能。管理员可以为不同的流量流分配不同的标签，以实现更好的流量控制和负载均衡。</li><li><strong>服务质量（QoS）支持</strong>：MPLS可以根据标签来实现不同类别的服务质量（如低延迟、高带宽等），这对于应对多种网络应用的需求非常重要，如实时音视频通信。</li><li><strong>简化路由表</strong>：MPLS可以减小路由器的路由表，因为它只需要考虑标签而不是完整的IP地址。这有助于减小路由器的存储和处理负担，提高了网络的扩展性。</li><li><strong>隧道和虚拟专用网络（VPN）支持</strong>：MPLS可以用于创建虚拟专用网络，使不同的企业或组织可以在共享的基础设施上构建私有网络，同时保持数据的隔离性和安全性。</li></ol><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><p>MPLS的工作原理包括以下步骤：</p><ol><li><strong>标签分配</strong>：在MPLS网络中，每个路由器都分配一个唯一的标签给数据包。这个标签通常是20位长，包含了一些信息，如数据包的下一个路由器（下一跳）。</li><li><strong>标签交换</strong>：当数据包到达一个MPLS路由器时，该路由器会查看数据包的标签，然后根据标签表将数据包转发到下一个路由器。标签表包含了标签与出口接口的映射关系。</li><li><strong>标签压栈和弹栈</strong>：在数据包通过MPLS网络的过程中，标签可以被压栈（添加新的标签）或弹栈（移除标签）。这允许数据包在网络中多次标记和转发。</li><li><strong>最终目的地</strong>：当数据包到达目的地时，最后一个MPLS路由器会弹出标签并将数据包交付给上层协议（通常是IP），然后根据目的IP地址将数据包传送到目标设备。</li></ol><p>MPLS技术的灵活性和效率使其成为了广泛应用于企业网络、服务提供商网络和数据中心网络的一种重要技术。它有助于改进网络性能、提高服务质量，并简化了网络管理。</p><p>物理层使用的中间设备叫做转发器</p><p>数据链路层使用的中间设备叫做网桥或交换机</p><p>网络层使用的中间设备叫做路由器</p><p>网络层以上使用的中间设备较网关</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（五）网络层上</title>
      <link href="/2023/11/19/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/11/19/Computer_system/Net/4%20%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>以前人们想借鉴电信网（电话网络）成功的经验，尝试采用虚电路服务，让网络层负责可靠交付，通信之前先建立虚电路。但是互联网的先驱者们提出让网络层尽可能简单，即用网络层提供简单灵活的，无连接的，尽最大努力交付的数据报服务，这是因为考虑到互联网的终端都是有智能的计算机而不是简单的电话，所以终端有着很强的数据处理能力，那么也就不需要网络层来进行这部分的可靠交付了。</p><p>后来多年的实践证明，先驱者们的选择多么正确</p><p>（1）网络层简单使得网络中的路由器可以做得比较简单,价格低廉，因而易于拓展，便于大规模发展</p><p>（2）运行方式灵活，能够适应多种应用</p><h1 id="1-网络层的两个层面"><a href="#1-网络层的两个层面" class="headerlink" title="1 网络层的两个层面"></a>1 网络层的两个层面</h1><p>两个主机通信的时候，需要经过若干个路由器转发信息。</p><p>转发的信息实际就两大类：一是传送的数据（数据层面），二是路由信息（控制层面）</p><ul><li>数据层面的信息转发：只需要查找本路由器的路由表，把收到的分组从对应的接口发送出去，数据部分直接硬件转发，速度极快，为纳秒数量级</li><li>控制层面的信息转发：路由器必须得经常和相邻的路由器交互路由信息更新自己的路由表，所以更为复杂，，软件介入转发，速度会慢了很多，为秒数量级</li></ul><h1 id="2-网络协议IP"><a href="#2-网络协议IP" class="headerlink" title="2 网络协议IP"></a>2 网络协议IP</h1><p>IP是TCP&#x2F;IP体系中最重要的两个协议之一</p><p>与IP协议配套使用的还有</p><p>地址解析协议ARP</p><p>网际控制报文协议ICMP</p><p>网际组管理协议 IGMP</p><p>如下图所示</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231213174142698.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231213174142698.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="整体结构示意图"></p><p>我们会发现ICMP，IGMP协议在IP的上方，是因为这两个协议经常需要调用IP协议</p><p>而ARP协议在IP的下方，是因为IP协议需要经常调用ARP协议</p><p>在讨论网际协议IP前，必须先了解什么是虚拟互联网络</p><h2 id="2-1-虚拟互联网络"><a href="#2-1-虚拟互联网络" class="headerlink" title="2.1 虚拟互联网络"></a>2.1 虚拟互联网络</h2><p>我们知道网络是要将全世界五花八门的计算机互联在一起，这就需要解决很多问题，最首要的一个就是异构，差异性</p><p>比如：不同的寻址方案，不同的组大分组长度，比如不同的差错控制方案等等一大堆。</p><p>那么该怎么办呢？</p><p>先驱者们提出在网络层，通过IP协议来进行统一，就是不管你其他层的协议是什么，我的网络层大家都用IP协议，这样仿佛在网络层看起来是一个统一的网络，也就叫做我们的虚拟互联网络。</p><p>所以大家可以感受到IP协议的重要性了吧！！！之前我们讲的一些协议可能通用性并没有那么强，但IP是互联网每一个用户都得遵守的boss rules</p><p>一个在互联网上的设备必须有IP地址才能与其他设备进行通信，接下来我们来了解IP地址</p><h2 id="2-2-IP地址"><a href="#2-2-IP地址" class="headerlink" title="2.2 IP地址"></a>2.2 IP地址</h2><p>整个因特网看成是一个单一的，抽象的网络</p><p>IP地址就是给每一个连接在因特网上的主机分配一个在全世界范围是唯一的32位的标识符</p><h3 id="2-2-1-固定分类编址方式"><a href="#2-2-1-固定分类编址方式" class="headerlink" title="2.2.1 固定分类编址方式"></a>2.2.1 固定分类编址方式</h3><p>IP地址由网络号和主机号组成，又叫做两级IP——网络号+主机号</p><p>​网络号表示着主机所连接到的网络，主机号表示该主机（对路由器的话是路由器）</p><p>最开始的时候采用固定分类的IP地址，即网络号的位数是固定的（8位A类,16位B类和24位C类）</p><p>如何区分不同类别的地址呢？通过网络号的前缀，如下图</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231214222727712.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231214222727712.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="固定分类编址"></p><p>对于A类地址，是网络号为8位的</p><p>​总地址空间$2^{31}$个 接近43亿</p><p>​网络号个数：由于A类地址网络号有7位，所以A类地址可以分配的网络号个数$2^7-2&#x3D;126个$，这里为什么要减去2呢，因为0000 000的网络号有特殊含义代表“本网络”，0111 1111的网络号代表环回测试</p><p>​主机号个数：$2^{24}-2$ 为什么这里还要减2呢，因为全0是本网络，全1是所有的广播</p><p>对于B类地址，是网络号为16位的</p><p>​总地址空间$2^{30}$个</p><p>​网络号个数：$2^{14}$</p><p>​主机号个数：$2^{16}-2$</p><p>对于C类地址，是网络号为24位的</p><p>​总地址空间$2^{29}$个</p><p>​网络号个数：$2^{21}$</p><p>​主机号个数：$2^{8}-2$</p><p>以上A,B,C类都是单播地址，而D类地址是多播地址</p><p>这样的好处是简单，看前缀就知道什么类型的地址了</p><p>缺点是：使用不灵活的问题</p><h3 id="2-2-2-无分类编制CIDR"><a href="#2-2-2-无分类编制CIDR" class="headerlink" title="2.2.2 无分类编制CIDR"></a>2.2.2 无分类编制CIDR</h3><p>于是采用更为灵活的CIDR</p><p>上一个网络号位数是由类别决定的，每一个类别网络号位数是固定的，而CIDR的网络号位数是由掩码决定的，是可变的</p><p>之前的网络号在CIDR里更名为网络前缀</p><p>网络前缀可以通过斜线+数字表示，如&#x2F;20</p><p>比如IP 128.14.32.7&#x2F;20  我们可以知道 网络前缀20位，那么主机号30-20&#x3D;12位！</p><p>人为可以看斜线数字，计算机怎么知道有多少位网络前缀呢？</p><p>通过子网掩码</p><p>如上述IP 128.14.32.7&#x2F;20，有20个并列的1,12个并列的0组成掩码</p><p>其中1的个数代表网络号个数，0的个数代表主机号个数</p><p>我们将IP地址和子网掩码按位与，可以得到网络地址</p><p>有三个比较特殊的地址块</p><p>1 前缀n&#x3D;32，用于主机路由</p><p>2 前缀n&#x3D;31，用于点对点路由</p><p>3 前缀n&#x3D;0，且所有主机号为0，用于默认路由</p><p>这些用途后面讲到</p><p>路由聚合——用较大的CIDR块替代较小的CIDR块，减少查找转发表的时间</p><h3 id="2-2-3-MAC地址和IP地址区别"><a href="#2-2-3-MAC地址和IP地址区别" class="headerlink" title="2.2.3 MAC地址和IP地址区别"></a>2.2.3 MAC地址和IP地址区别</h3><p>MAC地址是物理地址，硬件实现，在数据链路层，MAC帧首部</p><p>IP地址是逻辑地址，软件实现，在网络层，IP数据报首部</p><p>假设从A1，到B1，途径R1，R2两个路由器</p><p>IP数据报都不变，即IP首地址和源地址都是A1,B1</p><p>但MAC帧的首地址尾地址会发生变化，一开始A1，R1，然后R1，R2……</p><p>特殊IP地址</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231010165242389.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231010165242389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="特殊IP地址"></p><p>点分十进制记法</p><p>IP编址可以解决世界各地网络硬件地址差异大，转换工作复杂的问题</p><p>网络地址转换过程</p><p>​离开专用网的时候，替换源地址，将内部地址替换为全球地址</p><p>​进入专用网的时候，替换目的地址，将全球地址替换为内部地址</p><p>现在有一个问题，就是我们已经知道IP了，那么计算机怎么知道对应的MAC地址呢</p><p>这就涉及到地址解析协议ARP</p><h2 id="2-3-地址解析协议ARP"><a href="#2-3-地址解析协议ARP" class="headerlink" title="2.3 地址解析协议ARP"></a>2.3 地址解析协议ARP</h2><p>已经知道了一个机器（主机或路由器）的IP地址，如何找出其响应的硬件地址</p><p>地址解析协议ARP就是用来解决这个问题的</p><p>方法：每一个主机都设有一个ARP高速缓存（ARP cache，作用存放最近获得的IP地址绑定的MAC地址，减少ARP广播数量）这里面存有所在局域网上的各个主机和路由器IP地址到硬件地址的映射表</p><p>&lt;IP address; MAC address; TTL&gt; TTL:地址映射有效时间</p><p>我们可以查看自己的电脑的ARP高速缓存，命令</p><p>arp -a|more</p><h3 id="2-3-1-解析过程"><a href="#2-3-1-解析过程" class="headerlink" title="2.3.1 解析过程"></a>2.3.1 解析过程</h3><p>先在ARP高速缓存中查看有无主机B的IP地址</p><p>​如果有，就可查出对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该硬件地址写入MAC帧，然后通过局域网发往硬件地址</p><p>​如果没有，ARP进程在本局域网上广播发送一个ARP请求分组，收到ARP响应分组后，将得到的IP地址到硬件地址的映射写入ARP高速缓存</p><p>​不在同一个局域网的话，则交给一个路由器</p><p>​解析是自动进行的</p><h2 id="2-4-IP数据报格式"><a href="#2-4-IP数据报格式" class="headerlink" title="2.4 IP数据报格式"></a>2.4 IP数据报格式</h2><p>首部和数据部组成，首部是固定长度，共20字节，是所有IP数据报必须拥有的</p><p>首部的固定部分的后面是一些可选字段，其长度是可以变的</p><p>固定字段的常见内容如下</p><p>版本，首部长度，区分服务，总长度，标识，标志</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111222137020.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111222137020.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="固定字段及其可变部分"></p><p>分组头的长度是可变的</p><p>版本字段表示IP版本，值为4表示IPv4</p><p>协议字段表示上层协议</p><p>生存时间表示 一个分组最多条数</p><h1 id="3-IP层转发分组流程"><a href="#3-IP层转发分组流程" class="headerlink" title="3 IP层转发分组流程"></a>3 IP层转发分组流程</h1><p>显示本机路由表 route print -4</p><p>IP层后转发分组都只找网络前缀了（这样就可以找到目的网络）因为直接如果找到主机号的地步，会需要大量的内容，主机数目实在太大了，查找过程就会非常缓慢……</p><p>所以就找前缀相同，看看是不是本网络如果不是的话则通过端口转发。如果有多个匹配的前缀，那么则选取最长的前缀</p><p>核心算法（默认前缀按长到短排序）</p><p>1 从数据报首部提取目的主机的IP地址D，得出目的网络的地址N</p><p>2 若网络N与此路由器直接相连，则把数据报直接交付目的主机D，否则是间接交付。执行3</p><p>3 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中下一跳的路由器，否则执行4 </p><p>4 若路由表中有目的网络地址N的路由，则把数据报传送给路由表中下一跳的路由器，否则执行4 </p><p>5 若路由表中有一个默认路由，则把数据报传送给路由表中指明的默认路由器，否则执行6</p><p>6 报告转发分组出错</p><p>特殊的路由</p><p>​主机路由和默认路由</p><p>而为了加快查找表的查找过程，又可以使用二叉线索查找转发表</p><p>为了更有效地转发IP数据报并且提高交付机会，使用ICMP协议</p><p>使用ICMP后，就可以运行主机或者路由器报告差错情况和提供有关异常情况的报告</p><h1 id="4-国际控制报文协议ICMP"><a href="#4-国际控制报文协议ICMP" class="headerlink" title="4 国际控制报文协议ICMP"></a>4 国际控制报文协议ICMP</h1><p>提高IP数据报的交付成功机会，允许主机或路由器报告差错情况和提供有关异常情况的报告，但是不是高层协议，ICMP报文是装到IP数据报的数据部分中的</p><p>是IP层协议</p><h2 id="4-1-ICMP格式结构"><a href="#4-1-ICMP格式结构" class="headerlink" title="4.1 ICMP格式结构"></a>4.1 ICMP格式结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231024162522252.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231024162522252.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="IP数据报格式示意图"></p><p>ICMP报文的前四个字节是统一的格式，共有3个字段，即类型、代码、检验和</p><p>ICMP的应用举例</p><p>Ping</p><p>traceroute</p><h2 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h2><h3 id="4-2-1-差错报告报文"><a href="#4-2-1-差错报告报文" class="headerlink" title="4.2.1 差错报告报文"></a>4.2.1 差错报告报文</h3><p>在如下情况发送ICMP报文</p><p>​终点不可达</p><p>​源点抑制</p><p>​时间超过</p><p>​参数问题</p><p>​改变路由（重定向）</p><h3 id="4-2-2-询问报文"><a href="#4-2-2-询问报文" class="headerlink" title="4.2.2 询问报文"></a>4.2.2 询问报文</h3><p>ICMP报文的</p><h2 id="4-3-应用"><a href="#4-3-应用" class="headerlink" title="4.3 应用"></a>4.3 应用</h2><p>用ping命令测两个主机的连通性，其中ping是应用层直接使用网络层ICMP的一个例子</p><p>另一个例子是LInux的traceroute ，Windows下是tracert，可以知道到目的主机所经过路由器的IP地址</p><p>计算题</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）数据链路层</title>
      <link href="/2023/11/18/Computer_system/Net/3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/11/18/Computer_system/Net/3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》</p><p>重点</p><p>理解MAC地址</p><p>理解交换机</p><p>理解VLAN</p><p>理解高速以太网</p><p>数据链路是计算机网络的底层</p><h1 id="1-数据链路基本概念和问题"><a href="#1-数据链路基本概念和问题" class="headerlink" title="1 数据链路基本概念和问题"></a>1 数据链路基本概念和问题</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p><strong>链路</strong>   或者叫物理链路  是一段点到点的物理线段（有线或者无线）中间没有任何其他交换结点</p><p>一条链路只是一条<strong>通路</strong>的组成部分</p><p><strong>数据链路</strong>  或者叫数据链路   在链路的基础上加上控制协议和实现协议的软件和硬件!<br><a href="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001094833719.png"></a></p><p>​现在最常用的是使用适配器（网卡）来实现这些协议的硬件和软件，一般的适配器都包括了数据链路层和物理层的功能</p><p>​数据链路使用的信道主要有以下两种类型</p><ol><li>点对点信道，使用PPP协议</li><li>广播信道，使用CSMA&#x2F;CD协议</li></ol><h2 id="1-2-基本问题"><a href="#1-2-基本问题" class="headerlink" title="1.2 基本问题"></a>1.2 基本问题</h2><p>对于数据链路层而言，以下三个问题很重要</p><h3 id="（1）封装成帧"><a href="#（1）封装成帧" class="headerlink" title="（1）封装成帧"></a>（1）封装成帧</h3><p>我们知道，互联网上传输数据都以分组（即IP数据报）为传输单位进行传输，所以到了底层数据链路层也得保证不混淆不同的IP报</p><p>所以封装成帧就是在网络层的IP数据报上加上首部和尾部，构成帧</p><p>那么首部和尾部有什么作用呢？</p><p>最重要的</p><ul><li>我们首部和尾部的重要作用就是进行帧定界，通俗来讲就是  区分一个帧和另一个帧（核心目的就是为了不让IP数据报混淆）</li><li>首部和尾部包含一些控制信息</li></ul><p>所以综合来看，一个帧包括的内容有，我们要传输的数据，和首部尾部</p><p>那么为了提高传输效率，要尽可能使得传输数据部分长度大于首部尾部的长度，但每一种数据链路协议都规定了数据部分的长度上限——称为最大传输单元MTU</p><p>数据链路层传送的是<strong>帧</strong>  帧是传输数据的单位</p><p><strong>解决方式</strong>  用控制字符进行</p><h3 id="（2）透明传输"><a href="#（2）透明传输" class="headerlink" title="（2）透明传输"></a>（2）透明传输</h3><p>传播的数据部分出现控制字段，如开始和结束</p><p>如果不做处理的话，会导致接收方误以为提前结束，这个数据部分的EOS应该不被接收方看见</p><p>即应该被认为是透明的，所以叫他为透明传输</p><p>实现的方式是怎样的呢？</p><p><strong>解决方式</strong>  通过字节填充解决.数据中出现控制字符的时候，前面加入一个转义字符“ESC” 十六进制编码1B</p><p><strong>可能问题</strong></p><p>就是IP层交付的数据和DL数据链路层实际传输的数据不一样</p><h3 id="（3）差错控制"><a href="#（3）差错控制" class="headerlink" title="（3）差错控制"></a>（3）差错控制</h3><p>在传输过程中不可能一点都不出错，如0变成1,1变成0，这就叫做<strong>比特差错</strong>。对于差错我们的解决方式是</p><p>目前采用较多的是循环冗余检测方法CRC</p><p><strong>发送端</strong></p><p>原始数据M，进行n位冗余码，商定一个除数P（位数n+1），</p><p>1 原始数据M后面加n个零做被除数D</p><p>2 D除以P得到的余数（该余数又叫帧检验序列FCS）加在M后面</p><p><strong>接收端</strong></p><p>得到的信息除以除数P，余数为0，接受，否则丢弃</p><p>注意我们上面讲到的是比特差错，CRC仅能排查比特差错</p><p>实际上除了比特差错，还有其他差错，就是帧丢失，帧重复和帧失序</p><p>其中我们要注意的是仅仅排除比特差错是不够的，实现了无比特差错的传输叫做<strong>无差错传输</strong></p><p>但是只有排除了所有错误，如帧丢失，帧重复和帧失序之后才能叫做<strong>可靠传输</strong>，即发送什么就收到什么</p><p>这些排除错误的方法（帧编号，确认和重传机制）是往往是更高层来实现的</p><h1 id="2-数据链路层协议"><a href="#2-数据链路层协议" class="headerlink" title="2.数据链路层协议"></a>2.数据链路层协议</h1><h2 id="2-1-点对点-PPP协议"><a href="#2-1-点对点-PPP协议" class="headerlink" title="2.1 点对点 PPP协议"></a>2.1 点对点 PPP协议</h2><p>使用最多的是点对点协议PPP</p><p>我们前面反复提到互联网用户如果想要连入互联网，必须连接到某个ISP，其中我们的PPP协议广泛应用于本地计算机和ISP的数据链路层的通信</p><h3 id="2-1-1-需要实现的"><a href="#2-1-1-需要实现的" class="headerlink" title="2.1.1 需要实现的"></a>2.1.1 需要实现的</h3><p>PPP协议需要实现的一些功能</p><p>那么除了我们刚才讲到的 封装成帧，透明传输，差错检测这些基本问题，还实现了简单高效，支持多种网络层协议，支持多种类型链路，检测连接状态，数据压缩算法的协商</p><h3 id="2-1-2-PPP组成"><a href="#2-1-2-PPP组成" class="headerlink" title="2.1.2 PPP组成"></a>2.1.2 PPP组成</h3><p>一个将IP数据报封装到串行链路的方法，是同步还是异步</p><p>一个链路控制协议LCP（建立，配置，和测试数据链路的连接</p><p>一套网络控制协议NCP（支持多种网络层协议）</p><h3 id="2-1-3-帧格式"><a href="#2-1-3-帧格式" class="headerlink" title="2.1.3 帧格式"></a>2.1.3 帧格式</h3><p><strong>开始结束字段</strong>  F&#x3D;0x7E   1字节</p><p><strong>地址字段</strong>   A&#x3D;0xFF   因为是点对点，所以设置就维持不变  1字节</p><p><strong>控制字段</strong>   C&#x3D;0x03   1字节</p><p>开始结束和地址字段，控制字段实际上没有携带什么信息。他是最初设计的时候考虑之后可能会用到，但目前为止也没有用到</p><p><strong>协议字段</strong>  不同值代表不同协议  2字节</p><p>如0x0021时，是IP数据报，若为0xC021 ，则为LCP数据报</p><p><strong>信息字段</strong> 要传输的IP数据报或，链路控制数据，网络控制数据等</p><p><strong>检验字段</strong>  FCS</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001101538660.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001101538660.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>对于<strong>透明传输</strong>问题</p><p>异步传输方法是——<strong>字节填充法</strong></p><p>​当信息字段中出现和标志字段一样的比特（0x7E）组合时，在前面添加转义字符0x7D，同时把0x7E变为0x5E传输。整体变为（0x7D，0x5E）传输</p><p>​当信息字段出现转义符（0x7D）的时候，在前面再添加一个转义字符0x7D，同时把0x7D变为0x5D传输。整体变为（0x7D，0x5D）传输</p><p>​当信息中出现ASCLL控制码时候，也同理</p><p>同步传输方法是——<strong>零比特填充法</strong></p><p>发送端，先扫描整个信息字段（往往硬件实现）只要发现有5个连续的1，则立即填入一个0，因此经过这种比特的填充后，信息字段就不会出现6个1 的情况</p><p>接收端，首先找到标志字段F确定边界，然后用硬件对内部比特流扫描去掉0</p><h3 id="2-1-4-工作流程"><a href="#2-1-4-工作流程" class="headerlink" title="2.1.4 工作流程"></a>2.1.4 工作流程</h3><p>建立工作状态</p><ol><li>用户拨号接入ISP后，建立了一条从用户个人电脑到ISP的物理连接</li><li>用户个人电脑向ISP发送一系列的链路控制协议LCP分组（封装成多个PPP帧），以便建立LCP连接。这些分组及其响应选择了一些将要选择的PPP参数</li><li>进行网络层配置，NCP给新接入的用户分配一个临时IP，正式接入互联网</li></ol><p>通信完毕</p><ol><li>NCP释放网络层连接，收回去分配出去的IP</li><li>LCP释放数据链路层连接</li><li>释放物理层连接</li></ol><h2 id="2-2-广播-CSMA-CD协议"><a href="#2-2-广播-CSMA-CD协议" class="headerlink" title="2.2 广播 CSMA&#x2F;CD协议"></a>2.2 广播 CSMA&#x2F;CD协议</h2><p>接下来重点讨论局域网部分的一对多通信，其中以太网可以看成是一种实现局域网通信的技术标准（目前逐渐大家把它当作局域网的同义词。以太网的拓扑结构有环形的，星形的等等。局域网主要用双绞线，速率更高</p><p>开始之前，先探讨一个问题——我们本地的计算机是怎么连到局域网的？</p><p>其中一个关键部件是适配器（网卡）</p><p>适配器是什么</p><p><strong>适配器</strong></p><p>网络接口板子又称作通信适配器或者网卡</p><p>他的核心作用如下</p><p><strong>适配器的功能</strong></p><p>​进行串行并行转换</p><p>​对数据进行缓存</p><p>​在计算机的操作系统安装设备驱动程序</p><p>​实现以太网协议</p><p>计算机通过适配器和局域网进行通信</p><p>好的，我们已经了解了连接到局域网的关键设备，适配器</p><p>接下来一个重要问题就是，多用户如何共享信道资源，一般两种方式</p><ol><li><p>静态划分信道 FDMA，TDMA，WDMA，CDMA——频分复用，时分复用，码分复用等代价价高，  不适合于这个局域网</p></li><li><p>动态媒体接入控制 ——又称为多点接入，信道并非在用户通信时固定分配给用户，这里又分为两类</p></li></ol><ul><li><p>随机接入CSMA&#x2F;CD：即所有用户可以随机地发送信息，如果恰巧有两个用户在同一时刻发送信息，那么在共享媒体上就要发生碰撞，使得用户的发送都失败。因此，必须有解决碰撞的网络协议</p></li><li><p>受控接入：用户不能随机的发送信息，而必须服从一定的控制，这类的典型代表有分散控制令牌环局域网和集中控制的多点线路探询，或轮询</p></li></ul><p>由于局域网信道质量比较高（距离短），所以设计的时候要尽可能的简单</p><p>为此，局域网采取了如下的措施</p><ol><li><p>以太网提供的是<strong>无连接</strong>（不必先建立连接就可以直接发送数据）的<strong>不可靠</strong>（对发送的数据帧不进行编号，不要求确认）服务，以太网采用CSMA&#x2F;CD协议，意味着载波监听多点接入\碰撞检测</p></li><li><p>以太网的数据采用<strong>曼彻斯特编码</strong></p></li></ol><h3 id="2-2-1-协议要点"><a href="#2-2-1-协议要点" class="headerlink" title="2.2.1 协议要点"></a>2.2.1 协议要点</h3><p>半双工通信</p><p><strong>多点接入</strong>  表示计算机以多点的方式连接在一根总线上</p><p><strong>载波监听</strong>  每一个站点在发送数据前先检测一下总线上有没有其他计算机在发送数据</p><p>载波监听的问题</p><p>监听到空闲的其实并不一定是空闲的哦！所以需要碰撞检测</p><p>以太网端到端往返时延的两倍2t称为争用期或碰撞窗口，如果这段时间还没有检测到碰撞，这次发送就不会碰撞，当发送碰撞后，还会发送强化碰撞，即人为发送干扰信息，保证所有用户都知道已经发生了碰撞</p><p><strong>碰撞检测</strong>  检测到碰撞后立即停止发送，继续发送人为干扰信号（以便让所有用户知道发生了碰撞）等待一段随机时间后发送。</p><p>那么这个随机时间如何计算呢？ <strong>随机时间计算</strong></p><p>1 基本退避时间为争用期2t (以太网取51.2us为争用期)</p><p>2 从整数集合$[0,1,2,…,(2^k-1)]$中随机取出一个数记为r，k&#x3D;min[重传次数，10]</p><p>3 重传时延就是r倍的基本退避时间</p><p>4 如果重传16次依然不能成功时丢弃帧，向高层报告</p><p>由于以太网取51.2us为争用期，对于10Mbit&#x2F;s的网络而言，这期间可以发送512比特（64字节），如果发生冲突一定是在64节内，这会导致检测到冲突停止发送从而数据小于64节所以64字节为<strong>最短有效帧长</strong></p><p>还有<strong>帧间最小间隔</strong>即96帧，方便刚刚收到数据帧的站接收缓存清理，做好接受下一帧的准备</p><p>总结来看</p><p>该协议的要点：</p><p>1 准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部组成以太网帧。放入适配器的缓存中，发送之前检测信道</p><p>2 检测信道：若检测信道忙，则不停检测，一直等待信道转为空闲，且超过96帧后，发送过程中继续监测信道，如果超过争用期后还是未检测到碰撞，就认为发送成功，否则立刻停止发送，然后利用指数退避算法再次发送</p><p>接下来我们探讨一下局域网的信道利用率</p><p><strong>参数a</strong></p><p>$T_0&#x3D;L&#x2F;C$   L是帧长  C是数据发送速率，T0是帧发送时间</p><p>$a&#x3D;t&#x2F;T_0$   参数a等于以太网单端时延与帧的发送时间T_0的比</p><p>a接近0的时候，表示一发生碰撞就会被检测出来，信道利用率很高</p><p>a越大，争用期所占比例增大，发生一次碰撞就浪费许多资源</p><p>当数据率一定时候，以太网的连线长度受到限制，否则t数值就会太大，以太网帧长不能太短，否则会导致T0值太小，a太大</p><p>理想信道利用率</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144501740.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144501740.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="理想信道利用率" style="zoom:33%;" /><p>上面式子告诉我们$a$要远小于1，才能提高这个利用率</p><h2 id="2-3-集线器，交换器"><a href="#2-3-集线器，交换器" class="headerlink" title="2.3 集线器，交换器"></a>2.3 集线器，交换器</h2><p>使用接线器比起刚刚的无源的总线结构更靠谱一些</p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>星形拓扑结构，中心叫集线器，目前使用双绞线或光纤</p><p>一个集线器有许多个端口</p><p>集线器工作在物理层，仅仅简单地做转发，不进行碰撞检测</p><p>前面我们讲到适配器，那么局域网的各个电脑如何区分要发送的目的地呢</p><p>就是通过适配器的MAC地址，他是固化在适配的ROM中，全球唯一</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址又叫做硬件地址，物理地址</p><p>通常表示为48位， 6字节</p><p>表示的时候用12个16进制数，每2个16进制数之间用冒号隔开，如08：00：20：0A：8C：6D</p><p>地址段前三个字节由IEEE的注册管理机构RA向厂家分配，后三个字节由厂家自行分配</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144759678.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001144759678.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MAC地址格式"></p><p>IEEE规定地址字段的第一字节的最低位为I&#x2F;G位</p><p>I&#x2F;G&#x3D;0时候，地址字段表示一个单站地址</p><p>I&#x2F;G&#x3D;1时候，地址字段表示一个组地址，用来广播</p><p>当48位都为1时候，为广播地址，只能作为目的地址</p><p>IEEE规定地址字段的第一字节的最低第二位为G&#x2F;L位</p><p>G&#x2F;L位&#x3D;0时候，是全球管理</p><p>IG&#x2F;L位&#x3D;1时候，是本地管理</p><p>当48位都为1时候，为广播地址，只能作为目的地址</p><h3 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h3><p>常用以太网V2格式</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001145624341.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231001145624341.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MAC帧"></p><p><strong>源地址目标地址</strong> 上面讲到的MAC地址</p><p><strong>类型</strong> 上一层使用的什么协议</p><p><strong>数据字段</strong></p><p>​最小长度&#x3D;64-18字节的头尾&#x3D;46</p><p>​最长1500</p><p>检测字段<strong>FCS</strong></p><p><strong>前同步码</strong>  8个字节，前7个实现MAC帧同步，第8个帧开始定界符</p><p><strong>帧间最小间隔</strong>  9.6us</p><p><strong>总结：</strong></p><p>互联网&#x3D;通过<a href="https://www.zhihu.com/search?q=%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2565012876%7D">路由协议</a>联通的N个局域网。</p><p>局域网&#x3D;以太网+TCP&#x2F;IP协议。</p><p>以太网&#x3D;基于广播(MAC寻址)和碰撞检测机制 CSMA&#x2F;CD 的网络。</p><p>（  以太网是一种计算机局域网技术</p><h1 id="3-扩展以太网"><a href="#3-扩展以太网" class="headerlink" title="3 扩展以太网"></a>3 扩展以太网</h1><p>我们知道，以太网的两台主机距离不能太远，但是往往比如校园内，一些主机的距离可能蛮远的</p><p>要实现这样距离较远的通信，我们就需要扩展以太网</p><p>所以我们要搞清楚拓展的核心目的</p><p>那么拓展主要有两种方式，物理层上扩展，和数据链路层扩展</p><h2 id="3-1-物理层扩展方式"><a href="#3-1-物理层扩展方式" class="headerlink" title="3.1 物理层扩展方式"></a>3.1 物理层扩展方式</h2><ol><li><p>很早之前拓展是通过接转发器</p></li><li><p>而现在拓展的简单方法就是使用光纤，用到光纤调制解调器，能够到达几公里的范围</p></li><li><p>还有一种方式就是多个集线器，连接成覆盖更大范围的多级星型结构</p><p>比如一个学校有三个学院，每个学院配备一个集线器，最后再通过一个主干集线器连接在一起</p><p>多级集线器的优点是，可以跨院通信，同时扩大了范围，缺点是碰撞域变大了（三个独立的碰撞域合成了一个），同时没有缓存功能，不同学院必须使用相同的以太网技术</p></li></ol><p>​比如10Mb&#x2F;s的以太网，则十个用户端口，则每个用户端口变为1Mb&#x2F;s</p><p>​通过集线器连接，构成一个广播域，也是一个冲突域</p><h2 id="3-2-数据链路层扩展方式"><a href="#3-2-数据链路层扩展方式" class="headerlink" title="3.2 数据链路层扩展方式"></a>3.2 数据链路层扩展方式</h2><p>扩展方式主要通过交换机，交换机工作在数据链路层</p><p>特点 </p><ol><li>交换机实质是一个多端口的网桥，通常有十几个或者更多个端口，全双工工作方式</li><li>具有存储器，能够进行帧缓存</li><li>即插即用，避免人为配置，通过内部帧交换表实现，要了解交换机更新交换表的自学算法</li><li>用户独占信道，增大了交换机总容量</li><li>有多种速率端口</li></ol><p>比如10Mb&#x2F;s的以太网，则十个用户端口，则每个用户端口变为10Mb&#x2F;s</p><p>通过交换机连接，构成一个广播域，但不是一个冲突域</p><p>交换方式有</p><p>​存储转发方式</p><p>​先把整个数据帧先缓存再进行处理</p><p>​直通方式</p><p>​接收数据帧的同时就按照目的地址决定转发接，缺点是不查错</p><h3 id="3-2-1-交换机的自学功能"><a href="#3-2-1-交换机的自学功能" class="headerlink" title="3.2.1 交换机的自学功能"></a>3.2.1 交换机的自学功能</h3><p>交换表组成： MAC地址，端口，写入时间</p><p>如果交换表内没有自己要发送的对方的地址，则进行广播通知每一个主机，其他主机收到后看看是否是要发送给自己，不是的话则过滤掉，是的话则接收，同时将对应的信息加入交换表。如果有的话则直接一对一发送</p><h2 id="3-3-虚拟局域网"><a href="#3-3-虚拟局域网" class="headerlink" title="3.3 虚拟局域网"></a>3.3 虚拟局域网</h2><p>当前面的扩展方式进行很多的扩展的时候，就会遇到一些问题</p><p>首先一整个以太网是一个广播域，那么以太网上经常就会出现大量广播帧，浪费资源</p><p>其次，不利于信息的安全</p><p>所以提出虚拟局域网，核心思想是把一个较大的局域网分割为很多较小的局域网，每一个局域网是一个广播域</p><p>实现方式是在MAC帧的基础上嵌入了VLAN标签，一个虚拟局域网可以跨越多个交换机</p><h1 id="4-高速以太网"><a href="#4-高速以太网" class="headerlink" title="4 高速以太网"></a>4 高速以太网</h1><h2 id="4-1-100BASE-T"><a href="#4-1-100BASE-T" class="headerlink" title="4.1 100BASE-T"></a>4.1 100BASE-T</h2><p>是在双绞线上传输100Mbit&#x2F;s的系带信号的星形拓扑结构，比之前的100Mbit&#x2F;s快了很多</p><h2 id="4-2-吉比特以太网"><a href="#4-2-吉比特以太网" class="headerlink" title="4.2 吉比特以太网"></a>4.2 吉比特以太网</h2><p>即传输速率是1Gbit&#x2F;s</p><p>之前我们讲到大多通过电话线等方式接入互联网</p><p>但实际现在更多的是通过以太网进行宽带接入，比如我们现在只要登录校园网就可以访问外网了</p><p><strong>拓展</strong></p><p>了解一下网速单位</p><p>Mbps是Mb&#x2F;s 而不是MB&#x2F;S”。</p><p>运营商说的1M宽带的M是指Mb&#x2F;s，也就是Mbps，运营商为什么喜欢说这个呢？数据传输大多是以“位”（bit，又名“比特”）为单位的，数据的传输以及运营商在流量收费的时候都是按照比特来计算的</p><p>所以比如运营商说1M带宽，那么也就意味着是1Mb&#x2F;s，也就是0.125MB&#x2F;s</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231210103345528.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231210103345528.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="速率示意图"></p><p>我自己实际测试了网速</p><p>如图是300M-500M带宽</p><p>那么也就意味着是37.5MB&#x2F;s到62.5MB&#x2F;s</p><p> 路由器：（Router）是连接因特网中各局域网、广域网的设备。在路由器中记录着路由表，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。发生在网络层。<br>  交换机：（Switch）是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路，把传输的信息送到符合要求的相应路由上。发生在数据链路层。<br>  集线器：（Hub）是指将多条以太网双绞线或光纤集合连接在同一段物理介质下的设备。发生在物理层。</p><h4 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h4><table><thead><tr><th></th><th>路由器</th><th>交换机</th></tr></thead><tbody><tr><td>工作层次</td><td>网络层</td><td>数据链路层</td></tr><tr><td>转发依据</td><td>IP地址</td><td>Mac地址</td></tr><tr><td>功能</td><td>连接不同的网络</td><td>连接局域网中的电脑</td></tr><tr><td>宽带影响</td><td>共享宽带</td><td>独享宽带</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）物理层下</title>
      <link href="/2023/11/17/Computer_system/Net/2-1%20%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B/"/>
      <url>/2023/11/17/Computer_system/Net/2-1%20%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="3-物理层下面的传输媒介"><a href="#3-物理层下面的传输媒介" class="headerlink" title="3. 物理层下面的传输媒介"></a>3. 物理层下面的传输媒介</h1><p>传输媒介是发送器和接收器之间的物理通路</p><p>可以分为引导型传输媒介，非导引型传输媒介</p><h2 id="3-1-导引型传输媒介"><a href="#3-1-导引型传输媒介" class="headerlink" title="3.1 导引型传输媒介"></a>3.1 导引型传输媒介</h2><p>啥叫引导型</p><p>就是电磁波被引导着在固体传播</p><p>可以理解为我们常常称作的有线传输</p><p>常见的有</p><p><strong>1 双绞线</strong></p><p>将铜导线相互绞合，减少电磁干扰</p><p>又可以分为</p><ul><li><p>屏蔽双绞线</p></li><li><p>无屏蔽双绞线</p></li></ul><p>之前常常用作电话线，目前也用于一些计算机网络数据传输</p><p>计算机网络中常用的是5类双绞线，模拟电话中常用的是3类双绞线</p><p>5类双绞线的接头是RJ-45，它是4对8芯</p><p>3类双绞线的接头是RJ-11，它是2对4芯</p><p><strong>2 同轴电缆</strong></p><p>由最内层铜导体+绝缘层+屏蔽层组成</p><p>他的减少电磁干扰方式和双绞线不同是通过外层保护实现的</p><p>局域网初期使用，目前都用双绞线替代了，有看到的是有限电视网居民小区中</p><p><strong>3 光缆</strong></p><p>内部由光纤组成</p><p>由于光频率非常高，所以带宽很高，传播速率也块</p><p>​不同入射角 不同的模式，</p><p>​多模光纤  多条光线，多个入射角</p><p>​单模光纤  单条光线，只有一个入射角</p><p>单模光纤比多模光纤带宽高，速率也高</p><p>目前光纤越来越便宜，用到的也越来越多</p><h2 id="3-2-非导引型传输媒介"><a href="#3-2-非导引型传输媒介" class="headerlink" title="3.2 非导引型传输媒介"></a>3.2 非导引型传输媒介</h2><p>可以理解为无线</p><p>1 <strong>无线电微波通信</strong></p><p>​频率范围300MHz到300GHz</p><p>​直线传播，所以传播距离有限，一般只有50Km，如果使用100m高的天线塔，则传播距离可以增大到100km</p><p>​应用比较广，实际中，往往需要微波接力，即涉及多个中继站，一点一点将信号传输过去</p><p>2 <strong>短波通信</strong> </p><p>​主要靠电离层的反射，但电离层反射不稳定，以及多径效应，使得短波通信质量较差</p><p>3 <strong>卫星通信</strong></p><p>​卫星通信频带宽，容量大，但是传播时延较大</p><p>无线局域网使用的ISM频段</p><h1 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4 信道复用技术"></a>4 信道复用技术</h1><p>我们可以想象，如果信道只能一人占有，那么我们每个人通信前都需要建立一个独有信道，该多么麻烦，可能建立起来黄花菜也凉了，所以信道服用技术非常关键</p><p><strong>信道复用</strong></p><p>用于将多个信号或数据流合并到一个共享传输介质上，以便通过同一通信通道传输它们。复用技术允许多个信号共享有限的通信资源，从而提高了通信系统的效率和资源利用率</p><p>复用方式有以下三种</p><ol><li><p><strong>频分复用（Frequency Division Multiplexing，FDM）</strong>：</p><ul><li>原理：在FDM中，不同信号或数据流通过在不同的频率带宽范围内传输来进行复用。</li><li>实现方式：每个信号分配一个特定的频率范围，因此它们可以在同一传输介质上并行传输。</li><li>应用：电视广播和有线电视系统是FDM的常见示例，其中不同频道在不同频率上传输。</li></ul><p>对于光而言，实际上叫做波分复用WDM</p><p>有稀疏波分复用和密集波分复用</p><p>​稀疏波分复用CWDM：信道间隔为20nm（16个波长）</p><p>​密集波分复用DWDM：信道间隔为0.2nm到1.2nm</p></li><li><p><strong>时分复用（Time Division Multiplexing，TDM）</strong>：</p><ul><li>原理：TDM将不同信号或数据流分配到不同的时间段上进行复用。</li><li>实现方式：在每个时间段内，只有一个信号进行传输。</li><li>应用：音频电话网络中的TDM是一个典型的应用，其中每个电话通话被分配到独立的时间槽。</li></ul><p>以上两种方式，比较成熟应用较多</p><p>我们发现，如果对于频分复用而言，越多用户，每个用户分到的带宽就越少，而对于时分复用，越多用户不会影响他的带宽</p></li><li><p><strong>码分复用（Code Division Multiplexing，CDM或者CDMA）</strong>：</p><ul><li>原理：CDM使用不同的编码序列对信号进行复用，使它们能够在同一时间和频率上传输。</li><li>实现方式：每一个接收方被指派一个m个bit的序列，根据正交等运算实现，比较抽象，看下面的例子</li><li>应用：CDMA（Code Division Multiple Access）手机通信就是一个使用CDM的例子。</li></ul><p>例：</p><p>假设S站向T站发送信号</p><p>S站的分配到的序列（0，0,0,1，1,0,1,1）》转换为 （-1，-1，-1,1，，1，-1,1,1）</p><p>T站如何知道S站是否有发送信息给自己</p><p>可以将收到的总信号（是很多发送方的叠加）点乘S站的序列号除以8即可以得到</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930194457636.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930194457636.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算举例" style="zoom:50%;" /></li></ol><h1 id="5-数字传输系统"><a href="#5-数字传输系统" class="headerlink" title="5 数字传输系统"></a>5 数字传输系统</h1><h2 id="5-1-旧的数字系统"><a href="#5-1-旧的数字系统" class="headerlink" title="5.1 旧的数字系统"></a>5.1 旧的数字系统</h2><p>最早  频分复用FDM</p><p>较早前  时分复用PCM ，PDH（异步时分复用）准同步数字序列</p><p><strong>缺点</strong></p><p>​速率不统一，不是同步传输</p><p>中国&#x2F;欧洲的基群速率是E1，大约2Mbps</p><p>日本&#x2F;北美的基群速率是T1,大约是1.5Mbps</p><h2 id="5-2-新数字系统"><a href="#5-2-新数字系统" class="headerlink" title="5.2 新数字系统"></a>5.2 新数字系统</h2><p>​基于光缆的同步数字序列SDH（同步时分复用），和WDM，波分复用</p><h1 id="6-带宽接入技术"><a href="#6-带宽接入技术" class="headerlink" title="6 带宽接入技术"></a>6 带宽接入技术</h1><p>用户要连接到互联网，必须先连接到某个ISP（互联网服务提供商），以便获得上网所需要的IP</p><p>最开始的时候，通过使用电话的用户线通过调制解调连接到ISP的，为了提高上网速率，提出了多种带宽接入技术</p><p>大体分为两类，无线接入和有线接入</p><p>这里重点讲有线接入</p><h2 id="6-1-DSL（数字用户线）"><a href="#6-1-DSL（数字用户线）" class="headerlink" title="6.1 DSL（数字用户线）"></a>6.1 DSL（数字用户线）</h2><p>有线宽带接入技术</p><p>DSL利用标准的电话线路来传输数字数据，同时允许用户在不影响电话通信的情况下同时使用互联网</p><p><strong>分为多种类型</strong>：DSL有多个变种，包括以下几种：</p><ul><li><p><strong>ADSL（Asymmetric DSL）</strong>：ADSL提供不对称的上行和下行速度（上行指用户到ISP，下行指ISP到用户，下行更快），通常下载速度较快，适用于普通家庭用户。ADSL的传输距离取决于数据率和用户线路径</p><p>对于ADSL的调制解调，我国采用离散多音调<strong>DMT技术</strong></p><p>​<strong>DMT技术</strong></p><p>频分复用，上行信道少，下行信道多</p><p>最高传输速率取决于信噪比，传输距离</p><p>对于ADSL接入</p><p>关键设备是ADSL猫</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930195644009.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930195644009.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ADSL猫示意图"></p></li><li><p><strong>SDSL（Symmetric DSL）</strong>：SDSL提供对称的上行和下行速度，适用于需要对等上传和下载速度的业务用户，如一些企业</p></li><li><p><strong>VDSL（Very High Bitrate DSL）</strong>：VDSL提供更高的传输速度，适用于需要更高带宽的用途，如高清视频流和在线游戏。</p> <img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111215307056.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111215307056.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题" style="zoom:33%;" /></li></ul><h2 id="6-2HFC-光纤同轴混合网"><a href="#6-2HFC-光纤同轴混合网" class="headerlink" title="6.2HFC  光纤同轴混合网"></a>6.2HFC  光纤同轴混合网</h2><p>HFC是在有线电视网基础上开发的一种居民接入技术</p><p>它结合了光纤和同轴电缆两种不同的传输媒介。</p><p>频分复用，双向传输</p><h3 id="6-2-1-接入"><a href="#6-2-1-接入" class="headerlink" title="6.2.1 接入"></a>6.2.1 接入</h3><p>每个家庭要安装一个用户接口盒UIB</p><p>UIB提供三种连接，分别用于不同的应用场合</p><p>1 同轴电缆连接到机顶盒（因为要使得模拟电视机接收数字信号，所以用机顶盒），然后再连接到用户电视机</p><p>2 使用双绞线连接到用户的电话机</p><p>3 使用电缆调制解调器（一般在机顶盒内部集成）连接到用户的计算机</p><h2 id="6-3-FTTx技术"><a href="#6-3-FTTx技术" class="headerlink" title="6.3 FTTx技术"></a>6.3 FTTx技术</h2><p>FTTx是一种广泛用于提供高速互联网连接的技术，它利用光纤到户</p><p> “x” 代表不同的变种，包括FTTH（光纤到家）、FTTC（光纤到路边）和FTTB（光纤到大楼）。</p><p>对于普通居民而言，就是FTTH啦</p><p>FTTH是一种光纤接入技术，其中光纤被延伸到用户家庭的终端。这意味着数据通过光纤传输到用户家庭内部，提供了高速、稳定的互联网连接。FTTH通常提供对称的上行和下行速度，适用于需要大带宽的应用，如高清视频流、在线游戏和远程工作。</p><p>而我们知道，一个用户无法用完一条光纤的资源，所以设置了光配线网（ODN）目前常常使用的是下图的无源光配线网络PON，使得数十个家庭用户能够共享一个干线</p><p>其中注意一点，无源是指PON不用电源</p><p><strong>无源光网络PON</strong></p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201109120.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201109120.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="无源光网络PON"></p><p>观察上图可知 </p><p><strong>PON组成</strong></p><p>1 局端   中心控制站</p><p>2 用户端   光网络单元ONU（又叫做光猫）</p><p>3 光配线网</p><p>而AON是有源，维护难度大</p><p><strong>PON接入</strong></p><p>光猫</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201735085.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201735085.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="光猫"></p><p><strong>家庭主流接入方式</strong></p><p>可以看到从ONU出来后</p><p>有线部分可以接计算机</p><p>无线部分可以连手机WIFI之类的</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201851760.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230930201851760.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="家庭主流接入方式"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）物理层上</title>
      <link href="/2023/11/16/Computer_system/Net/2%20%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2023/11/16/Computer_system/Net/2%20%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》 </p><p>物理层重点</p><p>1 复用的概念</p><p>2 宽带接入技术，家庭和公司如何接入Internet？PON接入，画接入Internet的拓扑图</p><h1 id="1-物理层基本概念"><a href="#1-物理层基本概念" class="headerlink" title="1 物理层基本概念"></a>1 物理层基本概念</h1><p>物理层考虑的是怎样在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。怎么理解呢？因为我们的物理传输媒介千差万别，有可能通过光缆，有可能无线空气传输等等，那么物理层就要想办法消除这些差别，让物理层之上的数据链路层不必考虑具体的传输媒介，只需要关注本层的一些协议就好</p><p>用于物理层的协议也叫作物理层的<strong>规程</strong></p><p>可以将物理层的任务描述为确定与传输媒体的接口有关的一些特性，即</p><p><strong>机械特性</strong>  指明接口所用的接线器的形状和尺寸，引线数目和排列</p><p><strong>电气特性</strong>  指明在接口电缆的各条线上出现的电压范围</p><p><strong>功能特性</strong>  指明某一电平的电压表示何种意义</p><p><strong>过程特性</strong>  指明对于不同功能的各种事件出现顺序</p><p>学习之前，需要先了解一些通信的基础知识</p><h1 id="2-数据通信基础知识"><a href="#2-数据通信基础知识" class="headerlink" title="2.数据通信基础知识"></a>2.数据通信基础知识</h1><h2 id="2-1-数据通信基本概念"><a href="#2-1-数据通信基本概念" class="headerlink" title="2.1 数据通信基本概念"></a>2.1 数据通信基本概念</h2><p>我们通信的目的是<strong>传递消息</strong>，比如我打电话想告诉妈妈今天晚上想吃油闷大虾。</p><p>将这个消息使用特定方式表示之后，就可以得到<strong>数据</strong>，数据是运送这个消息的实体，</p><p>而信号是<strong>数据</strong>的电气和电磁的表现，同一个数据，用不同的方式传递，有不同的电气电磁表现。</p><p>那么数据又分为</p><p><strong>模拟的</strong> 代表信息的参数取值是连续的</p><p><strong>数字的</strong> 代表信息的参数取值是离散的</p><p>​<strong>码元：</strong> 时域的波形表示数字信号时，代表不同离散数值的基本波形</p><h2 id="2-2-信道基本概念"><a href="#2-2-信道基本概念" class="headerlink" title="2.2 信道基本概念"></a>2.2 信道基本概念</h2><p>了解 </p><p><strong>单工</strong>  单向通信，只能有一个方向交互，如广播电视，只能它向我们发送</p><p><strong>半双工</strong> 双向交替通信 ，如对讲机，只能一次一个人讲话</p><p><strong>全双工</strong> 双向通信，如打电话</p><p><strong>基带信号</strong></p><p>​即基本频带信号，来自数据发送方的信号，像计算机输出的各种文字或者图像文件的数据信号都属于基带信号</p><p>可以分为：</p><p>​模拟基带信号：如人说话产生的声波</p><p>​数字基带信号：如计算机产生数据的方波</p><p>而这种基带信号往往含有很多的直流或者低频成分，许多信道都不支持，在信道中直流和丰富低频成分的基带信号衰减的比较厉害，特别是直流不是被电容隔离就是被电感旁路，所以需要进行<strong>调制</strong>（通过变化去除这些成分）</p><p>调制有两种方式</p><p>方式一 <strong>基带调制</strong> 又称编码，对输入信号的波形进行变换， 输入为数字基带信号，仍为数字基带信号，如曼彻斯特编码</p><p>方式二 <strong>带通调制</strong> 使用载波调制，把基带信号频率范围搬移到较高的频段，并转换为模拟信号，如调幅调制</p><p>首先介绍方式一</p><h3 id="2-2-1-基带调制（编码）方式"><a href="#2-2-1-基带调制（编码）方式" class="headerlink" title="2.2.1 基带调制（编码）方式"></a>2.2.1 基带调制（编码）方式</h3><p>1 不归零制</p><p>2 归零制</p><p>3 曼彻斯特编码 ，方便同步比特个数</p><p>​数据位的中心点用来判断信号的取值。如果信号从低电平到高电平（或相反）变化，表示数据位为0；如果信号从高电平到低电平（或相反）变化，表示数据位为1。</p><p>4 差分曼彻斯特编码</p><p>​差分曼彻斯特编码的关键是信号的变化方式。在一个周期内，如果信号发生了变化，表示数据位为1；如果信号没有变化，表示数据位为0。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212007504.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212007504.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="不同编码方式"></p><p>再介绍方式二</p><h3 id="2-2-2-带通调制方式"><a href="#2-2-2-带通调制方式" class="headerlink" title="2.2.2 带通调制方式"></a>2.2.2 带通调制方式</h3><p>调制 对基带信号的几种调制方式</p><p>1 调相</p><p>2 调幅</p><p>3 调频</p><p>4 正交振幅调制</p><h2 id="2-3-信道的极限速率影响因素"><a href="#2-3-信道的极限速率影响因素" class="headerlink" title="2.3 信道的极限速率影响因素"></a>2.3 信道的极限速率影响因素</h2><p>那么我们通信核心一个议题就是想要传输的更快</p><p>但是研究表明，传输速率受到两个因素影响</p><h3 id="2-3-1-频率范围"><a href="#2-3-1-频率范围" class="headerlink" title="2.3.1 频率范围"></a>2.3.1 <strong>频率范围</strong></h3><p>当速度增大时候，码元之间的界限就会模糊，导致最后相互干扰，出现“码间串扰现象”，接收方就无法分辨，为了避免码间串扰，香农给出奈式准则，在无噪声的情况下，最高码原传递速率等于两倍的带宽（带宽反应频率范围）</p><p>知道带宽的情况下，就可以知道最大传输速率了，比如带宽W&#x3D;4000Hz，那么最大码元传输速率8000码元&#x2F;秒</p><p>即公式为 $最大码元传输速率&#x3D;2W （码元&#x2F;s）$</p><p>这里有一个问题，就是一个码元是多少bit，如果码元有4种，则需要两bit，如果是8种，则需要3bit，如果是16种则4bit，所以一个码元的bit数取决于码元的种类，等于$log_2V$</p><p>则理想状态下的极限传输速率为</p><p>$2Wlog_2V(bit &#x2F;s)$</p><p>注意这里的最大码元速率，和最大传输速率的区别！！！单位也不同，含义也不同</p><p>例题</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212346615.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111212346615.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题1" style="zoom:33%;" />但实际传输过程中，不能没有噪声，而噪声也对传输速率有影响，因而引入一个关键定义信噪比，也是影响速率的第二个因素<h3 id="2-3-2-信噪比"><a href="#2-3-2-信噪比" class="headerlink" title="2.3.2 信噪比"></a>2.3.2 <strong>信噪比</strong></h3><p>信噪比就是信号的平均功率和噪声的平均功率之比，常常记作S&#x2F;N，以分贝为单位</p><p>$信噪比&#x3D;10log_{10}(S&#x2F;N) （dB）$</p><p>当S&#x2F;N&#x3D;10的时候，信噪比为10dB，当S&#x2F;N&#x3D;1000时，信噪比为30dB</p><p>基于信噪比，香农提出了香农公式</p><p>噪声情况下，$极限信息传输速率C&#x3D;Wlog_2(1+S&#x2F;N) (bit&#x2F;s)$</p><p>W还是带宽</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111213107071.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20240111213107071.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="例题2" style="zoom:33%;" />注意这里需要注意一下哈，列不等式]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）概述</title>
      <link href="/2023/11/15/Computer_system/Net/1%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/15/Computer_system/Net/1%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>内容笔记来源于谢希任老师《计算机网络》</p><p>计算机网络可以说是现代生活最重要的一部分了</p><p>互联网（或因特网）之所以能够向用户提供服务，是因为互联网具有两个重要基本特点 连通性 和 共享</p><p>网络把许多计算机连在一起</p><p>互联网则把许多网络通过路由器连在一起</p><p>与网络相连的计算机叫做主机</p><p>互联网发展的三个阶段</p><p>1 单个网络ARPANET向互联网发展</p><p>2 建成三级结构因特网 主干网 地区网 校园网</p><p>3 出现多层次ISP 因特网服务提供者</p><h1 id="1-互联网组成"><a href="#1-互联网组成" class="headerlink" title="1. 互联网组成"></a>1. 互联网组成</h1><h2 id="1-1-四元素组成"><a href="#1-1-四元素组成" class="headerlink" title="1.1 四元素组成"></a>1.1 四元素组成</h2><p>用户设备</p><p>网络设备</p><p>传输介质</p><p>网络协议</p><h2 id="1-2-二元素组成"><a href="#1-2-二元素组成" class="headerlink" title="1.2 二元素组成"></a>1.2 二元素组成</h2><p><strong>边缘部分</strong></p><p>​所有连接在因特网的主机组成，用来进行数据资源共享，也称资源子网</p><p>​这部分直接用户使用的，</p><p><strong>核心部分</strong></p><p>​由大量网络和连接这些网络的路由器组成，提供了连通性和交换，也称为通信子网，为边缘部分提供服务</p><h3 id="1-2-1-边缘部分"><a href="#1-2-1-边缘部分" class="headerlink" title="1.2.1 边缘部分"></a>1.2.1 边缘部分</h3><p>如个人电脑，乃至一个很小的网络摄像头等</p><p>边缘部分利用核心部分所提供的服务</p><p>在网络边缘部分的端系统通信往往可以分为两种</p><p>1 客户服务器方式</p><p>​最为常见，比如我们在网络上搜索资料，或者收发邮件都是这样的</p><p>​主要特征是 客户是服务的请求方，服务器是服务的提供方</p><p>2 对等方式P2P</p><p>​对等连接方式可以支持大量对等用户工作，如QQ微信</p><h3 id="1-2-2-核心部分"><a href="#1-2-2-核心部分" class="headerlink" title="1.2.2  核心部分"></a>1.2.2  核心部分</h3><p>核心部分起特殊作用的是路由器</p><p>路由器实现的<strong>分组交换</strong></p><p>之前用电路交换，现在更多用分组交换</p><p>为什么要用分组交换</p><p>​计算机数据突发性强，使用分组交换承载计算机数据成本低</p><p><strong>区分分组交换和电路交换</strong></p><p>分组交换和电路交换都是计算机网络中常见的数据传输方式，但它们的实现方式和特点有所不同。</p><p>分组交换是一种将数据分成小块（即分组）进行传输的方式。在分组交换中，发送方将数据分成若干个大小相等的数据块，每个数据块被赋予一个地址，并通过网络独立传输。数据到达接收方后，接收方将数据块重新组装成原始数据。分组交换的优点是能够动态地分配网络带宽，提高网络利用率。常见的分组交换协议包括IP协议、TCP协议等。</p><p>电路交换是一种在通信开始前建立网络电路（即物理路径）的方式，并在通信过程中保持该电路。在电路交换中，发送方和接收方之间建立一个可靠的物理连接，并在通信过程中独占该连接。电路交换的优点是通信过程中具有稳定的带宽和延迟，适用于需要实时传输的应用，例如电话通信。常见的电路交换协议包括PSTN、ISDN等。</p><p>可以通过这样一个<strong>比喻来理解</strong></p><p>假设你要从一个城市到另一个城市旅行。如果你选择搭乘公共汽车，那么你需要在汽车站等待，直到一辆符合你行程的公共汽车出现，然后支付车费、上车，到达目的地后下车，这个过程就是电路交换的过程。</p><p>而如果你选择自驾游，那么你可以根据自己的行程和时间，制定出一张路线图，根据路线上的标志和地图，沿途行驶，在需要休息或加油时停车，到达目的地后停车。这个过程就是分组交换的过程。</p><p>可以看到，分组交换和电路交换的区别在于，电路交换是一种预先占用资源的方式，需要建立一个独占的物理连接（买票后别人就不能占用你的位置），而分组交换则是一种动态分配资源的方式（自己的车离开后别人就可以使用），可以根据需要在网络中分配资源。</p><p>这就涉及到一个问题</p><p><strong>分组如何实现？</strong></p><p>（1）发送端，把较长的报文划分成较短的，固定长度的数据段</p><p>（2）每一个数据段前添上首部，每一个数据段可以看做一个分组</p><p>首部含有的信息有地址（转发到下一个结点的交换机）</p><p>（3）以“分组”为数据单元传输，依次把分组传到接收端</p><p>（4）接收端收到分组后就剥去首部 还原成报文</p><p><strong>分组交换优点</strong></p><p>高效 灵活 迅速 可靠</p><p><strong>可能带来的问题</strong></p><p>可能需要排队，产生时延</p><p>首部的控制信息有开销</p><h1 id="2-计算机网路的功能"><a href="#2-计算机网路的功能" class="headerlink" title="2.计算机网路的功能"></a>2.计算机网路的功能</h1><p><strong>数据通信</strong></p><p>而最基本的功能是数据通信</p><p><strong>资源共享</strong></p><p>计算机网络的资源主要指</p><p>​计算机硬件、软件与数据</p><h1 id="3-计算机网络类别"><a href="#3-计算机网络类别" class="headerlink" title="3. 计算机网络类别"></a>3. 计算机网络类别</h1><h2 id="3-1-按照网络作用范围进行分类"><a href="#3-1-按照网络作用范围进行分类" class="headerlink" title="3.1 按照网络作用范围进行分类"></a>3.1 按照网络作用范围进行分类</h2><p>广域网WAN</p><p>​作用范围通常几十公里到几千公里</p><p>城域网MAN</p><p>​作用距离5-50公里</p><p>局域网LAN</p><p>​作用距离 1公里左右</p><p>个人区域网PAN</p><p>​10米左右</p><p>无线个域网</p><p>​如蓝牙，ZIGBee</p><h2 id="3-2-按照网络的使用者进行分类"><a href="#3-2-按照网络的使用者进行分类" class="headerlink" title="3.2 按照网络的使用者进行分类"></a>3.2 按照网络的使用者进行分类</h2><p>（1）公用网</p><p>指电信公司出资建造的大型网络，缴费的人即可使用</p><p>（2）专用网</p><p>某个部分为满足本单位的特殊业务工作的需要而建造的网络</p><h1 id="4-计算机网络性能指标"><a href="#4-计算机网络性能指标" class="headerlink" title="4 计算机网络性能指标"></a>4 计算机网络性能指标</h1><p><strong>1 速率</strong></p><p>指单位时间内传输的数据量，通常以(b&#x2F;s)bps、Kbps、Mbps等单位来表示。传输速率与带宽密切相关，但不同于带宽，它还考虑了传输数据的效率、误码率等因素。bps  Bit Per Second的缩写</p><p>以高清视频为例，它需要的传输速率大概在5-10 Mbps之间。因此，如果你的网络带宽是10 Mbps，就足以支持高清视频的流畅播放。如果网络带宽只有1 Mbps，则观看高清视频时可能会出现卡顿、缓冲等问题。</p><p><strong>2 带宽</strong></p><p>指网络中能够传输的最大数据量，通常以每秒传输的比特数（bps）来衡量。带宽越高，网络传输速度越快，数据传输能力越强。</p><p><strong>速率和带宽的区别</strong></p><p>速率指单位时间内传输的数据量，通常以bps、Kbps、Mbps等单位来表示。速率与数据传输的效率、误码率等因素有关。</p><p>带宽指网络中能够传输的最大数据量，通常也以bps、Kbps、Mbps等单位来表示。带宽是网络的物理特性，与网络的传输效率、误码率等因素无关。</p><p>可以通过一个比喻来理解速率和带宽的区别。假设你要从一桶水中抽取一定量的水，速率就表示你每秒钟能够抽取的水的数量，而带宽则是指这个水桶的容量大小。</p><p>网络界单位换算是1000</p><p>而存储界 单位换算是$2^{10}$</p><p><strong>3 吞吐量</strong></p><p>指单位时间内通过网络的数据量，通常以bps、Kbps、Mbps等单位来表示。吞吐量与传输速率类似，但还考虑了网络中拥塞的情况。</p><p><strong>4 时延</strong></p><p>指数据从发送方到接收方所需的总时间。时延包括</p><p>发送时延 数据从结点进入到传输媒体所需要的时间</p><p>​$发送时延&#x3D;\frac{数据帧长度b}{发送速率b&#x2F;s}$</p><p>传播时延（数据从发送方到接收方所需时间）</p><p>​$传播时延&#x3D;\frac{信道长度（米）}{信号在信道上传播速率m&#x2F;s}$</p><p>处理时延（路由器或交换机对数据进行处理所需时间）</p><p>排队时延（等待路由器或交换机处理数据的时间）四个部分。</p><p>注意，电路交换提前建立好了路径，所以中间节点是没有发送时延的，只有最开始有发送时延，而分组交换没有提前建立路径，所以对于k个链路，有k-1个节点，产生K-1个发生时延</p><p>容易产生错误的概念</p><p>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是在比特链路上的传播速率</p><p><strong>5 时延带宽积</strong></p><p>是指在一个网络中，数据从发送端到接收端所需要的时间与网络带宽的乘积。它的单位通常是比特（bits）可以用来评估网络的传输性能，也是确定网络传输最大吞吐量的一个重要参数。</p><p><strong>6 往返时间RTT</strong></p><p>是指数据从发送端发送到接收端并返回的时间，通常使用毫秒（ms）作为单位。</p><p>7 <strong>利用率</strong></p><p>利用率（Utilization）是指网络资源在一段时间内被使用的程度，是衡量网络资源利用效率的一个重要指标。利用率通常使用百分比（%）或小数表示，例如50%或0.5</p><p>时延与网络利用率关系</p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923224301410.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230923224301410.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="时延与网络利用率关系" style="zoom: 33%;" /><p>8 <strong>数据传输效率</strong></p><h1 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5 计算机网络体系结构"></a>5 计算机网络体系结构</h1><p>计算机网络学习的过程中，一个非常显著的特点就是会发现他是分层的，为何要这样做呢？</p><p>实际上，是因为看似网络传输这样一个简单问题，涉及到很多细节内容，如传输对方是否可以接收，如果可以出现差错怎么办，如果文件格式不匹配怎么来转换？等等一系列问题。所以计算机网络的设计者们就提出采用分层的方式来将庞杂的问题化大为小，各点突破！</p><p>常见的网络体系结构有OSI参考模型和TCP&#x2F;IP参考模型两种，OSI提出的要比TCP&#x2F;IP早，但是因为一些原因一直没有得到广泛商用，所以也就意味着当下商用的模型都主要是TCP&#x2F;IP模型，也是我们学习的重点</p><ol><li>OSI参考模型</li></ol><p>OSI参考模型是由国际标准化组织（ISO）制定的一个网络体系结构标准。它共分为七层，包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层都有自己的特定功能和任务，不同层之间通过接口进行通信，从而实现数据传输和处理。</p><ol><li>TCP&#x2F;IP参考模型</li></ol><p>TCP&#x2F;IP参考模型是由美国国防部高级研究计划局（ARPA）制定的一个网络体系结构标准。它共分为四层，包括链路层、网络层、传输层和应用层。与OSI参考模型不同，TCP&#x2F;IP参考模型将会话层、表示层和应用层合并为一个应用层，简化了网络结构，提高了网络的可靠性和效率。在学习过程中还会引入物理层（为了便于讲述原理等）。</p><p>所以我们实际学习的是五层</p><p>而每一层有很多协议，协议我们就可以理解为约定。</p><p>比如我们往往可以在谍战片里看到两个人接头暗号，就是一种协议，知道对方是要做什么，怎么做等等</p><p>因而计算机网络协议是我们要学习的重点</p><h1 id="6-计算机网络协议"><a href="#6-计算机网络协议" class="headerlink" title="6 计算机网络协议"></a>6 计算机网络协议</h1><h2 id="6-1-计算机网络协议与组成"><a href="#6-1-计算机网络协议与组成" class="headerlink" title="6.1 计算机网络协议与组成"></a>6.1 计算机网络协议与组成</h2><p>网络协议是计算机网络中数据传输和通信的规则集合。一个完整的网络协议通常包括以下几个要素：</p><ol><li>语法：定义了数据传输的格式和规范，即数据在网络中的组织方式和编码方式。</li><li>语义：定义了数据传输的含义和解释方式，即数据在网络中的意义和作用。</li><li>同步：定义了数据传输的时间顺序和流程，即数据在网络中的传输顺序和时序关系。</li></ol><h2 id="6-2-PDU"><a href="#6-2-PDU" class="headerlink" title="6.2  PDU"></a>6.2  PDU</h2><p>PDU：协议数据单元</p><p>什么是协议数据单元呢？</p><p>首先我们知道我们传输的都是数据，数据会从发送方的顶层出发，一层一层向下传输到物理层，然后通过物理介质传输到接收方，接收方再一层一层向上到顶层</p><p>其中每到一层，都会根据当层协议去给数据加信息</p><p>所以PDU定义如下</p><p>在计算机网络通信中，PDU 是指在不同网络层之间传输的数据单元。每个网络层将数据辅助添加到 PDU 中，然后将其传递给下一层，直到数据到达目标。</p><p>PDU&#x3D;首部+载荷+尾部</p><p>各层PDU名称</p><p>各层PDU名称如下：</p><ol><li><p>物理层：比特流（Bit Stream）</p></li><li><p>数据链路层：帧（Frame）</p></li><li><p>网络层：包（Packet）</p></li><li><p>传输层：TCP的PDU： 报文段</p><p>​              UDP的PDU  ：用户数据报</p></li><li><p>应用层： 报文</p></li></ol><p>再来了解几个概念</p><p><strong>实体</strong></p><p>实体表示任何可发送或接收信息的硬件或软件进程</p><p><strong>协议</strong></p><p>协议是控制两个对等实体进行通信规则的集合</p><p>协议是水平的，即协议是控制对等实体之间的通信规则</p><p><strong>服务</strong></p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</p><p>服务是垂直的，即服务是由下层向上层通过层间接口提供的</p><p>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点SAP</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（六）设备管理</title>
      <link href="/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/20/Computer_system/Os/6%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210604795.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><h1 id="1-设备管理概述"><a href="#1-设备管理概述" class="headerlink" title="1 设备管理概述"></a>1 设备管理概述</h1><h2 id="1-1-系统总线结构"><a href="#1-1-系统总线结构" class="headerlink" title="1.1 系统总线结构"></a>1.1 系统总线结构</h2><p>系统总线上传输的信息有——数据 地址 其他控制状态定时信号</p><p>系统总线其实有几类</p><p>如下图 CPU总线 存储器总线 和I&#x2F;O总线</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118173505779.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="CPU总线 存储总线 I/O总线"></p><p>其中北桥芯片组把处理器和存储器分成了两个总线</p><p>南桥芯片连接在I&#x2F;O总线上</p><p>I&#x2F;O总线上连着众多的I&#x2F;O设备</p><p>当然I&#x2F;O总线和I&#x2F;O设备之间通过设备管理器进行连接控制</p><p>那么设备管理器的结构是怎样的呢？</p><h2 id="1-2-设备控制器通用结构"><a href="#1-2-设备控制器通用结构" class="headerlink" title="1.2 设备控制器通用结构"></a>1.2 设备控制器通用结构</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183119930.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设备控制器结构"></p><p>控制不同的外设需要不同的设备控制器，将系统总线和设备侧的接口连在一起</p><h2 id="1-3-I-O设备的模型"><a href="#1-3-I-O设备的模型" class="headerlink" title="1.3 I&#x2F;O设备的模型"></a>1.3 I&#x2F;O设备的模型</h2><p>对于外部设备而言，他们的设备如下</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118183147173.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="外部设备通用模型"></p><h1 id="2-I-O端口"><a href="#2-I-O端口" class="headerlink" title="2 I&#x2F;O端口"></a>2 I&#x2F;O端口</h1><p>I&#x2F;O设备中非常重要的一部分就是外设寄存器（也叫做I&#x2F;O端口，下文我们都叫做I&#x2F;O端口了）（存储着设备状态，数据等）</p><p>控制需要了解外设寄存器值，读取数据也是从相应的寄存器值读取</p><p>I&#x2F;O端口通常包括：控制寄存器、状态寄存器和数据寄存器三大类</p><p>所以这里就牵扯出一个问题，CPU下达指令读或写某个I&#x2F;O端口（寄存器），需要知道那个寄存器在哪里，也就是说寄存器的地址是什么，这就涉及到I&#x2F;O端口的编址以及寻址</p><h2 id="2-1-寻址方式"><a href="#2-1-寻址方式" class="headerlink" title="2.1 寻址方式"></a>2.1 寻址方式</h2><p><strong>统一编址方式（内存映射方式）</strong></p><p>与主存空间统一编址，主存单元和I&#x2F;O端口在同一个地址空间</p><p>外设与内存统一的编址方式，优点是编程简单，因为可以像访问内存一样去访问外设。缺点是IO也占用CPU的寻址空间。</p><p><strong>独立编址方式（特殊I&#x2F;O指令方式）</strong></p><p>单独编号，不和主存单元一起编，使成为一个独立的I&#x2F;O地址空间，例如Intel处理器</p><p>而独立编址的方式，优点是不占用CPU的寻址空间，但是CPU的构造比较复杂。(因为额外的CPU指令需要对CPU进行额外的设计处理)。</p><h1 id="3-驱动程序"><a href="#3-驱动程序" class="headerlink" title="3 驱动程序"></a>3 驱动程序</h1><p>控制外设进行输入输出的底层I&#x2F;O软件是驱动程序，由设备生产商制作，包括 设备控制器中有哪些用户可以访问的寄存器、控制状态寄存器的每一位的含义，通信协议等等</p><p>驱动程序通过访问 I&#x2F;O端口控制外设进行I&#x2F;O</p><p>​比如 读取控制命令送到控制寄存器来启动外设工作</p><p>​读取状态寄存器了解外设和设备控制器的状态</p><p>​访问数据缓冲寄存器进行数据的输入和输出</p><p>实现这种访问操作是通过I&#x2F;O操作完成的，他是一种特权指令</p><h1 id="4-基本I-O控制方式"><a href="#4-基本I-O控制方式" class="headerlink" title="4 基本I&#x2F;O控制方式"></a>4 基本I&#x2F;O控制方式</h1><p>有如下四种</p><h2 id="4-1-程序直接控制"><a href="#4-1-程序直接控制" class="headerlink" title="4.1 程序直接控制"></a>4.1 程序直接控制</h2><p>​程序查询I&#x2F;O方式</p><p><strong>原理</strong> 由CPU负责直接控制I&#x2F;O操作，不涉及中断或DMA（Direct Memory Access）。</p><p><strong>方法</strong></p><p>计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字， CPU 需要对外设状态进行循环检查，直到确定该字已经在I&#x2F;0 控制器的数据寄存器中</p><p><strong>优点</strong> 简单、易于实现。</p><p><strong>缺点</strong></p><p>在程序直接控制方式中，由于CPU 的高速性和I&#x2F;0设备的低速性，致使CPU 的绝大部分时间都处于等待I&#x2F;0 设备完成数据I&#x2F;0 的循环测试中，造成了<strong>CPU 资源的极大浪费</strong>。在该方式中， CPU 之所以要不断地测试I&#x2F;0 设备的状态，就是因为在CPU 中未采用中断机构，使I&#x2F;0 设备无法向CPU报告它已完成了一个字符的输入操作。</p><h2 id="4-2-中断I-O方式"><a href="#4-2-中断I-O方式" class="headerlink" title="4.2 中断I&#x2F;O方式"></a>4.2 中断I&#x2F;O方式</h2><p>​中断I&#x2F;O方式</p><p><strong>原理</strong> 设备在完成操作后发出中断信号，通知CPU进行数据传输。</p><p><strong>方法</strong></p><p>中断驱动方式的思想是，允许I&#x2F;0 设备主动打断CPU 的运行并请求服务，从而“解放”CPU, 使得其向I&#x2F;0 控制器发送读命令后可以继续做其他有用的工作。</p><p><strong>优点：</strong> 提高CPU利用率，减少了对CPU的占用。</p><p><strong>缺点</strong></p><p>中断方式在一些情况下可以提高CPU利用率，但在一些情况下，字符式设备，其中断频率太高，来回切换的话也会耗费处理机较多时间</p><p>核心是因为什么？</p><p>是因为上面两种方式都需要经过CPU处理？</p><p>什么叫经过CPU处理</p><p>是外设输入数据流大概是这样的： 【外围设备-&gt;I&#x2F;O控制器的数据寄存器-&gt;CPU寄存器-&gt;存储器】，这就叫经过CPU，或者说传输数据的过程需要CPU的干预</p><p>于是引出了下面的DMA(直接在I&#x2F;O设备和内存之间建立数据通路)</p><h2 id="4-3-DMA方式"><a href="#4-3-DMA方式" class="headerlink" title="4.3 DMA方式"></a>4.3 DMA方式</h2><p>磁盘等高速外设设备所用的方式</p><p><strong>原理</strong></p><p>​基本思想 在高速外设和主存间直接传送数据</p><p>​由专门硬件<strong>（即DMA控制器）</strong>控制总线进行传输，注意这里不是CPU了</p><p><strong>方式</strong></p><ol><li>基本单位是数据块（前面是一个字）。</li><li>所传送的数据，是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU 干预，整块数据的传送是在DMA控制器的控制下完成的。</li></ol><p><strong>优点</strong> 大大减轻了CPU的负担，提高了数据传输速率。</p><p><strong>缺点</strong> 需要额外的硬件支持，复杂度较高。</p><p>如何进一步提高资源利用率呢？当然是请更牛逼的通道，将苦逼的CPU尽可能的从累活中解放出来。</p><h2 id="4-4-I-O通道控制方式"><a href="#4-4-I-O通道控制方式" class="headerlink" title="4.4 I&#x2F;O通道控制方式"></a>4.4 I&#x2F;O通道控制方式</h2><p><strong>原理</strong> 使用专门的I&#x2F;O通道控制器，它独立于CPU和主存储器，负责管理多个设备的I&#x2F;O操作</p><p><strong>方式</strong></p><p>I&#x2F;0 通道是指专门负责输入／输出的处理机。I&#x2F;O通道方式是DMA方式的发展，它可以进一步 减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I&#x2F;0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p><p><strong>优点：</strong> 高度并行化的数据传输，减少了对CPU的占用。</p><p><strong>缺点：</strong> 需要更复杂的硬件支持，成本较高。</p><h1 id="5-I-O管理中的重要思想"><a href="#5-I-O管理中的重要思想" class="headerlink" title="5 I&#x2F;O管理中的重要思想"></a>5 I&#x2F;O管理中的重要思想</h1><h2 id="5-1-设备独立性"><a href="#5-1-设备独立性" class="headerlink" title="5.1 设备独立性"></a>5.1 设备独立性</h2><p>该思想旨在使应用程序与具体的I&#x2F;O设备解耦，从而提高系统的灵活性、可移植性和可维护性。</p><h2 id="5-2-SPOOLing技术"><a href="#5-2-SPOOLing技术" class="headerlink" title="5.2 SPOOLing技术"></a>5.2 SPOOLing技术</h2><p>​即外围设备同时联机操作，又称作假脱机操作</p><p>什么是<strong>脱机I&#x2F;O</strong>？</p><p>​脱机I&#x2F;O  目的是为了解决CPU和I&#x2F;O速度不匹配的问题，输入由一台低挡计算机做中介</p><p>什么是<strong>假脱机</strong>？</p><p>​即模拟实现上面的脱机i&#x2F;O</p><p><strong>实现方法</strong></p><p>​OS利用两个进程分别模拟脱机I&#x2F;O时外围机的功能</p><p>​其中一个进程负责将输入设备的数据传送到磁盘，另一个进程负责将数据从磁盘送到输出设备</p><p><strong>组成</strong></p><p>​1 输入输出井</p><p>​2 预输入进程和缓输出进程</p><h2 id="5-3-I-O软件的多层模型"><a href="#5-3-I-O软件的多层模型" class="headerlink" title="5.3 I&#x2F;O软件的多层模型"></a>5.3 I&#x2F;O软件的多层模型</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118190157639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="I/O软件的多层模型"></p><p>1 用户进程层——执行I&#x2F;O系统调用，对I&#x2F;O数据进行格式化(如将十进制数转换为ASCLL码字符串以便输出)</p><p>2 独立于设备的软件——实现设备的命名，分配，数据的缓冲，设备的保护，提供下层的统一接口，检查用户是否有权使用</p><p>3 设备驱动程序，与设备有关的代码，向设备控制器发送命令，检测设备的执行状态</p><p>4 中断处理程序，负责I&#x2F;O完成时，唤醒设备驱动程序的进程，进行中断处理</p><p>5 硬件层 实现物联I&#x2F;O操作</p><h1 id="6-磁盘I-O"><a href="#6-磁盘I-O" class="headerlink" title="6 磁盘I&#x2F;O"></a>6 磁盘I&#x2F;O</h1><p>磁盘一般分为固定结构和移动头磁盘两大类</p><p>固定头磁盘——每个盘面的每条磁道都有一个读写磁头，固定头磁盘各个磁头可并行读写，成本高</p><p>移动头磁道——每个盘面只有一个读写磁头</p><h2 id="6-1-磁盘调度算法"><a href="#6-1-磁盘调度算法" class="headerlink" title="6.1 磁盘调度算法"></a>6.1 磁盘调度算法</h2><p>目标 使得磁盘平均寻道时间最短 </p><h3 id="6-1-1-先来先服务-FCFS"><a href="#6-1-1-先来先服务-FCFS" class="headerlink" title="6.1.1 先来先服务 FCFS"></a>6.1.1 先来先服务 FCFS</h3><p>按请求访问磁盘的先后次序进行调度</p><h3 id="6-1-2-最短寻道时间优先-SSTF"><a href="#6-1-2-最短寻道时间优先-SSTF" class="headerlink" title="6.1.2 最短寻道时间优先 SSTF"></a>6.1.2 最短寻道时间优先 SSTF</h3><p>选择处理与当前磁头距离最近的磁道请求，以减少寻道时间</p><h3 id="6-1-3-扫描算法-电梯调度算法-SCAN"><a href="#6-1-3-扫描算法-电梯调度算法-SCAN" class="headerlink" title="6.1.3 扫描算法 电梯调度算法 SCAN"></a>6.1.3 扫描算法 电梯调度算法 SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，再反方向</p><p>（可以联想电梯哦！！）</p><h3 id="6-1-3-循环扫描-C-SCAN"><a href="#6-1-3-循环扫描-C-SCAN" class="headerlink" title="6.1.3  循环扫描 C-SCAN"></a>6.1.3  循环扫描 C-SCAN</h3><p>要求磁头臂仅沿一个方向移动，并在途中满足所有未完成的请求，直到最后一个磁道，不反方向直接回到最后一个磁道，开始扫描</p><p>（可以联想循环结构哦！第一次for(i&#x3D;0;i&lt;&#x3D;10;i++) ，i从0开始，到10 下次执行还是从0开始）</p><p>SSFT、SCAN、C-SCAN都存在“饿死现象”</p><p>即当一个或多个进程反复请求某个磁道I&#x2F;O，垄断了整个磁盘，其他磁道得不到访问</p><h3 id="6-1-4-N-Step-SCAN"><a href="#6-1-4-N-Step-SCAN" class="headerlink" title="6.1.4 N-Step-SCAN"></a>6.1.4 N-Step-SCAN</h3><p>将磁盘请求队列分成若干个长度为N的子队列</p><p>每一次SCAN处理一个子队列</p><p>磁盘调度将按FCFS算法依次处理这些子队列，而每处理一个子队列时，又是按照SCAN算法，当一个队列处理完后，再处理其他队列。当正在处理某子队列时，如果又出现新的磁盘I&#x2F;O请求，则将其放入其他队列中（这时候，因为不在同一队列里了，所以就不能老是执行一个进程的请求了！！！）</p><h3 id="6-1-5-FSCAN"><a href="#6-1-5-FSCAN" class="headerlink" title="6.1.5 FSCAN"></a>6.1.5 FSCAN</h3><p>使用2个子队列</p><p>当扫描开始时，所有请求都在一个子队列，另一个子队列为空，扫描过程中，所有新到的请求加入另一个子队列中，使得新请求服务延迟老请求处理完后（这样也可以避免饿死现象）</p><h2 id="6-2-其他磁盘I-O性能的改善"><a href="#6-2-其他磁盘I-O性能的改善" class="headerlink" title="6.2 其他磁盘I&#x2F;O性能的改善"></a>6.2 其他磁盘I&#x2F;O性能的改善</h2><p>高速缓存</p><p>合理分配磁盘空间</p><p>把有可能顺序访问的放到一块</p><p>提前读，延迟写，周期性的成簇写回</p><p><strong>例题</strong></p><p>尝试给出一种能够满足下列要求的I&#x2F;O设备管理设计方案：</p><p>1 应用程序在访问设备时候，不需要关心设备的物理特性</p><p>2 应用程序申请使用某类设备时，不需要指定具体的物理设备</p><p>3 应用程序可以通过文件系统访问设备</p><p>设计方案：</p><p>为满足上述要求，可以设计一个综合管理系统，其设计思路如下：</p><p>1 <strong>采用分层的I&#x2F;O软件模型</strong>  多层处理，如用户层，设备驱动程序等待。进行设备抽象，将不同类型的设备进行抽象，屏蔽设备的具体物理特性。通过设备抽象，应用程序可以以统一的方式访问各种设备，而无需关心设备的底层实现。</p><p> 2 <strong>设备分组</strong>：将相同类型的设备进行分组，并为每个设备组分配一个唯一的标识符。应用程序在申请使用某类设备时，只需指定设备组的标识符，而无需指定具体的物理设备。</p><p>3  <strong>权限控制</strong>：设计合适的权限控制机制，确保应用程序只能访问其被授权的设备组和设备文件，以保护系统的安全性和数据的机密性。</p><p>数据结构</p><p>1 用类和结构定义抽象层，包括设备的通用属性，操作方法，事件等</p><p>2 用哈希表或映射存储设备组的标识符和相应的设备类型</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）文件系统</title>
      <link href="/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/19/Computer_system/Os/5%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126205825390.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="文件系统上总览图"></p><h1 id="1-文件系统概述"><a href="#1-文件系统概述" class="headerlink" title="1 文件系统概述"></a>1 文件系统概述</h1><p><strong>为什么引入文件系统</strong></p><p>​长期保存（大量的）数据</p><p>​方便用户使用</p><p>文件是有名字的记录在外存中的一组有逻辑意义的数据项序列</p><p><strong>什么是文件系统</strong></p><p>文件系统是OS中用来管理文件的那一部分软件</p><p><strong>文件系统功能</strong></p><p>统一管理文件的存储空间，实施存储空间的分配与回收<br>实现文件信息的共享，提供文件的保护和保密措施<br>实现文件的按名访问<br>     访问的透明性：用户不关心文件的物理位置和存储结构<br>向用户提供一个方便使用的接口，提供对文件系统操作的命令<br>提供与I&#x2F;O的统一接口</p><p><strong>文件分类：</strong></p><p>Unix系统将文件分为3类:<br>普通文件(regular)：ASCII或二进制文件<br>目录文件(directory)<br>特殊文件：设备文件，管道，套接字（socket），符号链接等</p><h1 id="2-文件的结构与存取方式"><a href="#2-文件的结构与存取方式" class="headerlink" title="2 文件的结构与存取方式"></a>2 文件的结构与存取方式</h1><p>文件是存在磁盘上的</p><h2 id="2-1-磁盘"><a href="#2-1-磁盘" class="headerlink" title="2.1 磁盘"></a>2.1 磁盘</h2><p>磁盘有扇片  磁道 扇区</p><p>扇区——磁盘最小可寻址单元</p><p>簇——存储块，固定数量的扇区</p><ul><li>平均存取时间</li></ul><p>​T&#x3D;平均寻道时间+平均旋转等待时间+数据传输时间（有时候忽略不计）</p><p>​其中</p><p>​平均寻道时间——磁头寻找到指定磁道所需要的平均时间（大约5ms）</p><p>​平均旋转等待时间——指定扇区旋转到磁头下方所需要的平均时间（约4-6ms）</p><ul><li>磁盘响应时间&#x3D;平均存取时间+排队时间+控制器时间</li></ul><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106203358743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="计算例题"></p><p>注意想明白这里的0.5的来源</p><h2 id="2-2-文件的物理结构"><a href="#2-2-文件的物理结构" class="headerlink" title="2.2 文件的物理结构"></a>2.2 文件的物理结构</h2><h3 id="2-2-1-连续结构"><a href="#2-2-1-连续结构" class="headerlink" title="2.2.1 连续结构"></a>2.2.1 连续结构</h3><p>文件的数据存放在若干连续的物理块中</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162832432.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="连续结构"></p><p><strong>优点：</strong></p><p>简单，只要记住首块的地址和文件长度即可<br> 支持顺序存取和随机存取<br> 顺序存取速度快<br> 所需的磁盘寻道时间最少</p><p><strong>缺点：</strong></p><p>不利于文件的动态增长<br>    若预留空间：浪费，而且预先不知道文件的最大长度<br>    否则需要重新分配和移动<br>不利于文件内容的插入和删除<br>存在外部碎片问题</p><h3 id="2-2-2-链式结构"><a href="#2-2-2-链式结构" class="headerlink" title="2.2.2 链式结构"></a>2.2.2 链式结构</h3><p> 一个文件的数据存放在若干不连续的物理块中，各块之间通过指针连接，<br> 每个物理块指向下一个物理块</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162903188.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="链式结构"></p><p><strong>优点</strong></p><p>提高了磁盘空间利用率<br> 不存在外部碎片问题<br> 有利于文件的插入和删除<br> 有利于文件的动态扩充</p><p><strong>缺点：</strong><br>随机存取相当缓慢<br>需要更多的寻道时间<br>链接指针占用一定的空间</p><p>改进变形</p><p>FAT表</p><p>文件分配表FAT的一种实现：<br>磁盘的每个分区包含一个FAT，分区中的每个盘块在其中占有1项（以块号为索引），指出文件中下一块的块号。<br>在目录项中包含文件首块的块号。</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231106204009176.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="FAT表图示"></p><h3 id="2-2-3-索引结构"><a href="#2-2-3-索引结构" class="headerlink" title="2.2.3 索引结构"></a>2.2.3 索引结构</h3><p>一个文件的数据存放在若干不连续的物理块中，系统为每个文件建立一个专用数据结构–索引表。<br>索引表存放逻辑块号与物理块号的对应关系<br>一个索引表就是磁盘块地址（块号）数组，其中第i个条目存放的是逻辑块号i对应的物理块号<br>文件目录的目录项中指出索引表的物理地址</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231118162943439.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="索引结构"></p><p><strong>优点</strong>：保持了链接结构的优点，又避免了其缺点<br> 既能顺序存取，又能随机存取<br> 能满足文件动态增长、插入、删除的要求<br> 能充分利用外存空间<br><strong>缺点</strong>：<br>索引表本身带来了系统开销</p><p>UNIX文件系统采用的是多级混合索引结构。<br>每个文件的索引表为13个索引项<br>最前面10项直接登记存放文件数据的物理块号（直接寻址）<br>如果文件大于10块，则利用第11项指向一个物理块，该块中最多可放256个文件物理块的块号（一次间接寻址）。对于更大的文件还可利用第12和第13项作为二次和三次间接寻址<br>UNIX中采用了三级索引结构后，文件最大可达16M个物理块</p><p>索引表的组织方式</p><p>如果文件很大，索引表较大，超过了一个物理块，就必须考虑索引表的组织方式，即怎么去存储索引表</p><p>索引表的组织方式:<br>（1）连续方式<br>    索引表占用多个连续的盘块<br>（2）链接方式<br>    索引表按照链式结构组织，占用多个不连续的盘块<br>（3）多级索引（多重索引）<br>  例如，二级索引：将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中<br>  此外，还有三级索引等。</p><p>题目</p><p>设每个盘块4kB，每个盘块号4B，则采用3次间址可表示的文件最大长度为 [4T] B。</p><h2 id="2-3-文件的存取方式"><a href="#2-3-文件的存取方式" class="headerlink" title="2.3 文件的存取方式"></a>2.3 文件的存取方式</h2><p>主要有顺序存取和随机存取两种。<br>1 顺序存取<br>  对文件中的数据按逻辑顺序进行读&#x2F;写的存取方式<br> 2 随机存取<br>  对文件中的数据按任意顺序进行读&#x2F;写的存取方式<br> 3 按键（key）存取：如DBMS</p><p>还与介质有关</p><h1 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3 文件目录"></a>3 文件目录</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>几个基本的概念</p><p><strong>1 文件控制块</strong></p><p>文件控制块是操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有相关信息（文件属性）</p><p>基本信息：文件的名字、地址（起始物理块号）、长度、结构（逻辑结构、物理结构）、类型<br>存取控制信息：文件属主（owner）、存取权限或口令<br>使用信息：共享计数，文件的建立、修改日期等</p><p><strong>2 文件目录</strong></p><p> 把所有的FCB组织在一起，就构成了文件目录<br>  即文件控制块的有序集合</p><p><strong>3  目录项</strong><br>  构成文件目录的项目（目录项就是FCB）</p><p><strong>4 目录文件</strong></p><p>为了实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，<br> 这个文件就叫目录文件<br> 目录主要是为了系统快速实现“按名访问”而引入的，<br> 查目录是文件系统最频繁的操作，因此目录的合理组织很重要</p><h2 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h2><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>为所有文件建立一个目录文件（组成一线性表）<br>优点：简单，易实现</p><p>缺点：<br> 限制了用户对文件的命名（容易出现“命名冲突”）<br> 顺序检索文件时，平均检索时间长<br> 不利于对文件的共享</p><h3 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h3><p>对二级目录简单扩充可得三级或三级以上的多级目录结构，<br>即允许每一级目录中的FCB要么指向文件，要么指向下一级子目录。<br>这是当今主流OS普遍采用的目录结构<br>优点：<br>    层次结构清晰，便于管理和保护；有利于文件分类；<br>    能较好地避免重名问题；提高了文件检索速度；有利于访问权限的控制</p><h2 id="3-3-文件目录检索"><a href="#3-3-文件目录检索" class="headerlink" title="3.3 文件目录检索"></a>3.3 文件目录检索</h2><p>访问文件时，必须首先确定<strong>读写文件的地址</strong>，需要下列2步：<br>（1）目录检索：根据文件名，查目录，确定文件的起始地址。<br>（2）文件寻址：确定所要访问文件内容的起始位置（地址）。</p><h3 id="3-3-1-目录检索"><a href="#3-3-1-目录检索" class="headerlink" title="3.3.1 目录检索"></a>3.3.1 目录检索</h3><p>文件的“按名存取”是通过查目录实现的，系统按照文件的路径名检索<br>基本的目录检索技术主要有：<br>线性检索法<br>Hash方法<br>为了加快目录检索，许多系统引入当前目录（工作目录）、相对路径名等。</p><h3 id="文件寻址"><a href="#文件寻址" class="headerlink" title="文件寻址"></a>文件寻址</h3><p>根据目录项（FCB）中记录的文件物理地址等信息，<br>求出文件的任意记录或字节在存取介质上的地址<br>文件寻址与文件的物理结构和逻辑结构以及设备的物理特性有关<br>文件的内容是以块为单位存储的。<br>但存取文件时，对于记录式文件，是以逻辑记录为单位提出存取要求的，因此，<br>存储介质上的物理块长度与逻辑记录的长度是否匹配直接影响到对文件的寻址</p><h2 id="3-4-文件目录的实现"><a href="#3-4-文件目录的实现" class="headerlink" title="3.4 文件目录的实现"></a>3.4 文件目录的实现</h2><p>当查找文件时候，需要依次将存放目录的物理块装入内存，逐一比较文件名，直到找到为止</p><p>例如：文件说明占128B，每块512B，则每块可存放4个目录项</p><p>设目录文件占用的盘块数是N个，则要找到一个目录项，<br>平均需要读入多少个盘块？(N+1)&#x2F;2块</p><p>把文件说明信息（FCB）都放在目录项中的缺点：<br>  查找文件缓慢，因为目录项较大<br>  文件目录平常放在外存中，当文件很多时，可能占用大量的外存物理块</p><p>但实际上我们文件检索只需要文件名，不需要那么多其他的信息</p><p>所以我们将文件说明分成两部分   把FCB分成两部分</p><p>1 符号目录项——包括文件名，文件号</p><p>2 基本目录项——除文件名以外的所有信息</p><p>目录项分解法的典型实现</p><p>1 符号文件目录+基本文件目录</p><p>2 目录项 +I 节点</p><p>Unix&#x2F;Linux采用此方法，它把符号目录项称为目录项，而把基本目录项称为I节点（Index node，索引节点），这样，目录项中的文件号就是I节点号。</p><p>举例一个查找过程</p><p>一个文件存在根目录下的wang目录下，若获得这个文件的I结点号，需要读几个磁盘物理块</p><p>注意 I节点只存储当前目录或者文件的信息！！！</p><p>I节点存的物理块号（如果是目录的话，就是目录项的地址，如果是文件的话，则是文件的首地址）！！！</p><p>首先根据根目录的I节点号以及内存中的I节点与物理块号的对应关系，可以知道根目录I节点的地址，去读这个地址的内容（第一次读物理块读取），即是获得了根目录的目录项的地址，去读根目录的目录项（第二次物理块读取）可以知道wang对应的I节点物理地址，读wang的I节点地址内容（第三次读取）可以知道wang的目录项地址，读wang目录项地址就可以获得文件a.c的I节点号（第四次读取）</p><p>如果是索引的话 获得的地址不是物理块地址，而是索引表地址，所以需要每一个获取地址都增加一次，总共六次</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126210111722.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231126210111722"></p><h1 id="4-空闲存储空间的管理"><a href="#4-空闲存储空间的管理" class="headerlink" title="4 空闲存储空间的管理"></a>4 空闲存储空间的管理</h1><h2 id="4-1-空闲区表"><a href="#4-1-空闲区表" class="headerlink" title="4.1 空闲区表"></a>4.1 空闲区表</h2><p>将所有空闲区记录在一个表中。<br>    适合连续文件的外存分配与回收。如今很少用</p><h2 id="4-2-空闲块链"><a href="#4-2-空闲块链" class="headerlink" title="4.2 空闲块链"></a>4.2 空闲块链</h2><p>把所有空闲块链成一个链，适合离散分配</p><p>扩展：<br>①不断地适度增加块大小<br>    从最早的512B 1KB  2KB  4KB  8KB  16KB  32KB  64KB。<br>②成组链接法<br>  链上每个节点记录1组空闲块。适合大型文件系统，分配、释放快，<br>  链占用空间少（除首组外均隐藏在空闲块中）。UNIX用之</p><p>成组连接法</p><h2 id="4-3-位图"><a href="#4-3-位图" class="headerlink" title="4.3 位图"></a>4.3 位图</h2><p>用一串二进制位反映磁盘空间的分配情况，每个物理块对应1位，已分配的物理块为1，否则为0<br>申请物理块时，可以在位图中查找为0的位，返回对应的物理块号<br>归还时，将对应位设置为0<br>描述能力强，适合各种物理结构</p><h1 id="5-文件的使用"><a href="#5-文件的使用" class="headerlink" title="5 文件的使用"></a>5 文件的使用</h1><p>为方便用户使用文件，文件系统提供对文件的各种操作，<br>使用的形式包括系统调用或命令<br> ① 提供设置和修改用户对文件访问权限的操作<br> ② 提供建立、修改、删除目录的操作<br> ③ 提供文件共享、设置访问路径的操作<br> ④ 提供创建、打开、读、写、关闭、删除文件等操作<br>其中，最基本的操作是：打开、关闭、读、写文件等</p><p>为什么要 打开&#x2F;关闭文件呢</p><p>open：把文件说明信息（FCB）装入内存，便于以后的快速访问。<br>（1）根据指定的文件路径名，查目录，找到相应文件的目录项，检查权限；<br>（2）将文件说明信息装入内存；<br>（3）分配一个文件id（整数）。后面通过该id实施对该文件的操作。</p><p>close：<br> （1）释放文件说明信息所占的内存空间；<br> （2）把文件缓冲区中已修改的内容写回文件。<br> 很多系统限制进程打开文件的个数，用户尽可能要关闭不再使用的文件。</p><p>打开文件会在内存建立文件的描述信息，记录文件的当前指针，有助于提高文件的访问速度与灵活性。</p><p>关闭会释放文件缓冲区，将已修改的内容写盘，释放文件描述信息所占的内存空间。若不关闭文件，则内存空间被浪费，甚至可能会使修改的内容丢失。</p><h1 id="6-文件共享"><a href="#6-文件共享" class="headerlink" title="6 文件共享"></a>6 文件共享</h1><p>文件共享：一个文件被多个用户或进程使用<br>共享的目的：<br>节省时间和存储空间，减少用户工作量<br>进程间通过文件交换信息</p><h2 id="6-1-普通的文件共享方法"><a href="#6-1-普通的文件共享方法" class="headerlink" title="6.1 普通的文件共享方法"></a>6.1 普通的文件共享方法</h2><h3 id="6-1-1-按路径名访问共享文件"><a href="#6-1-1-按路径名访问共享文件" class="headerlink" title="6.1.1 按路径名访问共享文件"></a>6.1.1 按路径名访问共享文件</h3><p>  实现简单，不需要建立另外的目录项<br>  但路径名可能长，检索较慢</p><h3 id="6-1-2-链接法"><a href="#6-1-2-链接法" class="headerlink" title="6.1.2 链接法"></a>6.1.2 链接法</h3><p>在相应目录项之间建立链接。即一个目录项中含有指向另一个目录项的指针。<br> 实现方法：<br>  在目录项中设置一个“链接属性”，<br>  表示目录项中的“物理地址”是指向另一目录项的指针。<br>  同时，在共享文件的目录项中包含“用户计数”。</p><h3 id="6-1-3-基本文件目录BFD"><a href="#6-1-3-基本文件目录BFD" class="headerlink" title="6.1.3 基本文件目录BFD"></a>6.1.3 基本文件目录BFD</h3><p>整个文件系统有1个基本文件目录BFD：<br>    每个文件（及目录）有1个目录项，包含系统赋予的唯一标识符ID（整数）<br>    以及其他的文件说明信息<br>每个目录有1个符号文件目录SFD：除了ID &#x3D; 0，1，2外,<br>     每个目录项仅包含文件名和ID<br>系统把ID &#x3D; 0，1，2的目录项分别作为BFD、FFD、MFD的标识符<br>共享方法：<br>     若一个用户想共享另一用户的文件，只需在自己的目录文件中增加一个目录项，填上自己起的文件名和该共享文件的唯一ID即可。如ID &#x3D; 6的文件。  </p><h2 id="6-2-基于I节点的文件共享方法（Unix采用）"><a href="#6-2-基于I节点的文件共享方法（Unix采用）" class="headerlink" title="6.2 基于I节点的文件共享方法（Unix采用）"></a>6.2 基于I节点的文件共享方法（Unix采用）</h2><h3 id="6-2-1-硬链接"><a href="#6-2-1-硬链接" class="headerlink" title="6.2.1 硬链接"></a>6.2.1 硬链接</h3><h3 id="6-2-3-符号链接"><a href="#6-2-3-符号链接" class="headerlink" title="6.2.3 符号链接"></a>6.2.3 符号链接</h3><p>在Windows中叫做 快捷方式</p><h1 id="7-文件保护"><a href="#7-文件保护" class="headerlink" title="7 文件保护"></a>7 文件保护</h1><p>主要涉及文件存取控制</p><ol><li><p>存取控制矩阵<br> 给出每个用户对每个文件的访问权限。<br> 一维是所有用户，另一维是所有文件，<br> 对应的矩阵元素是用户对文件的访问权限。<br> 例如，访问操作分为：<br> 读操作（r）<br> 写操作（w）<br> 执行操作（x）<br> 不能执行任何操作（-）<br> 当用户和文件较多时，很庞大。</p></li><li><p>存取控制表（Access Control List，ACL）<br> 每个文件一张ACL，将用户分类，规定每类用户的访问权限。<br> 例如，Unix&#x2F;Linux将用户分类为：<br> 文件主（owner）<br> 文件主的同组用户（group）<br> 其他用户（other）</p></li><li><p>存取权限表（Capability List，CL）<br> 每个用户一张CL，规定对每个文件的访问权限。</p></li><li><p>口令<br> 用户创建文件时，设置一个口令，放在文件目录中。</p></li><li><p>密码<br> 写入时加密，读出时解密。</p></li></ol><p>假定两个用户共享一个文件系统，用户A有文件a，b，e，f ，用户B有文件c，d，e，f。用户A的b和用户B的d是同一个文件。用户A的e和用户B的e不是同一个文件，用户A的f和用户B的f是同一个文件。拟定一个文件组织方案，使得A，B两个用户能够共享该文件系统而不会造成混乱</p><p>答</p><p>为了确保用户A和用户B能够共享文件系统而不会造成混乱，可以采用以下文件组织方案：</p><ol><li><strong>首先创建两个用户目录</strong>：为每个用户创建一个独立的目录，目录A和目录B。这样，用户A和用户B的文件可以分别存储在各自的目录中，避免混淆，对于用户A的e和用户B的e不是同一个文件，则可以将它们分别存放在各自的目录中，因为它们不需要共享</li><li><strong>共享文件存放目录</strong>：对于文件f，创建一个共享文件存放目录，这确保了用户A和用户B可以共同访问和修改这些共享文件。</li><li><strong>建立符号链接</strong>：对于用户A的b和用户B的d是同一个文件，则可以在用户A的目录中创建一个符号链接，指向用户B的文件d。这样，用户A可以访问和操作这个文件，同时避免重复存储。</li></ol><p>通过以上的文件组织方案，用户A和用户B可以共享文件系统，各自管理自己的文件，并且能够访问和修改共享文件，同时避免重名文件和混淆。这样可以确保文件系统的整体有序性和可维护性。</p><p>已知某文件系统采用多级目录结构，逻辑块和物理块大小均为1KB，目录当做文件，采用目录项+I结点的方式。假定要读取文件&#x2F;a&#x2F;b&#x2F;c.dat的第10600-10900个字节，针对连续结构，基本链式结构，FAT和单级索引结构这四种情况，回答下列问题</p><p>1 给出读盘过程</p><p>2 给出读盘次数（如果有必要，可以对本题未给出的条件做出合理假设）</p><ol><li>读盘过程：</li></ol><ul><li><p>连续结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到其起始逻辑块号。然后根据逻辑块号和文件系统的块映射关系，直接读取对应的物理块</p></li><li><p>基本链式结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，逐级跳转到链式结构中的下一个块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>FAT（文件分配表）结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据FAT表的信息，依次读取块链中的物理块，直到找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li><li><p>单级索引结构：根据文件&#x2F;a&#x2F;b&#x2F;c.dat在目录中的信息，找到对应的I节点编号。从I节点中读取文件的索引结构，根据单级索引指向的块，再根据块内的索引信息找到包含所需字节范围的块。然后从该块中读取所需字节。</p></li></ul><ol start="2"><li>读盘次数：</li></ol><ul><li><p>连续结构：只需进行一次读取，因为连续结构中的数据是连续存储的。</p></li><li><p>基本链式结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要跳转到下一个块。</p></li><li><p>FAT结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据FAT表的信息找到下一个块。</p></li><li><p>单级索引结构：根据所需字节范围的位置，可能需要多次读取。每次读取都需要根据索引结构中的信息找到下一个块。</p></li></ul><p>需要注意的是，以上的读盘次数可能还会受到文件系统的缓存策略等因素的影响，这里只是基于给出的情况做出的合理估计。</p><p>为某一个应用场景设计一个文件系统，所设计的文件系统不能建立在已有的文件系统的基础上。具体要求如下：</p><p>1 举一个应用场景的例子，说明该场景下对文件系统的具体需求</p><p>2 针对具体需求给出一种文件系统的设计方案</p><p>3 对你的设计方案进行评价</p><ol><li><p>应用场景示例：智慧农业控制嵌入式系统。在智慧农业系统中，用户可以通过手机或者智能音箱等设备来控制农场中的各种设备，如灯光、温度、安防等。在这个场景中，文件系统被用于存储和管理各类设备的配置文件、日志文件等数据。</p></li><li><p>文件系统设计方案：</p></li></ol><p>考虑到智慧农业控制嵌入式系统的特点和需求，可以设计一种轻量级的文件系统，具备以下特点：</p><ul><li><strong>简单快速</strong>: 提供简洁的操作界面和易于理解的文件组织方式，方便用户进行文件的存储、查找和管理。优化文件系统的读写性能，以满足实时控制的需求。采用文件缓存、文件索引等技术来提升文件读写效率。</li><li><strong>可靠性</strong>: 采用数据冗余和文件系统日志等机制来保证数据的完整性和可靠性，防止数据丢失或损坏。</li><li><strong>安全性</strong>: 对于敏感信息，采用加密算法进行数据保护，防止数据泄露和非法访问。</li><li><strong>灵活扩展</strong>: 设计分级的结构设计，以便未来能够支持新的设备类型、新的功能和协议。</li></ul><ol start="3"><li>设计方案评价：</li></ol><p>该设计方案针对智慧农业控制嵌入式系统的需求进行了考虑，并且具备一定的可行性和可实现性。然而，对于一个完整的文件系统来说，还需要更多的细节和技术实现方面的考虑，如并发访问的处理、容错和恢复机制等。此外，还需要考虑与其他系统组件的协同工作，以确保整个智慧农业控制嵌入式系统的稳定运行和良好的用户体验</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）内存管理</title>
      <link href="/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/10/18/Computer_system/Os/4%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202354730.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="内存管理总览图"></p><h1 id="1-内存管理概述"><a href="#1-内存管理概述" class="headerlink" title="1 内存管理概述"></a>1 内存管理概述</h1><p>内存是存储系统的一部分</p><p>存储系统核心目的是存储要运行的程序数据之类的</p><p>存储系统的设计目标可以归纳为3个问题</p><p>容量，速度，和成本之间的矛盾：</p><p>​三个目标不可能同时达到最优，要权衡利弊</p><p>​存取速度越快，每一位价格越高</p><p>​大容量就要降低速度</p><p>​高速度就要降低容量</p><p>解决方案：采用层次化的存储体系</p><p>换句话说 靠近CPU的，我们把他的存取速度加大，同时他的成本就会增加，容量就会减少</p><p>寄存器（CPU内）-》高速缓冲（Cache）-》内存-》磁盘-》磁带</p><p>从左到右，存取速度下降，存取容量增大</p><h2 id="1-1-内存管理目的"><a href="#1-1-内存管理目的" class="headerlink" title="1.1 内存管理目的"></a>1.1 内存管理目的</h2><p>​有效利用内存空间</p><p>​应用程序不必特别考虑内存的大小</p><p>​可以大于内存</p><h2 id="1-2-内存管理功能"><a href="#1-2-内存管理功能" class="headerlink" title="1.2 内存管理功能"></a>1.2 内存管理功能</h2><p>​记录内存的使用情况</p><p>​进程所占内存空间的分配与回收</p><p>​当内存不足时，采取相应措施</p><p>​内存空间的共享与保护</p><h1 id="2-程序的连接和装入"><a href="#2-程序的连接和装入" class="headerlink" title="2 程序的连接和装入"></a>2 程序的连接和装入</h1><h2 id="2-1-程序的连接"><a href="#2-1-程序的连接" class="headerlink" title="2.1 程序的连接"></a>2.1 程序的连接</h2><h3 id="2-1-1程序的连接的功能"><a href="#2-1-1程序的连接的功能" class="headerlink" title="2.1.1程序的连接的功能"></a>2.1.1程序的连接的功能</h3><p>多个目标文件及库文件连接成1个完整的可执行文件。</p><h3 id="2-1-2-程序连接的时机"><a href="#2-1-2-程序连接的时机" class="headerlink" title="2.1.2 程序连接的时机"></a>2.1.2 程序连接的时机</h3><p>静态连接：静态的，只连接1次，多次运行<br> 装入时连接：装入后是静态的<br> 实际运行时连接：调用时动态连接</p><h2 id="2-2-程序的装入"><a href="#2-2-程序的装入" class="headerlink" title="2.2 程序的装入"></a>2.2 程序的装入</h2><p>每个程序运行前，必须装入内存(为什么？这样存取速度才能匹配上CPU的速度)不一定一次性全部装入</p><p>装入方式有</p><h3 id="2-1-1-完全静态装入"><a href="#2-1-1-完全静态装入" class="headerlink" title="2.1.1 完全静态装入"></a>2.1.1 完全静态装入</h3><p>程序装入时不作任何修改。<br>即装入内存的每个字节与其可执行文件完全相同。</p><h3 id="2-1-2-静态重定位装入"><a href="#2-1-2-静态重定位装入" class="headerlink" title="2.1.2 静态重定位装入"></a>2.1.2 静态重定位装入</h3><p>程序装入时进行一次地址重定位，运行时不变。</p><p><strong>重定位</strong>是把汇编中的相对地址转换为内存中的实际地址</p><p><strong>相对地址:</strong><br>用户的程序经过汇编或编译连接后形成可执行代码，代码通常采用相对地址的形式，其首地址为0，指令中的地址都采用相对于首地址的偏移量。<br>机器是不能用相对地址在内存中读取信息的，必须用绝对地址<br><strong>绝对地址:</strong><br>内存中存储单元的实际地址</p><h3 id="2-1-3-动态重定位装入"><a href="#2-1-3-动态重定位装入" class="headerlink" title="2.1.3 动态重定位装入"></a>2.1.3 动态重定位装入</h3><p>真正<strong>执行到一条指令</strong>要访问某个内存地址时，才进行地址重定位。</p><p>一般设置1个重定位寄存器 存放当前进程在内存的起始地址<br> 绝对地址 &#x3D; 相对地址 + 重定位寄存器的值</p><h1 id="3-实存储器管理"><a href="#3-实存储器管理" class="headerlink" title="3 实存储器管理"></a>3 实存储器管理</h1><p>程序的大小不能超过可用内存空间的大小</p><p> 实实在在的 给我装进去哈哈哈</p><h2 id="3-1-连续分配"><a href="#3-1-连续分配" class="headerlink" title="3.1 连续分配"></a>3.1 连续分配</h2><p> 为每个进程分配连续的内存空间</p><h3 id="3-1-1-单一连续分配"><a href="#3-1-1-单一连续分配" class="headerlink" title="3.1.1 单一连续分配"></a>3.1.1 单一连续分配</h3><p>一般将内存划分为2个区：<br>     系统区：存放OS程序和数据<br>     用户区：存放用户程序和数据</p><p>如果是单一连续分配</p><p>内存中只存在1个用户程序。<br>     整个用户区为该程序独占！</p><p><strong>缺点：</strong></p><p>只能用于单用户、单任务OS。所以在现代操作系统肯定是不行的</p><h3 id="3-1-2-固定静态分区"><a href="#3-1-2-固定静态分区" class="headerlink" title="3.1.2 固定静态分区"></a>3.1.2 固定静态分区</h3><p>刚刚讲到的单一连续分配为什么不能多用户，多程序呢？</p><p>因为没有划分区域，不知道哪个用户或哪个程序该用哪一块内存</p><p><strong>改进</strong></p><p>所以固定分区进行划分区域操作</p><p>将内存的用户区预先划分为若干区域（分区）<br>分区个数和每个分区的大小是固定的<br>每个分区存放1个进程</p><p><strong>管理所需要的数据结构</strong></p><p>1个分区使用表（内存分配表），记录分区状态（比如区号id，分区大小，起始地址，状态是否被使用）</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223356489.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="管理所需的数据结构"></p><p><strong>缺点：</strong></p><p>(1) 当进程大小大于划分区域的时候，无法装入，<br>(2) 当进程大小小于划分区域的时候，存在内部碎片(Internal fragmentation)意味着会有内存资源的浪费<br>(3) 分区数目固定，使活动进程数目受限，比如划分十个区域，那么最多就是十个进程</p><p>所以也是不行的</p><h3 id="3-1-3-可变动态分区"><a href="#3-1-3-可变动态分区" class="headerlink" title="3.1.3 可变动态分区"></a>3.1.3 可变动态分区</h3><p>刚刚讲到的固定静态分区很差劲哦</p><p>原因在于很多东西都是固定的，比如分区数目，比如分区大小。</p><p>那么既然如此，我们就可以让他们“动”起来！</p><p><strong>改进</strong></p><p>动态分区<br>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化，既然如此我们需要一些数据结构进行记录</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223501062.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="动态分区图示"></p><p><strong>需要的记录的数据结构</strong></p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115223740827.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据结构"></p><p>动态分区有一个核心就是怎么去分配分区，所以有着一系列的分区分配算法</p><p><strong>分区分配算法</strong></p><p>① 最先适配法（first fit）<br>    空闲分区链（表）按地址递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>② 下次适配法（next fit）<br>    从上次分配的分区的下一个开始，选择第1个大小足够的分区</p><p>③ 最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><p>④ 最差适配法（worst fit）<br>    空闲分区链（表）按大小递减的次序排列<br>    从头开始，选择第1个分区（如果足够大）</p><p>后两种方法利用率更高，但是需要排序，开销会更大</p><p>分区给不同 进程分配出去了，当进程执行结束后，还需要将该进程的所在分区释放回收，这时候可能会产生一些碎片（因为没有比这些碎片小的进程放入的时候就会产生这些碎片</p><p>如何解决</p><p>1 内存紧凑（compaction）：集中小碎片为大分区</p><p> 但是涉及到程序在内存中的移动，开销很大</p><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231115224359347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="紧凑"></p><p>2 根本上是因为 我们上述讨论的一直都是连续分配，所以我们可以从根本上解决，提出离散分配，也就是下一章的重点！</p><h2 id="3-2-离散分配"><a href="#3-2-离散分配" class="headerlink" title="3.2 离散分配"></a>3.2 离散分配</h2><p>刚刚3.1我们讲到连续分配导致很多的碎片，所以我们可以进行离散分配，首先进程可以分为不同部分装入内存的不同分区</p><p>典型的离散分配方式，分页管理，分段管理</p><h3 id="3-2-1-分页管理"><a href="#3-2-1-分页管理" class="headerlink" title="3.2.1 分页管理"></a>3.2.1 分页管理</h3><p>（1）等分内存为物理块（或称页面，页框，page frame）<br>         物理块编号为0，1，2，．．．。<br>（2）进程的逻辑地址空间分为不同的页（page）<br>         页大小 &#x3D; 物理块大小<br>         页编号为0，1，2，．．．。<br>（3）内存分配原则：<br>         进程的1页可装入任一物理块</p><p>这里我们注意一下和固定分区的区别，固定分区一下子只能装入一整个程序（整个程序在内存中是连续的），而分页操作可以使得一个进程不同部分离散的存储在内存的不同位置！</p><p><strong>问题</strong></p><p>进程的最后1页可能装不满，产生“页内碎片”。</p><p><strong>管理的数据结构</strong></p><p>OS为每个进程建立1个页表（Page Table）<br>记录进程的页号和物理块号的对应关系</p><p><img src="/img/OS/image-20231115225502679.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115225502679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115225502679"></p><p><strong>地址转换</strong></p><p>逻辑地址 → 物理地址</p><p>我们给程序分页的时候 0，1,2,3 实际上是逻辑地址或者叫相对地址，只知道这个我们肯定不知道程序在内存中的哪里，所以我们还需要通过上图的页表转换为实际的物理地址</p><p>所以对于一个程序而言，我们要找到页表，那么我们怎么找到一个程序的页表呢？</p><p>通过<strong>页表寄存器</strong> 存放当前进程的页表起始地址和长度  每个进程的页表起始地址和长度平时放在其PCB（进程管理模块）中，调度时由OS放入PTR</p><p>注意的几点问题</p><p>（1）在这个过程中，需要选择页的大小</p><p>页小：碎片小，但页表占用空间大（因为页的数量会很多）</p><p>页大：页表小，但页内碎片大<br>通常，页的大小为2的整数次幂</p><p>所以需要对两者进行权衡</p><p>假设我们页大小为1KB&#x3D;1024B（$2^{10}&#x3D;1024$）则需要10位页内地址，假设逻辑地址是16位，第0-9位是页内地址，10-15位是页号</p><p>（2）进程的逻辑地址结构 ——及地址转换<br>   地址的高位部分为页号，低位部分为页内地址</p><p><img src="/img/OS/image-20231115230855467.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231115230855467.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231115230855467"></p><p>物理地址 &#x3D; 块号×页大小 + 页内地址</p><p>（3）引入快表</p><p>快表，又称联想存储器(Associative Memory) ： 具有并行查找能力的特殊高速缓存（cache）。<br>用途：保存当前进程的页表的子集（部分表项），比如最近访问过的页表项。<br> 当切换到新进程时，快表要刷新。</p><p>目的：提高地址转换速度</p><p>思考一个问题，加深我们对于该部分的理解</p><p>1  CPU要存取一个数据时，需要访问内存几次？</p><p>2次。<br> 第1次：访问页表，找到该页号P对应的物理块号，将此块号×页大小 与页内地址拼接形成物理地址；<br> 第2次：访问该物理地址，存取其中的指令或数据。</p><p>假设逻辑地址中，页号占20位，页内地址12位，则总共有$2^{20}$个页1M个页，如果每个页表项4B，光页表就占用4MB的空间</p><p>因而 页表本身可能占用相当大的内存空间，而且是连续的。</p><p>如何解决？</p><p>采用二级页表(只能解决连续，但解决不了占用较大的内存)</p><p>将页表进行分页，页大小 &#x3D; 物理块大小<br>  设置1个一级页表，多个二级页表<br>   一级页表：第i项记录第i号二级页表所在的物理块号<br>  二级页表：第i项记录第i页对应的物理块号<br>  系统设置１个页表寄存器，存放一级页表的起始地址和长度</p><p>二级页表并未减少页表所占的内存空间，但解决了页表的离散分配问题</p><h3 id="3-2-2-分段管理"><a href="#3-2-2-分段管理" class="headerlink" title="3.2.2 分段管理"></a>3.2.2 分段管理</h3><p>静态段式管理</p><p>按程序的逻辑划分为若干个程序段，每一个段连续，且各个段的长度不要求相等</p><p>段号从0开始</p><p>分段类似于可变分区，但不同之处在于：<br>       一个进程可占据多个分区，而且分区之间不要求连续<br>分段无内部碎片，但有外部碎片。</p><p>（2）内存分配原则</p><p>以段为单位，各段不要求相邻</p><p>我们刚刚讲到的分页管理类似于固定分区，现在的分段管理则类似于可变分区，不同之处在于分区之间不要求连续。</p><p><strong>管理需要的数据结构</strong></p><p>OS为每个进程建立1个段表（Segment Table）<br>每个段在段表中有1项，记录该段在内存中的基址和长度</p><p><img src="/img/OS/image-20231116093449579.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231116093449579.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231116093449579"></p><p>分段分页比较</p><p>（1）分页对程序员是不可见的；分段通常是可见的，并作为组织程序和数据的手段提供给程序员；<br>（2）页的大小由系统确定，段的大小由用户程序确定；<br>（3）分段更利于多个进程共享程序和数据；<br>（4）分段便于实现动态链接;<br>（5）分页可有效提高内存利用率，分段可更好地满足用户需要。</p><h3 id="3-2-3-分页分段管理"><a href="#3-2-3-分页分段管理" class="headerlink" title="3.2.3 分页分段管理"></a>3.2.3 分页分段管理</h3><p> 动机：结合分段和分页的优点，克服二者的缺点。</p><p>进程分段——同段式管理<br>每段分页，内存分块，内存以块为单位分配——同页式管理</p><p>进程的逻辑地址结构</p><p>由段号、页号和页内地址构成</p><p><strong>管理需要的数据结构</strong></p><p>每个进程有一个段表</p><p>记录每个段对应的页表的起始地址和长度</p><p>每个段有一个页表</p><p>记录该段所有页号与物理块的关系</p><p>CPU要存取一个数据时，需要访问3次内存。</p><p>第1次：访问段表，获得该段的页表地址；<br>第2次：访问页表，取得物理块号，形成物理地址；<br>第3次：访问该物理地址，存取其中的指令或数据。</p><p>实存储管理模式下，怎么提高运行程序的大小</p><p><strong>覆盖</strong></p><p>把程序划分为若干个功能上相对独立的程序段（称为覆盖块），按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域；</p><p>覆盖块存放在磁盘上，当一个程序段执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）</p><p>   (1)  要求程序员划分程序，提供一个明确的覆盖结构；<br>   (2) 增加了编程的复杂度。<br>   (3) 增加执行时间，从外存装入覆盖模块，时间换空间<br>    对用户不透明，增加了用户负担。</p><p>所以更好的方式是虚拟存储管理</p><h1 id="4-虚拟存储管理"><a href="#4-虚拟存储管理" class="headerlink" title="4 虚拟存储管理"></a>4 虚拟存储管理</h1><p>进程的大小可以超过可用物理内存的大小，<br>由OS把当前用到的那部分留在内存，其余的放在外存中。</p><p>几个概念</p><p> 虚拟地址：程序中使用的地址。进程的虚拟地址从0开始。<br> 物理地址：可寻址的内存实际地址<br> 虚拟地址空间：虚拟地址的集合<br> 物理地址空间：实际的内存空间</p><p>交换技术</p><p>将当前要使用的那部分程序或数据装入内存，将暂时不用的放在磁盘上，待需要时再装入。</p><p>交换是虚拟存储器设计的基础，最初的交换是针对整个进程的交换</p><h2 id="4-1-分页-虚拟存储"><a href="#4-1-分页-虚拟存储" class="headerlink" title="4.1 分页+虚拟存储"></a>4.1 分页+虚拟存储</h2><p>在进程开始运行之前，不是装入全部页，而是装入部分或0个页，之后根据进程运行的需要，动态装入其它页；<br>当内存空间已满，而又需要装入新的页时，则根据某种算法淘汰某个页，以便装入新的页。</p><p><img src="/img/OS/image-20231117222116973.png" class="lazyload placeholder" data-srcset="/img/OS/image-20231117222116973.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117222116973"></p><p>除了页号和物理块号外，需要增加下列字段：</p><p> 有效位（状态）：表示该页是否在内存中<br>1 表示该页位于内存中，该页表项是有效的，可以使用<br>0表示该页当前在外存中，访问该页表项将导致缺页异常</p><p> 修改位M：表示该页在装入内存后是否被修改过<br>在有效位为1的情况下有效的情况下<br>用于回收该物理页面时，据此判断是否要把它的内容写回外存</p><p> 访问位A（访问字段）：记录该页最近是否被访问过<br>用于页面置换算法</p><p>  保护位：表示该页的允许访问方式<br>只读、可读写、可执行等</p><p> 外存地址：该页在磁盘上的地址</p><p>由于访问的页可能不在内存，所以需要</p><p>报告不在内存——缺页中断处理</p><p>将页从外存读入内存——页的换入换出</p><h3 id="4-1-0-缺页中断处理"><a href="#4-1-0-缺页中断处理" class="headerlink" title="4.1.0 缺页中断处理"></a>4.1.0 缺页中断处理</h3><p>1  保护当前进程现场；<br>2  根据页表中给出的外存地址，在外存中找到该页；<br>3  若内存中无空闲物理块，则选择1页换出；<br>4  分配一个空闲物理块，将新调入页装入内存；<br>5  修改页表中相应表项的状态位及相应的物理块号，修改空闲物理块表（链）；<br>6  恢复现场。</p><h3 id="4-1-1-页的换入换出"><a href="#4-1-1-页的换入换出" class="headerlink" title="4.1.1 页的换入换出"></a>4.1.1 页的换入换出</h3><p>页的换入换出涉及到</p><p>如何给进程分配物理块——页的分配策略</p><p>在什么范围内选择淘汰页——页的置换策略</p><p>页该怎么调入——页的调入策略</p><p>该选择哪些页被换出去——页的置换算法</p><p><strong>1）页的分配策略</strong>：为每个进程分配多少个物理块</p><p> 固定分配<br>    为每个进程分配的总物理块数固定，在整个运行期间不变。</p><p>可变分配<br>    先为每个进程分配一定数目的物理块，OS自身维持一个空闲物理块队列。<br>    当发生缺页时，由系统分配一个空闲块，存入调入的页；</p><p><strong>2）页的置换策略</strong>：在什么范围内选择淘汰页<br> 局部置换<br>只从缺页进程自身选择淘汰页<br>全局置换<br>从整个内存中选择淘汰页    当无空闲块时，才会换出。</p><p><strong>3）页的调入策略</strong><br>① 何时调入<br> 请求调页（demand paging）<br>    只有访问的页不在内存中时，才会调入该页。<br> 预调页（prepaging）<br>    一次调入多个连续的页。为什么这样做？<br>② 从何处调入：文件区（可执行文件）、交换区<br> 全部从交换区调入<br>    进程创建时，全部从文件区拷贝到交换区。<br> 首次调入从文件区，以后从交换区</p><p><strong>4）页的置换算法</strong></p><p>选择换出页 减少缺页率</p><ul><li><strong>最优置换算法 OPT</strong></li></ul><p>​淘汰以后永不使用的，或者过最长时间才会被访问的页</p><p>​因为无法预测将来，所以不好实现</p><ul><li><strong>先进先出置换算法 FIFO</strong></li></ul><p>​只需把进程中已调入内存的页，按先后次序链成一个队列即可；链首最长，链尾最短；出现缺页时，选择链首页面进行置换，新页面加到链尾。</p><p>​优点：开销较小，实现简单。<br>​缺点：<br>       ① 它与进程访问内存的动态特性不相适应；有可能调出的页面可能是经常访问的<br>       ② 会产生belady现象。即：当分配给进程的物理块数增加时，有时缺页次数反而增加。</p><ul><li><strong>最近最久未使用算法 LRU</strong></li></ul><p>淘汰最近一次访问距当前时间最长的页。<br>即淘汰未使用时间最长的页<br>关键：如何快速地判断出哪一页是最近最久未使用的。<br>算法较好，但实现代价高。</p><p>实现方法</p><p>方法一：计时器</p><p>​对于每一页增设一个访问时间计时器</p><p>​每当某页被访问时，当时的绝对时钟内容被拷贝到对应的访问时间计时器中，这样系统记录了内存中所有页最后一次被访问的时间。<br>  淘汰时，选取访问时间计时器值最小的页。</p><p>方法二：移位寄存器</p><p>​为内存中的每一页配置一个移位寄存器<br>  当访问某页时，将相应移位寄存器的最高位置1<br>  每隔一定时间，寄存器右移1位<br>  淘汰寄存器值最小的页。</p><p>方法三：栈</p><p>​  每次访问某页时，将其页号移到栈顶。使得栈顶始终是最近被访问的页，<br>  栈底是最近最久未用的。</p><p>以上的最近最久未使用算法核心需要判断最久，开销较大</p><p>所以我们提出一个近似，最近未使用算法NRU</p><ul><li><strong>最近未使用算法 NRU 也叫做CLOCK算法</strong></li></ul><p>实现方法</p><p>页表中设置一个访问位，当访问某页时，将访问位置1<br>将内存中的所有页链成一个循环队列<br>从上次换出页的下一个位置开始扫描<br>在扫描过程中，将访问位&#x3D;1的页清0，直到遇到访问位&#x3D;0的页，淘汰该页，并将指针指向下一页</p><p>改进：</p><p>该算法的提出基于如下考虑：<br>① 对于已修改的页，换出时必须重新写回到磁盘上。因此，优先选择未访问过、未修改过的页换出；<br>② 淘汰一个最近未访问的已修改页要比淘汰一个被频繁访问的“干净”页好。</p><p>所以按照下面的顺序进行淘汰</p><p>第1类：A &#x3D; 0，M &#x3D; 0：未访问，未修改；最佳淘汰页<br>第2类：A &#x3D; 0，M &#x3D; 1：未访问，已修改<br>第3类：A &#x3D; 1，M &#x3D; 0：已访问，未修改；有可能再次访问<br>第4类：A &#x3D; 1，M &#x3D; 1：已访问，已修改</p><p>算法</p><p>① 找第1类页，将遇到的第1个页作为淘汰页；<br>② 若查找1周后未找到第1类页，则寻找第2类页，并将扫描经过的页的访问位清0。将遇到的第1个页作为淘汰页；<br>③ 否则，转①、②，一定能找到淘汰页。</p><ul><li><strong>最少使用算法 LFU</strong></li></ul><p>选择最近访问次数最少得页淘汰</p><p> 通常不直接利用计数器来记录页的访问次数，而是采用移位寄存器R。<br>  类似于LRU算法，每次访问某页时，将其移位寄存器的最高位置1。每隔一定时间将移位寄存器右移1位。</p><p>这样，在最近一段时间内使用次数最少的页就是移位寄存器各位之和最小的页。</p><p>往往配合页缓冲算法，提高LFU的效率</p><p>基本方法 设置两个空闲链表 空闲页链表，已修改页链表</p><p>① 若淘汰页未修改，则直接放入空闲页链表，否则放入已修改页链表；<br>② 当已修改页达到一定数量时，再将其一起写回磁盘，即成簇写回，以减少I&#x2F;O操作的次数。</p><p>缺页率对于虚拟存储来说非常重要</p><p>因为缺页导致的中断处理相对处理时间也比较长</p><p>前面进程没有考虑进程对内存块需求的差异性，有可能给进程多增加一个物理页面，就会导致缺页率大幅度下降</p><p>所以全局置换算法可能效果更好，为进程分配可变数目的物理页面，经典的算法有工作集</p><ul><li>工作集置换算法</li></ul><p>1 基本思想</p><p> 根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页，这些页称为活动页。<br>    如果分配给一个进程的物理块数太少了，使该进程所需的活动页不能全部装入内存，则进程在运行过程中将频繁发生缺页中断。<br>    如果能为进程提供与活动页数相等的物理块数，则可减少缺页中断次数。</p><p> 首先什么是工作集</p><p>一个进程在时刻t、参数为△的工作集W(t, △)，表示该进程在过去的△个时间单位中被访问到的页的集合。△称为工作集的窗口大小。</p><p>工作集大小的三个因素</p><p>   访页序列特性<br>   时刻t<br>   观察该进程的时间窗口大小(△)</p><p>实现方法：</p><p>访存链表：维护窗口内的访存页面链表<br>访存时，换出不在工作集的页面；更新访存链表<br>缺页时，换入页面；更新访存链表</p><h2 id="4-2-分段-虚拟存储"><a href="#4-2-分段-虚拟存储" class="headerlink" title="4.2 分段+虚拟存储"></a>4.2 分段+虚拟存储</h2><p>要比虚拟页式管理复杂一些</p><p>会有缺段中断</p><h2 id="4-3-段页-虚拟存储"><a href="#4-3-段页-虚拟存储" class="headerlink" title="4.3 段页+虚拟存储"></a>4.3 段页+虚拟存储</h2><p>涉及缺段中断、缺页中断。<br>注意的是，对于缺段中断处理，主要是在内存中建立该段的页表，而非调入完整的一段。</p><p>影响缺页次数的因素</p><p>（1）分配给进程的物理块数<br>    一般来说，进程的缺页中断率与进程所占的内存块数成反比。<br>    分配给进程的内存块数太少是导致抖动现象发生的最主要原因。<br>（2）页的大小<br>     缺页中断率与页的大小成反比，但页的大小也不能一味地求大，它一般在0.5KB~4KB之间，是个实验统计值。因为页大时，页表较小，占空间少，查表速度快，缺页中断次数少，但页内碎片较大。页小时，恰恰相反。<br>（3）程序的编写方法<br>    进程的缺页中断率与程序的局部性（包括时间和空间局部性）程度成反比。<br>     用户程序编写的方法不合适可能导致程序运行的时空复杂度高，缺页次数多。<br>（4）页置换算法<br>    算法不合理会引起抖动。</p><p>页式管理</p><p><strong>页</strong></p><p>相对物理块来说，页是逻辑地址空间（<a href="https://link.zhihu.com/?target=http://www.tomorrow.wiki/tag/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">虚拟内存</a>空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB。</p><p>例如：一个 32 位的<strong>操作系统</strong>，页的大小设为 2^12&#x3D;4Kb，那么就有页号从 0 编到 2^20 的那么多页逻辑空间。</p><p>段式管理</p><p>段页式管理</p><p>段页</p><p>虚拟内存</p><p>​让用户感觉像是在分段，但实际上是分页管理</p><p>$命中率h&#x3D;\frac{N_c}{N_c+N_m}$</p><p>其中$N_c$为Cache完成存取的总次数，$Nm$表示主存完成存取的次数</p><p>页框是什么</p><p><strong>高级调度：</strong></p><p>​功能：调度对象是作业。其主要功能是根据某种算法，其选择从就绪队列中选择哪个进程进入内存执行，以便后续的执行。决定从外存中处于后备队列中的哪几个作业调入内存，为创建进程、分配必要的资源。</p><p>​关系：高级调度与中级调度之间的关系是，高级调度将作业从后备队列中选择并将它们加载到内存中，然后中级调度负责将这些作业分配给可运行队列。高级调度与低级调度之间的关系是，它确定了哪些进程将被带入内存，以供后续的执行。</p><p><strong>中级调度：</strong></p><p>又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。</p><p>​功能：中级调度的主要任务是管理内存中的进程。它可以将某些进程从内存中暂时移出，以便为其他进程腾出空间，以减轻内存压力，提高内存利用率和系统吞吐量。</p><p>​关系：中级调度与高级调度之间的关系是，它接受高级调度分配的作业，将它们加载到内存中，并可以在必要时将它们暂时移出内存。中级调度还与低级调度之间有关，因为它可以调整进程的内存分布，以优化系统性能。</p><p><strong>低级调度：</strong></p><p>​功能：低级调度是最频繁的调度级别，其任务是从就绪队列中选择下一个要执行的进程。它控制着CPU的分配，决定哪个进程将在CPU上执行，以确保公平性和性能。</p><p>​关系：低级调度与高级调度之间的关系是，它执行高级调度选择的进程，将其分配给CPU执行。它还与中级调度之间有关，因为中级调度可能会将某些进程暂时移出内存，而低级调度负责在需要时将它们带回内存。</p><p>慢表（Page）：页表、段表存放在主存中，收到虚拟地址后要先访问主存，査询页表、段表，进行虚实<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">地址转换</a>。</p><p>快表（TLB）：提高变换速度→用高速缓冲存储器存放常用的页表项（注意不是放在内存的）</p><p>假设某计算机硬件提供了动态重定位寄存器和地址越界检查，现在为计算机涉及一个操作系统的内存管理方案，支持多进程并发执行,且不大于内存空间大小的进程可以装入内存执行</p><p>（1）阐述方案的设计思路</p><p>由于该计算机需要多进程并发执行，所以可以采用可变动态分区的方法进行内存管理，同时计算机只需要装入不大于内存的进程，所以可以采用实存储器管理方案。</p><p>综上所述可以采用 实存储器管理的可变动态分区的方案进行管理</p><p>开始时只有1个空闲分区，随着进程的装入和退出，分区的个数和每个分区的大小、位置会动态变化</p><p>（2）管理所需要的数据结构</p><p>1 空闲分区表  记录开始地址，长度，以及状态（是否分配）</p><p>2 已分配分区表   记录开始地址，长度，以及进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">free_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> start_address; <span class="comment">//开始地址</span></span><br><span class="line">        <span class="type">double</span> length; <span class="comment">//长度</span></span><br><span class="line">    <span class="type">double</span>  state; <span class="comment">//状态（是否分配）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">used_list_queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> id;<span class="comment">//进程号</span></span><br><span class="line">    <span class="type">double</span> start_address;<span class="comment">//开始地址</span></span><br><span class="line">    <span class="type">double</span> length;<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）为了尽可能的避免产生碎片，我决定采用最佳适配法</p><p>最佳适配法（best fit）<br>    空闲分区链（表）按大小递增的次序排列<br>    从头开始，选择第1个大小足够的分区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assignment memory&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">length</span>(free_list_queue)!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">sort</span>(free_list_queue);<span class="comment">//对空闲列表进行排序</span></span><br><span class="line">best=<span class="built_in">check</span>(free_list_queue,process_memory)<span class="comment">//遍历空闲列表，找到第一个足够大小的分区</span></span><br><span class="line"><span class="built_in">fill_memory</span>(best,process)<span class="comment">//将进程放入该分区</span></span><br><span class="line"><span class="keyword">delete</span> free_list_queue[best] <span class="comment">//更新空闲列表</span></span><br><span class="line">        add <span class="built_in">used_list_queue</span>(prcess,best)<span class="comment">//更新已使用的列表</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">    置换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软中断和硬中断区别</p><p>总体而言，硬中断和软中断都是计算机系统中用于处理异步事件的机制，但它们的触发方式和处理方式有所不同。硬中断是由外部硬件设备触发的，而软中断是由软件程序主动发起的。</p><p>看到网上的一个比喻我觉得非常恰当：</p><p>你在屋里打电话，这时候响起了敲门声，你可以去处理敲门声，也可以不理会继续打电话，这是软中断。但是如果电话线断了，你必须停止打电话，这是硬中断</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）进程管理下</title>
      <link href="/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/"/>
      <url>/2023/10/17/Computer_system/Os/3%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126202016655.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="进程管理下总览图"></p><p>进程之间的同步和互斥</p><p>同步，是指一个某一步的执行必须需要等待其他操作完成之后</p><p>互斥，是指一个进程的某一块只能有一个进程访问</p><h1 id="6-经典进程同步问题"><a href="#6-经典进程同步问题" class="headerlink" title="6.经典进程同步问题"></a>6.经典进程同步问题</h1><h2 id="6-1-生产者-消费者问题-既有同步又有互斥"><a href="#6-1-生产者-消费者问题-既有同步又有互斥" class="headerlink" title="6.1 生产者-消费者问题 (既有同步又有互斥)"></a>6.1 生产者-消费者问题 (既有同步又有互斥)</h2><p><strong>问题描述</strong></p><p>生产者往缓冲区写数据，满了的话就不能写了</p><p>消费者从缓冲区取数据，空的话就不能取了</p><p>一次只能有一个生产者或消费者取读数据</p><p><strong>问题分析</strong></p><p>核心解决</p><p>（1）不能向满的缓存区写数据，否则的话必须等待（同步关系）</p><p>（2）不能向空的缓存区取数据，否则的话必须等待（同步关系）</p><p>（3）任何时刻，仅允许一个1个生成者或1个消费者访问</p><p>意味着消费者之间互斥，生成者之间互斥，消费者和生产者之间互斥，总结来说就是任意两个进程之间对缓冲区操作的时候，其他进程不能操作 （互斥关系）</p><p>full：记录缓冲区中非空的槽数，初始值&#x3D;0</p><p>empty：记录缓冲区中空的槽数，初始值&#x3D;N</p><p>mutex：确保进程不同时访问缓冲区，初始值&#x3D;1</p><p>解决（1）（2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void producer(void)&#123;</span><br><span class="line">while (True) &#123;</span><br><span class="line">        produce(); //生产1项</span><br><span class="line">        P(empty); //申请1个空槽</span><br><span class="line">        P(mutex); //请求进入临界区</span><br><span class="line">        append(); //加入缓冲区</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(full); //递增非空槽</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void)&#123;</span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">        P(full); //申请1个非空槽</span><br><span class="line">        P(mutex); //申请进入临界区</span><br><span class="line">        remove(); //从缓冲区移出1项</span><br><span class="line">        V(mutex); //离开临界区</span><br><span class="line">        V(empty); //递增空槽数</span><br><span class="line">        consume(); //消费数据</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2-读者-写者问题"><a href="#6-2-读者-写者问题" class="headerlink" title="6.2 读者-写者问题"></a>6.2 读者-写者问题</h2><p><strong>问题描述</strong></p><p>多个Reader进程，多个Writer进程，共享文件F<br>要求：<br>  允许多个Reader进程同时读文件<br>  不允许任何一个Writer进程与其他进程同时访问（读或写）文件</p><p><strong>问题分析</strong></p><p>​写者之间要互斥</p><p>​读者和写者之间互斥</p><p>​读者之间不互斥</p><p>所以核心是我们要在第一个读者进来的时候，进行判断是否有写者正在写</p><p><strong>标答</strong></p><p>write</p><p>WriteMutex &#x3D; 0  读写操作的互斥访问<br>Rcount &#x3D; 0 正在读操作的读者数目<br>CountMutex &#x3D; 0 读者计数的互斥访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (True) &#123;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line">  <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">     ++Rcount;</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line">     read;</span><br><span class="line"><span class="built_in">P</span>(CountMutex);</span><br><span class="line"> --Rcount;</span><br><span class="line">      <span class="keyword">if</span> (Rcount == <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"><span class="built_in">V</span>(CountMutex);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (True) &#123;</span><br><span class="line">    <span class="built_in">P</span>(WriteMutex);</span><br><span class="line">        write;</span><br><span class="line">    <span class="built_in">V</span>(WriteMutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-哲学家进餐问题"><a href="#6-3-哲学家进餐问题" class="headerlink" title="6.3 哲学家进餐问题"></a>6.3 哲学家进餐问题</h2><p><strong>问题描述</strong></p><p>有5个哲学家围坐在一张圆桌周围，每个哲学家面前有1碗饭，左右各1把叉子。<br>哲学家有两种活动：思考和吃饭。<br>只有拿到左右两把叉子才能吃饭。<br>吃饭后，放下叉子，继续思考。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5个信号量，分别用于对5个叉子互斥</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  5 <span class="comment">//哲学家数</span></span></span><br><span class="line">Semaphore_t  fork[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span> <span class="params">(<span class="type">int</span> i)</span> <span class="comment">//i是哲学家编号：0~N-1  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)  &#123;</span><br><span class="line">        <span class="built_in">think</span>(); </span><br><span class="line">        <span class="built_in">P</span>(fork[i]); </span><br><span class="line">        <span class="built_in">P</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">        <span class="built_in">eat</span>(); </span><br><span class="line">        <span class="built_in">V</span>(fork[i]); </span><br><span class="line">        <span class="built_in">V</span>(fork[(i+<span class="number">1</span>) % N]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-进程之间通信"><a href="#7-进程之间通信" class="headerlink" title="7.  进程之间通信"></a>7.  进程之间通信</h1><p>P,V操作实现的是进程之间的低级通信，所以P,V操作是低级通讯原语，即不能传递大量的信息</p><p>所以我们引入进程间高级通讯方式</p><h2 id="7-1-共享存储区"><a href="#7-1-共享存储区" class="headerlink" title="7.1 共享存储区"></a>7.1 共享存储区</h2><p>相互通信的进程间设有公共的内存区，每个进程既可向该公共内存中写，也可从公共内存中读，通过这种方式实现进程间的信息交换。<br>      把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p><h2 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h2><p> 源进程发送消息，目的进程接受消息。所谓消息，就是一组数据。</p><p>（1）消息队列（message Queue）或消息缓冲<br>    发送者发消息到一个消息队列中；<br>    接收者从相应的消息队列中取消息。<br>    消息队列所占的空间从系统的公用缓冲区中申请得到。<br>（2）邮箱（mailbox）<br>  发送者发消息到邮箱，接收者从邮箱取消息。<br>  邮箱是一种中间实体，一般用于非实时通信。</p><h2 id="7-3-管道"><a href="#7-3-管道" class="headerlink" title="7.3 管道"></a>7.3 管道</h2><p>首创于Unix。用于连接一个读进程、一个写进程，以实现它们之间通信的共享文件，称为pipe文件。</p><p>管道分为下列2种：<br> 有名管道<br> 无名管道</p><h1 id="8-线程"><a href="#8-线程" class="headerlink" title="8.线程"></a>8.线程</h1><p>为什么引入线程</p><p>线程是进程的１条执行路径。方便进程内部的同步操作，线程之间共享内存</p><p>比如，一个文字输入软件，其内部可以有三个线程，一个用来加载视频、一个用来播放视频，一个用来备份。因为进程之间不共享内存，所以不能用多个进程来实现这时就用多线程可以解决。线程之间共享内存，所以从一个线程切换到另一个线程不需要陷入内核，也不需要切换上下文，线程之间的切换比进程切换快捷。</p><p>　1个进程可以有多个线程，其中至少有1个主线程（primary thread）。</p><p>　1个进程内的多个线程在同一个地址空间内（共享该进程的地址空间）。</p><p>每个线程有自己的线程控制块TCB（Thread Control Block），包含自己的堆栈和状态信息。TCB比PCB小得多。</p><h2 id="8-1-线程的实现机制"><a href="#8-1-线程的实现机制" class="headerlink" title="8.1 线程的实现机制"></a>8.1 线程的实现机制</h2><p>用户级线程</p><p>​由在用户空间执行的线程库来实现，OS对此一无所知。　<br>线程库提供线程创建、撤消、上下文切换、通信、调度等功能。</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是进程为单位的，容易阻塞</p><p>​但是性能高，无需陷入内核</p><p>核心级线程</p><p>​用户级线程是自己实现的线程创建，删除</p><p>​但是这样的话操作系统分配的是线程为单位的</p><p>​但是性能低，需要陷入内核</p><h1 id="9-进程调度"><a href="#9-进程调度" class="headerlink" title="9 进程调度"></a>9 进程调度</h1><p>为什么进程调度</p><p>多个进程就绪时候，OS决定先执行哪一个</p><p>我们进程调度要达到的目的</p><p>​CPU利用率高，吞吐量大，周转时间少，等待时间短，公平</p><p>​很多时候都是在权衡！很多时候很难兼顾所有的目的</p><p>什么时候会切换进程呢？</p><p>​硬件中断，进程异常，或者该进程请求IO，这些都会让CPU闲下来，我们就要给CPU找活干了</p><p>一些概念</p><ul><li>周转时间 &#x3D; 作业完成时刻 - 作业到达时刻</li><li>带权周转时间 &#x3D; 周转时间 &#x2F; 服务时间</li><li>平均周转时间 &#x3D; 作业周转总时间 &#x2F; 作业个数</li><li>平均带权周转时间 &#x3D; 带权周转总时间 &#x2F; 作业个数</li></ul><h2 id="9-1-调度方式"><a href="#9-1-调度方式" class="headerlink" title="9.1 调度方式"></a>9.1 调度方式</h2><p>非抢占方式</p><p>​一旦某进程被调度，直到完成或因某事件而阻塞，才会切换到其他进程</p><p>抢占方式</p><p>​允许暂停正在运行的进程，切换到其他进程</p><p>抢占原则：</p><p>​时间片原则：时间片到时抢占</p><p>​优先级原则：优先级高者到时抢占</p><h2 id="9-2-常见算法"><a href="#9-2-常见算法" class="headerlink" title="9.2 常见算法"></a>9.2 常见算法</h2><h3 id="9-2-1-先来先服务-FCFS"><a href="#9-2-1-先来先服务-FCFS" class="headerlink" title="9.2.1 先来先服务  FCFS"></a>9.2.1 先来先服务  FCFS</h3><p><strong>方法</strong></p><p>按照进程就绪的先后次序来调度进程，非抢占式方式</p><p><strong>优点</strong>：实现简单</p><p><strong>缺点</strong>:<br>    （1）平均等待时间波动很大<br>              短进程、长进程到达时间是随机的<br>    （2）有利于CPU繁忙型进程，不利于I&#x2F;O繁忙型进程<br>    （3）有利于长进程，不利于短进程</p><h3 id="9-2-2-短进程优先-SPN"><a href="#9-2-2-短进程优先-SPN" class="headerlink" title="9.2.2 短进程优先 SPN"></a>9.2.2 短进程优先 SPN</h3><p><strong>方法：</strong></p><p>  选择估计运行时间最短的进程运行。<br>短进程优先算法具有最优平均周转时间</p><p><strong>优点</strong>：</p><p>  平均等待时间较短</p><p><strong>缺点</strong></p><p>  对长进程（作业）不利。<br>  极端情况下，会使长进程（作业）得不到调度。</p><p>所以在这个上面的改进提出最高响应比算法</p><h3 id="9-2-3-最高相应比优先算法"><a href="#9-2-3-最高相应比优先算法" class="headerlink" title="9.2.3 最高相应比优先算法"></a>9.2.3 最高相应比优先算法</h3><p><strong>方法</strong></p><p>选择就绪队列中相应比R值最高的进程<br>     R &#x3D; （W + S）&#x2F; S<br>             W: 等待时间（waiting time）<br>             S: 执行时间（service time）</p><p>短进程优先算法：长进程等待的时间而出现饥饿<br>  对于最高响应优先算法，如果等待时间越长，则R会越大，在一定程度上避免了长进程出现饥饿的情况</p><p>但上面的两种方法都得估计进程运行的时间，这个预测未来比较难</p><p>另外计算开销比较大，所以应用比较少</p><h3 id="9-2-4-时间片轮转-RR"><a href="#9-2-4-时间片轮转-RR" class="headerlink" title="9.2.4 时间片轮转 RR"></a>9.2.4 时间片轮转 RR</h3><p><strong>方法</strong></p><p> 将所有的就绪进程按FCFS原则排成一个队列，<br>    规定一个时间片为进程每次使用CPU的最长时间，<br>    每次选择队首进程运行，<br>    当时间片到时，剥夺该进程的运行，将其排在队尾</p><h3 id="9-2-5-基于优先级的调度"><a href="#9-2-5-基于优先级的调度" class="headerlink" title="9.2.5 基于优先级的调度"></a>9.2.5 基于优先级的调度</h3><p><strong>方法</strong></p><p>每个进程一个优先级；<br>总是选择就绪队列中优先级最高的进程投入运行；<br>可以是抢占式，或非抢占式。</p><h3 id="9-2-6-多级反馈队列"><a href="#9-2-6-多级反馈队列" class="headerlink" title="9.2.6 多级反馈队列"></a>9.2.6 多级反馈队列</h3><p><strong>方法</strong></p><p>(1) 按优先级设置n(n&gt;1)个就绪队列，每个队列赋予不同优先级。如第一级队列到最后一级队列，优先级依次降低。<br>(2) 优先级越高队列，分配的时间片越小。<br>(3) 每个队列按照先来先服务原则排队。<br>(4) 一个新进程就绪后进入第一级（或相应优先级）队尾。<br>(5) 调度方法<br>每次选择优先级最高队列的队首进程运行；<br>若被调度进程的时间片到，则放入下一级队列的队尾；<br>最后一级队列采用时间片轮转；<br>当有一个优先级更高的进程就绪时，可以抢占CPU，被抢占进程回到原来队列的末尾。</p><p>该算法综合了前面几种算法的优点。<br>  既考虑了先来先服务，又照顾了长进程；<br>  既考虑了优先级，又讲求公平。</p><h1 id="10-进程死锁"><a href="#10-进程死锁" class="headerlink" title="10 进程死锁"></a>10 进程死锁</h1><h2 id="10-1-基本概念"><a href="#10-1-基本概念" class="headerlink" title="10.1 基本概念"></a>10.1 基本概念</h2><p>第一个概念死锁</p><p><strong>死锁</strong></p><p>什么是死锁呢？</p><p>一个进程集合中的每个进程都在等待只能由该集合中的其它进程才能引发的事件，这种状态称作死锁。<strong>一组竞争系统资源的进程由于相互等待而出现“永久”阻塞</strong>。</p><p>例如，2个进程A、B，都需要资源R1、R2</p><p>若A：拥有R1，申请R2</p><p>若B：拥有R2，申请R1</p><p>如何？</p><p>第二个概念资源的基本分类</p><p><strong>资源分类</strong></p><p><strong>可重用资源</strong></p><p>资源不能被删除且在任何时刻只能有一个进程使用</p><p>进程释放资源后，其他进程可重用</p><p>例如：处理器，I&#x2F;O通道等等</p><p>可能出现的死锁</p><p>每个进程占用一部分资源并请求其他资源</p><p><strong>消耗资源</strong></p><p>资源创建和销毁过程</p><p>例如：在I&#x2F;O缓冲区的中断、信号和消息等</p><p> 可能出现的死锁</p><p>进程间相互等待接收对方的消息</p><h2 id="10-2-什么情况产生死锁"><a href="#10-2-什么情况产生死锁" class="headerlink" title="10.2 什么情况产生死锁"></a>10.2 什么情况产生死锁</h2><p>四个必要条件</p><p>1）互斥条件<br>   每个资源要么被分配给了1个进程，要么空闲<br>2）占有及等待（部分分配）条件<br>   已经得到了资源的进程要申请新的资源<br>3）不可剥夺条件<br>   已经分配给一个进程的资源不能被剥夺，只能由占有者显式释放<br>4）环路等待条件<br>   存在由2个或多个进程组成的一条环路，<br>   该环路中的每个进程都在等待相邻进程占有的资源</p><h2 id="10-3-死锁前—检测死锁"><a href="#10-3-死锁前—检测死锁" class="headerlink" title="10.3 死锁前—检测死锁"></a>10.3 死锁前—检测死锁</h2><p>一 由OS处理</p><p>​1 检测死锁并恢复</p><p>​2 分配资源时避免死锁</p><p>​3 假装没看见（鸵鸟策略）：多数OS对待死锁的策略，那死锁了怎么办，开机重启</p><p>二 由应用程序本身预防死锁</p><p>实际中检测死锁恢复是可能的，但是代价太大</p><h3 id="10-3-1-死锁检测"><a href="#10-3-1-死锁检测" class="headerlink" title="10.3.1 死锁检测"></a>10.3.1 死锁检测</h3><p>方法一 资源分配图</p><p>看看有没有环，有环的话有没有无法释放的情况</p><p>方法二 矩阵</p><h3 id="10-3-2-何时检测"><a href="#10-3-2-何时检测" class="headerlink" title="10.3.2 何时检测"></a>10.3.2 何时检测</h3><p>1）每当有资源请求时；</p><p>2）周期性检测；</p><p>3）每当CPU的使用率降到某一阈值时。</p><p>死锁检测会占用大量的CPU时间</p><h2 id="10-4-死锁前—死锁避免"><a href="#10-4-死锁前—死锁避免" class="headerlink" title="10.4 死锁前—死锁避免"></a>10.4 死锁前—死锁避免</h2><p><strong>银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定金额的贷款，而他知道不可能所有客户同时都需要最大的贷款额。在这里，我们可将客户比作进程，银行家比作操作系统。银行家算法就是对每一个客户的请求进行检查，检查如果满足它是否会引起不安全状态。如果是，则不满足该请求；否则，便满足。</p><p><strong>使得死锁四个条件有一个不成立</strong></p><p>1 破坏互斥条件   对资源统一管理，如SPOOLing技术</p><p>2 破坏不可剥夺条件 当进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源。</p><p>3 破坏占有及等待条件  原子性地获得所需全部资源。</p><p>4 破坏环路等待条件 把系统中所有资源按类型不同进行线性排队，并编号</p><h2 id="10-5-死锁后—恢复死锁"><a href="#10-5-死锁后—恢复死锁" class="headerlink" title="10.5 死锁后—恢复死锁"></a>10.5 死锁后—恢复死锁</h2><p>如何从死锁中恢复？</p><p>1 剥夺法恢复<br>  将某一资源从一个进程抢占过来给另一个进程使用<br>  不能影响原进程的最终执行结果<br>  取决于资源的特性</p><p>2  回退法恢复<br>  从各进程最近的检查点（check point）逐次重新启动</p><p>3 杀死进程来恢复<br>  最好杀死可重复执行、不会产生副作用的进程</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）进程管理上</title>
      <link href="/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/"/>
      <url>/2023/10/16/Computer_system/Os/2%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%20%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201558893.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="总览图"></p><p><strong>简单概述</strong></p><p>什么是进程？<br>   是程序的1次执行（程序执行的1个实例）<br>   每个进程有自己的地址空间。</p><p>为什么引入进程？<br>   多任务的需要。在内存中同时有多个可执行的进程，如果某一个进程去请求I&#x2F;O了，那么CPU就会空闲，这时候其他进程如果不执行的话，CPU利用率就会很低，所以进程并发执行以提高效率（特别是CPU的利用率）。</p><p>因此，需要对进程进行管理，以避免冲突：<br>   借助于PCB，记录进程的描述和控制信息、上下文状态</p><h1 id="1-进程和程序区别"><a href="#1-进程和程序区别" class="headerlink" title="1 进程和程序区别"></a>1 进程和程序区别</h1><p>进程是程序的1次执行。<br>进程（Process）和程序（Program）是两个不同的概念，它们在计算机科学中有明确的区别：</p><ol><li><strong>程序（Program）</strong>：<ul><li><strong>定义</strong>：程序是一组计算机指令的有序集合，这些指令被编写成一个文件，通常以可执行文件的形式存在。程序是静态的，它只是一段代码的集合，等待被执行。</li><li><strong>特点</strong>：程序包含了计算机程序员编写的源代码，它描述了一系列任务的算法和逻辑，但并没有实际执行。程序不占用计算机的内存空间，也不消耗计算机的CPU时间。</li><li><strong>例子</strong>：一个文本编辑器的程序文件、一个游戏的可执行文件、一个网页浏览器的应用程序等都是程序的例子。</li></ul></li><li><strong>进程（Process）</strong>：<ul><li><strong>定义</strong>：进程是计算机中正在运行的程序的实例。它是程序在内存中加载并执行时的活动状态，包括程序的代码、数据、执行状态、系统资源分配等。</li><li><strong>特点</strong>：进程是动态的，它占用计算机的内存空间，可以执行计算机指令，与其他进程并发运行。每个进程都有自己的独立内存空间，因此它们不会相互干扰。进程可以创建、启动、暂停、终止等。</li><li><strong>例子</strong>：当运行一个文本编辑器、播放音乐、浏览网页或打印文档时，每个活动都对应一个独立的进程。</li></ul></li></ol><p>总结来说，程序是静态的、不执行的计算机指令集合，而进程是程序的运行实例，它占用计算机内存，执行指令，并与其他进程一起协同工作。进程是计算机操作系统中的核心概念，它使多任务处理成为可能.</p><p>可以将程序和进程比喻为烹饪的过程：</p><ol><li><strong>程序（Program）</strong>就像是一本菜谱。菜谱是一份详细的食物制作指南，它包含了食材清单、烹饪步骤和所需的厨具。但菜谱本身并不能做出美味的食物，它只是一份指导，等待着被厨师（计算机）读取和执行。就像您需要拿出菜谱并按照其中的步骤去做一道菜一样，计算机需要将程序加载到内存中并执行其中的指令。</li><li><strong>进程（Process）</strong>就像是正在烹饪中的一道菜。当您选择一道菜谱并开始烹饪时，您实际上在制作一道具体的菜肴。这个菜肴有自己的成分、调味料和烹饪状态。它在火上烹煮、被切割、被摆盘等等。这个菜肴是实际被制作和提供给食客的，就像进程是正在计算机内存中运行和执行的程序实例。</li></ol><p>所以，程序就像是一份指导，而进程是实际的动态执行。程序是静态的，而进程是具体的、可见的操作。</p><h1 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2 进程状态"></a>2 进程状态</h1><h2 id="2-1-进程的5种基本状态"><a href="#2-1-进程的5种基本状态" class="headerlink" title="2.1 进程的5种基本状态"></a>2.1 进程的5种基本状态</h2><p>（1）新建（new）：进程正在被创建。<br>（2）就绪（ready）：进程可运行，正等待获得处理机。<br>（3）运行（running）：进程的指令正在被执行。<br>（4）阻塞（blocked）或等待：进程因等待某事件（如请求I&#x2F;O）而暂停执行。<br>（5）完成（done）：进程结束。</p><h2 id="2-2-进程状态之间转换"><a href="#2-2-进程状态之间转换" class="headerlink" title="2.2 进程状态之间转换"></a>2.2 进程状态之间转换</h2><p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20230916111349155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="状态转换图"></p><h2 id="2-3-七状态模型"><a href="#2-3-七状态模型" class="headerlink" title="2.3 七状态模型"></a>2.3 七状态模型</h2><p>在五状态的模型基础上，引入挂起（即 进程此时在外存等待）</p><p>就绪(Ready)：进程在内存且可立即进入运行状态<br>阻塞(Blocked)：进程在内存并等待某事件的出现<br>阻塞挂起(Blocked, suspend)：进程在外存并等待某事件的出现<br>就绪挂起(Ready, suspend)：进程在外存，但只要进入内存，即可运行<br> 运行<br> 新建<br> 完成</p><p>注意 挂起都在外存</p><p>挂起：把进程从内存转到外存  </p><p>激活：把进程从外存转到内存</p><p>补充：</p><p>时间片是操作系统给程序分配的时间，保证一个进程不会一直占用CPU资源不释放造成混乱</p><h1 id="3-进程描述"><a href="#3-进程描述" class="headerlink" title="3 进程描述"></a>3 进程描述</h1><h2 id="3-1-进程控制块-PCB"><a href="#3-1-进程控制块-PCB" class="headerlink" title="3.1 进程控制块 PCB"></a>3.1 进程控制块 PCB</h2><p><strong>作用</strong></p><p>​1 是OS管理和控制进程的数据结构。</p><p>​2 PCB记录着进程的描述信息。</p><p>​ 每个进程对应1个PCB。</p><p><strong>信息内容</strong></p><p>（1）进程本身的标识信息</p><p>​进程标识符pid(process ID)：整数，由OS分配，唯一</p><p>​用户标识符uid(user ID)：创建该进程的用户</p><p>​对应程序的地址：内存、外存</p><p>（2）CPU现场 - 为进程正确切换所需</p><p>​所有寄存器的值  或称进程上下文(context)</p><p>​因为要切换走进程！所以要保护当前进程的上下内容，使得切换回来的时候可以继续正常执行</p><p>（3）进程调度信息</p><p>​进程的状态</p><p>​优先级</p><p>​使进程阻塞的条件</p><p>​占用CPU 、等待CPU的时间（用于动态调整优先级）</p><p>（4）进程占用资源的信息</p><p>​进程间同步和通信机制，如信号量、消息队列指针</p><p>​打开文件的信息，如文件描述符表</p><p>CPU现场 - 为进程正确切换所需</p><p> 所有寄存器的值</p><p> 或称进程上下文(context)</p><p>Linux的进程控制块:task_struct</p><p>​进程创建时，由OS创建PCB;进程终止时，由OS撤销PCB；进程运行时，以PCB作为调度依据。</p><h2 id="3-2-进程块组织方式"><a href="#3-2-进程块组织方式" class="headerlink" title="3.2 进程块组织方式"></a>3.2 进程块组织方式</h2><p>一般来说，系统把所有PCB组织在一起，并把它们放在内存的固定区域，构成<strong>PCB</strong>表。</p><p>PCB表的大小决定了系统中最多可同时存在的进程个数。</p><p>同一状态进程的PCB组成一个链表，不同状态对应多个不同的链表，如就绪链表、阻塞链表 </p><h1 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4 进程控制"></a>4 进程控制</h1><p>进程控制就是要对我们上述讲到的进程状态之间做转换</p><p>基本概念</p><p><strong>原语</strong></p><p>​创建、撤销进程以及完成进程各状态之间的转换，由具有特定功能的原语完成</p><p>​原语 由若干指令构成的具有特定功能的函数</p><p>​具有原子性，其操作具有不可分割性</p><p>如：</p><p>​进程创建原语</p><p>​进程撤销原语</p><p>​阻塞原语</p><p>​唤醒原语</p><p>​挂起原语</p><p>​激活（解挂）原语</p><p>​改变进程优先级</p><h1 id="5-进程同步-互斥"><a href="#5-进程同步-互斥" class="headerlink" title="5 进程同步 互斥"></a>5 进程同步 互斥</h1><p>在执行时间上互相重叠（或交替），一个进程的执行尚未结束，另一个进程的执行已经开始的执行方式。</p><p>这样会有一个问题</p><p>​因为资源共享的问题，结果会产生不确定性</p><p>举一个例题</p><p>为此，引入同步（synchronization）和互斥（mutual exclusion）。</p><p>临界资源  一次只允许一个进程独占访问（使用）资源 ，越小越好</p><p>临界区   进程中访问临界资源的的程序段</p><h2 id="5-1-区分进程互斥和同步"><a href="#5-1-区分进程互斥和同步" class="headerlink" title="5.1 区分进程互斥和同步"></a>5.1 区分进程互斥和同步</h2><p>互斥是指执行某个进程的时候访问某一临界资源的时候，另一个进程不能执行访问这一临界资源。</p><p>经典只有互斥问题：打印机打印</p><p>同步是指完成某一进程执行是有条件的，必须等另一个进程的某一资源结束才可以</p><p>经典只有同步的问题：售票员售票</p><p>既有互斥又有同步问题：消费者问题</p><h2 id="5-2-核心方案"><a href="#5-2-核心方案" class="headerlink" title="5.2 核心方案"></a>5.2 核心方案</h2><p>信号量</p><p>利用信号量P-V操作可以实现进程的互斥访问</p><p>利用信号量P-V 操作可以实现进程的同步访问</p><h2 id="5-3-其他方案"><a href="#5-3-其他方案" class="headerlink" title="5.3 其他方案"></a>5.3 其他方案</h2><p>实现互斥方案</p><p>一个好的互斥方案应满足以下条件：</p><p>（1）任何两个进程不能同时处于临界区。</p><p>（2）临界区外的进程不应阻止其他进程进入临界区。</p><p>（3）不应使进程在临界区外无休止地等待。就是说，临界区代码执行时间要短。</p><p>（4）不应对CPU的个数和进程之间的相对运行速度作任何假设。</p><h3 id="方案1-设置锁变量"><a href="#方案1-设置锁变量" class="headerlink" title="方案1 设置锁变量"></a>方案1 设置锁变量</h3><p>即设置一个共享变量lock</p><p>当lock&#x3D;0的时候，临界区内无进程，初始值</p><p>当lock&#x3D;1的时候，临界区内有进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(lock);</span><br><span class="line">lock=<span class="number">1</span>;</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">lock=<span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt;</span><br></pre></td></tr></table></figure><p>可能的问题</p><p>1 会导致两个进程同时进入临界资源</p><p>​比如进程1走到lock&#x3D;1的时候，还没来得及上锁（修改lock的值为1）就被切换走了，这时候其他进程 就可以避免while也进入临界区</p><p>2  可能会存在盲等待   走到lock&#x3D;0的时候，还没来得及解锁就被切换走了，这时候其他进程都进不来！</p><p>所以这种方案是错误的，不能达到效果</p><h3 id="方案2-严格轮转法"><a href="#方案2-严格轮转法" class="headerlink" title="方案2 严格轮转法"></a>方案2 严格轮转法</h3><p>设置共享变量turn，以指示进入临界区的进程号</p><p>以两个进程为例</p><p>turn&#x3D;0的时候允许进程0进入临界区，初始值</p><p>turn&#x3D;1的时候允许进程1进入临界区</p><p>进程0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">0</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>进程1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  (turn != <span class="number">1</span>);</span><br><span class="line">&lt;临界区&gt;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">&lt;非临界区&gt; </span><br></pre></td></tr></table></figure><p>本质互为锁</p><p>可能的问题</p><p>进程可能会被临界区之外的进程阻塞</p><h3 id="方案3-Peterson解决方案"><a href="#方案3-Peterson解决方案" class="headerlink" title="方案3 Peterson解决方案"></a>方案3 Peterson解决方案</h3><p>设置一个共享变量process，代表此时进入临界区的进程号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enter_region</span>(process); <span class="comment">//process是 进入/离开临界区的进程号</span></span><br><span class="line">&lt;临界区&gt;</span><br><span class="line"><span class="built_in">leave_region</span>(process);</span><br><span class="line">&lt;非临界区&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个进程想进入临界区时，先调用enter_region函数，判断是否能安全进入，不能的话等待；当进程从临界区退出后，需调用leave_region函数，允许其它进程进入临界区。<br>两个函数的参数均为进程号</p><p>以两个进程为例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  FALSE  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TRUE   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   N        2 <span class="comment">// 进程的个数</span></span></span><br><span class="line"><span class="type">int</span>  turn;   <span class="comment">// 轮到谁？</span></span><br><span class="line"><span class="type">int</span>  interested[N];   <span class="comment">// 兴趣数组，表明第i个进程是否在临界区，所有元素初始值均为FALSE</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">enter_region</span> <span class="params">(<span class="type">int</span>  process)</span>  <span class="comment">// process为进程号 0 或 1&#123;        </span></span></span><br><span class="line"><span class="function">    <span class="type">int</span>  other</span>;  <span class="comment">// 另外一个进程的进程号        </span></span><br><span class="line">other  =  <span class="number">1</span>  -  process;        </span><br><span class="line">interested[process]  =  TRUE; <span class="comment">// 表明本进程进入临界区       </span></span><br><span class="line">turn  =  process;          <span class="comment">// 设置标志位       </span></span><br><span class="line"><span class="keyword">while</span> ( turn == process &amp;&amp; interested[other] == TRUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">leave_region</span> <span class="params">(<span class="type">int</span>  process)</span></span>&#123;      </span><br><span class="line">    interested[process]  =  FALSE; <span class="comment">// 本进程将离开临界区&#125;</span></span><br></pre></td></tr></table></figure><h3 id="方案4-关中断"><a href="#方案4-关中断" class="headerlink" title="方案4 关中断"></a>方案4 关中断</h3><p>由于进程在切换进程的时候 必须进行中断处理，既然如此的话</p><p>我们可以在一个程序进入临界区域之前，将中断功能给关闭，简称关中断！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关中断；</span><br><span class="line">&lt;临界区&gt;;</span><br><span class="line">开中断;</span><br><span class="line">&lt;非临界区&gt;;</span><br></pre></td></tr></table></figure><p>缺点</p><p>1 对多处理机系统无效，因为每个处理机有自己的中断开关</p><p>2 关中断权利交给用户不合适</p><h3 id="方案5-机器指令实现的互斥"><a href="#方案5-机器指令实现的互斥" class="headerlink" title="方案5 机器指令实现的互斥"></a>方案5 机器指令实现的互斥</h3><p>即保证某些内容他是直接互斥的</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）操作系统概述</title>
      <link href="/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/15/Computer_system/Os/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" class="lazyload placeholder" data-srcset="https://qodicat-1321366457.cos.ap-beijing.myqcloud.com/OS/image-20231126201236315.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="概述总览图"></p><h1 id="1-程序如何执行"><a href="#1-程序如何执行" class="headerlink" title="1 程序如何执行"></a>1 程序如何执行</h1><p>我们都对运行程序很熟悉，无论是QQ，微信都是一个个在运行的程序</p><p>我们也都知道有这样一个职业叫做——程序员，就是编写这些程序的代码的。</p><p>那么代码从编写好后到最终执行的过程是怎样的呢？实际有三步</p><p>​预处理 编译 链接</p><p>我们感觉好像很简单，但实际上程序运行需要各种资源，会有一些异常，这些处理我们往往不关心，而这些实际上是系统应用程序——操作系统来完成的</p><p>换句话说<strong>程序</strong>执行的整个生命周期都<strong>受操作系统控制</strong></p><p>比如建立程序的内存映像， CPU的分配 内存分配、释放 文件访问，输入输出（I&#x2F;O） 中断（异常）处理</p><h1 id="2-操作系统初探"><a href="#2-操作系统初探" class="headerlink" title="2 操作系统初探"></a>2 操作系统初探</h1><h2 id="2-1-操作系统功能"><a href="#2-1-操作系统功能" class="headerlink" title="2.1 操作系统功能"></a>2.1 操作系统功能</h2><p><strong>从用户观点看</strong>，操作系统是一个<strong>虚拟机</strong></p><p>​让用户（程序员）在使用计算机时不涉及计算机硬件的细节，使硬件细节和用户（程序员）隔离开来，即建立一种简单的高度抽象。</p><p><strong>从系统观点来看</strong>，操作系统是一个<strong>资源管理器</strong>：管理系统的软硬件资源</p><p>​硬件资源：构成计算机系统所必须配置的所有硬件： CPU、内存、时钟、磁盘。       软件资源：程序和数据（文件）。</p><p>总结来看，操作系统有四大功能</p><p>​ 进程管理，内存管理，文件管理， I&#x2F;O设备管理，以后的系列文章也会微软这个展开</p><h2 id="2-2-操作系统定义"><a href="#2-2-操作系统定义" class="headerlink" title="2.2 操作系统定义"></a>2.2 操作系统定义</h2><p>基于操作系统的功能</p><p>操作系统可以定义为</p><p>​OS是硬件之上的第1层软件（系统软件），是一组程序，用来有效控制和管理计算机系统的各类资源（硬件和软件资源：设备、文件、存储器、CPU、程序（进程））， 以方便用户使用计算机（用户和计算机的接口）</p><h1 id="3-操作系统一些概念"><a href="#3-操作系统一些概念" class="headerlink" title="3.操作系统一些概念"></a>3.操作系统一些概念</h1><h2 id="3-1-作业"><a href="#3-1-作业" class="headerlink" title="3.1 作业"></a>3.1 作业</h2><p>从输入开始到输出结束，用户要求计算机所做的一次业务处理的全部工作（一次业务处理往往需要包括多个程序配合）所以操作系统中的作业（Job）通常又可以理解为是一组相关任务或程序的集合</p><p>作业由三部分组成：1 程序  2要执行的程序代码  3数据</p><p>作业通常需要访问和处理数据，因此数据是作业的另一个重要组成部分</p><p>作业往往有着自己的控制信息等</p><p>假设你正在使用一台多任务操作系统的个人电脑，你同时打开了以下两个应用程序：</p><ol><li>文字处理器：你在编辑一份重要的文档。</li><li>网页浏览器：你正在浏览互联网上的一些新闻文章。</li></ol><p>在这个情景中，操作系统将视每个应用程序为一个作业，并为其分配资源和执行环境。</p><h2 id="3-2-批处理"><a href="#3-2-批处理" class="headerlink" title="3.2 批处理"></a>3.2 批处理</h2><p>为改进内存和I&#x2F;O设备之间的吞吐量 ，进行批处理操作</p><p>就是3.1讲的是一个作业处理</p><p>而3.2 就是同时处理多个作业，多个作业构成一个队列，依次处理</p><p><strong>缺点</strong>：</p><p>​    用户不能干预自己作业的运行     一旦发现作业错误不能及时改正     延长了软件开发时间     一般只适用于成熟的程序或大型的计算程序</p><h2 id="3-3-单道程序和多道程序"><a href="#3-3-单道程序和多道程序" class="headerlink" title="3.3 单道程序和多道程序"></a>3.3 单道程序和多道程序</h2><ul><li>单道程序：</li></ul><p>​内存中只有一个用户程序</p><p>​因为I&#x2F;O很费时，若当前程序因等待I&#x2F;O而暂停， 则<strong>CPU空闲</strong></p><ul><li>多道程序：  在内存中存放多个用户程序，同时处于可运行状态。    当一个程序等待I&#x2F;O时，另一个程序可以使用CPU</li></ul><p>我们现在的操作系统肯定都是多道程序，核心目的让CPU忙起来，提高效率</p><h2 id="3-4-多道批处理系统"><a href="#3-4-多道批处理系统" class="headerlink" title="3.4 多道批处理系统"></a>3.4 多道批处理系统</h2><p>多道程序+批处理&#x3D;多道批处理系统</p><p>与单道批处理系统相比：  系统吞吐量（单位时间内完成的总工作量）大；  资源利用率高； 周转时间（作业从进入系统到完成所经历的时间）长。</p><h2 id="3-5分时系统"><a href="#3-5分时系统" class="headerlink" title="3.5分时系统"></a>3.5分时系统</h2><p>多个用户（程序）共享一台计算机，按时间片（time slice）轮流使用。</p><p>什么是 时间片：OS将CPU时间划分为若干个片段</p><h2 id="3-6-并发和并行"><a href="#3-6-并发和并行" class="headerlink" title="3.6 并发和并行"></a>3.6 并发和并行</h2><p>并发：两个或多个事件在同一时间间隔内交替发生，不一定是同时执行。</p><p>并行：两个或多个事件在同一时刻发生。</p><p> 多用户：允许多个用户通过各自的终端使用同一台主机，共享主机系统中的各类资源。 多任务：允许多个程序并发执行。</p><p>一个 比喻更好理解</p><ul><li><strong>并发</strong>：想象一个餐厅，只有一个厨师和一个服务员。多个客人进入餐厅，他们点餐后，服务员会为每个客人记录点餐的需求，然后将这些需求交给厨师。厨师会依次准备每份菜肴，然后将它们送到客人的桌子上。虽然只有一个厨师，但由于服务员不断地切换处理不同客人的需求，似乎每个客人都在同一时间段内得到了服务，这就是<strong>并发</strong>。多个任务（客人的点餐需求）在同一个资源（厨师）上交替执行。</li><li><strong>并行</strong>：现在，想象这家餐厅升级了，雇佣了多个厨师，每个厨师都可以独立准备菜肴，而服务员可以同时为多个客人提供服务。在这种情况下，每个厨师和服务员都可以同时处理不同的客户需求，这就是<strong>并行</strong>。多个任务（客人的点餐需求）在同时使用不同的资源（多个厨师和服务员）来提高效率。</li></ul><p>还有比如实时OS，网络OS，分布式OS</p><h1 id="4-OS对运行环境的要求"><a href="#4-OS对运行环境的要求" class="headerlink" title="4. OS对运行环境的要求"></a>4. OS对运行环境的要求</h1><h2 id="4-1-CPU"><a href="#4-1-CPU" class="headerlink" title="4.1 CPU"></a>4.1 CPU</h2><p>CPU是执行程序的核心部件</p><p>CPU 通过状态标识，知道是操作系统程序还是用户程序在执行，从而给到OS特权指令（只能由OS执行的命令），进行一些紧急任务建立存储保护，清内存、关中断等</p><p>CPU<strong>两种工作状态</strong></p><p>​<strong>核心态</strong></p><p>处于核心态的时候 </p><p>全部指令（包括特权指令）可以执行 可使用所有资源 并具有改变处理器状态的能力</p><p>​<strong>用户态</strong></p><p>处于用户态的时候</p><p>只有非特权指令能执行 特权级别不同，可运行的指令集合也不同 特权级别越高，可以运行的指令集合越大 高特权级别对应的可运行指令集合包含低特权级的</p><p>CPU的<strong>程序状态字PSW</strong></p><p>指示程序执行的当前状态，主要包括<br>  CPU的工作状态——指明核心态还是用户态，用来说明当前在CPU上执行的是操作系统还是应用程序，从而决定其是否可以使用特权指令或拥有其他的特殊权力<br>  条件标志——反映指令执行后的结果特征<br>  中断标志——指出是否允许中断</p><p>CPU的<strong>程序计数字PC</strong></p><p>指示下一条要执行的指令</p><h2 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h2><p>程序必须存放在内存中才能运行。 </p><p>在多任务系统中，操作系统要管理、保护各任务的程序和数据，使它们不至于受到破坏和相互干扰。 操作系统本身也要存放在内存中并运行，不能被破坏。</p><p><strong>内存分块：</strong>块作为分配内存空间的基本单位，如4KB为1块。</p><p>为什么要按块来分配内存空间？旨在简化对内存的分配和管理</p><p><strong>内存保护：</strong> OS正常运行的基本条件</p><p>常用的保护机制</p><p> (1) 界限寄存器 存放某任务在内存的上界和下界地址(或者下界与长度)，越界后产生越界中断</p><p>(2) 存储保护键（ Key） 当一个程序进入内存时，OS为其分配一个唯一的Key。 同时将分配给它的每个存储块都设置成该Key</p><h2 id="4-3-中断"><a href="#4-3-中断" class="headerlink" title="4.3 中断"></a>4.3 中断</h2><p>指CPU在收到外部中断信号后，停止原来工作，转去处理该中断事件，完毕后回到原来断点继续工作。  CPU对系统中发生的“异步（随机）”事件的处理</p><p><strong>中断类型</strong></p><p>1 硬件中断</p><p>​又分为两类 </p><p>​内部异常（硬故障中断 ： 如电源断掉，程序性中断 ：如溢出，越界，非法指令等）</p><p>​外部中断（CPU外部发生的特殊事件，通过“中断请求”向CPU请求处理  如打印机缺纸等）</p><p> 2 异常（Exception）</p><p>3 陷入（Trap）</p><p>4 访管中断（系统调用）</p><p><strong>中断响应过程</strong></p><p>1 关中断   防止其他中断修改影响当下中断</p><p>2 保护断点和程序状态    将断点和程序状态保存到栈或特殊寄存器中</p><p>3 识别中断事件</p><h2 id="4-4-时钟"><a href="#4-4-时钟" class="headerlink" title="4.4 时钟"></a>4.4 时钟</h2><p>进行程序的同步，计数等</p><p>1 硬件时钟：通过时钟寄存器实现。  绝对时钟：记录当前时间 相对时钟（间隔时钟）：分时系统的基础。 </p><p>2 软件时钟：通过时钟队列实现。 </p><h2 id="4-5-重定位"><a href="#4-5-重定位" class="headerlink" title="4.5 重定位"></a>4.5 重定位</h2><p>将程序中的相对地址转换为绝对地址。 </p><p> 原因：运行前不可能知道程序将放在内存的什么位置。 </p><p>静态重定位：程序装入内存时，由装入程序重定位</p><p>动态重定位：CPU每次访问内存时，由动态地址转换机构（硬件）自动进行</p><h1 id="5-现代操作系统基本特征"><a href="#5-现代操作系统基本特征" class="headerlink" title="5.现代操作系统基本特征"></a>5.现代操作系统基本特征</h1><p>（1）并发         计算机系统中同时存在多个运行的程序，需要OS管理和调度</p><p> （2）共享        “同时”访问          互斥共享  </p><p>（3）虚拟         利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务 （4）异步        程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知         只要运行环境相同，OS需要保证程序运行的结果也要相同</p><h1 id="6-操作系统启动过程"><a href="#6-操作系统启动过程" class="headerlink" title="6 操作系统启动过程"></a>6 操作系统启动过程</h1><ol><li><strong>硬件自检（POST）</strong>：<ul><li>当计算机电源打开时，计算机硬件执行自检过程（POST），以确保所有硬件组件正常运行。这包括检查内存、CPU、磁盘驱动器等。</li></ul></li><li><strong>引导设备选择</strong>：<ul><li>计算机 BIOS 或 UEFI 固件负责选择要从中启动的设备。用户可以在 BIOS&#x2F;UEFI 设置中配置启动顺序，以决定首选引导设备，例如硬盘、光盘驱动器、USB 驱动器等。</li></ul></li><li><strong>MBR&#x2F;GPT加载</strong>：<ul><li>根据 BIOS&#x2F;UEFI 设置，计算机将查找引导设备的主引导记录（MBR）或分区表（GPT），以确定启动引导加载程序的位置。</li></ul></li><li><strong>引导加载程序（Boot Loader）</strong>：<ul><li>引导加载程序是启动过程的下一步，它负责加载操作系统内核。在EOS操作系统中，引导加载程序通常是GRUB（GRand Unified Bootloader）或其他引导加载程序。</li></ul></li><li><strong>内核加载</strong>：<ul><li>引导加载程序加载EOS操作系统内核（Linux内核）到计算机的内存中。内核是操作系统的核心，它负责管理硬件、进程、内存和文件系统等。</li></ul></li><li><strong>初始化（init）</strong>：<ul><li>一旦内核加载到内存中，它会执行初始化过程，初始化操作系统的各个组件和服务。在Linux中，init 进程是初始化的第一个进程，它将创建其他系统进程，并启动用户界面或命令行终端。</li></ul></li><li><strong>启动级别&#x2F;运行级别（Runlevels）</strong>：<ul><li>EOS操作系统支持不同的启动级别，每个级别定义了在系统启动时运行的一组服务和任务。用户可以通过更改运行级别来控制系统启动时加载的服务。不同的运行级别可以是单用户模式、多用户模式等。</li></ul></li><li><strong>登录&#x2F;用户界面</strong>：<ul><li>最后一步是用户登录或进入用户界面。用户可以通过输入用户名和密码登录，或者进入图形用户界面（GUI）或命令行界面（CLI），具体取决于系统配置。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（八）ControlNet</title>
      <link href="/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/"/>
      <url>/2023/07/24/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/8%20ControlNet/</url>
      
        <content type="html"><![CDATA[<p>2023年的2月13日，一款名叫ControlNet的插件横空出世，AI绘画变得更加可控</p><p>ControlNet直译过来很简单，就叫做控制网，开发者是一名华裔，毕业于苏州大学，目前在斯坦福做读博士一年级，大佬大佬！</p><p>在controlNet之前，基于扩散模型的绘画是极为难控制的，平时自嗨画画其实没有一点问题，随机就随机一点，但是对于一些特定要求的岗位的同学来说，这种抽卡式缺乏稳定性的模型很难真正提高效率。</p><h1 id="1-ControlNet的作用结构"><a href="#1-ControlNet的作用结构" class="headerlink" title="1 ControlNet的作用结构"></a>1 ControlNet的作用结构</h1><p>​根据一些额外信息控制扩散生成走向，业内人士称为微调，通俗点说就是大模型你不是随机吗，那我给你一些指引信息，让你乖乖听话朝着我期望的方向走</p><p>​这时候有好奇的小伙伴就要问到了，那他和图生图有什么区别吗？我直接输入图片不也可以达到同样的效果吗？其实从某种意义上来说是的，但我举如下一个例子你就明白了</p><p>​比如我现在要生成一个有着特定姿势的图片，我固然可以通过一张自己期待的姿势的图片输入，模型可能会了解到这个姿势，但与此同时，这种图片除了姿势的其他信息如画面颜色，风格，人物特征也会被网络捕获到，因而就可能会产生意外的化学反应，但是用ControlNet可以提取人体关键点（如下图），这样的话模型只会了解到纯粹的需要生成的姿势而不会混杂其他信息，可控性就会增强了</p><h1 id="2-ControlNet的安装和使用"><a href="#2-ControlNet的安装和使用" class="headerlink" title="2 ControlNet的安装和使用"></a>2 ControlNet的安装和使用</h1><p>ControlNet本质是一个插件，所以类似于之前插件的安装（看之前的这篇插件安装的文章）</p><p>不同于一些插件，ControlNet还需要搭配不同的模型来使用，来实现特定的功能</p><p>最推荐的安装方式，是将ControlNet的扩展文件夹放在根目录下的extensions文件夹内，可以省下很多麻烦</p><p>然后在扩展选单里重新加载WebUI 界面，就可以在文生图和图生图里面看到了</p><p>下载一个ControlNet模型（一般是pth和yaml文件）之后移动到ControlNet的扩展文件夹中</p><h1 id="3-基本使用方式"><a href="#3-基本使用方式" class="headerlink" title="3 基本使用方式"></a>3 基本使用方式</h1><p>点开ControlNet控制网。输入一张图片，我们在这里期望输出的图片模仿我们输入图片的姿势</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913193208411.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913193208411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913193208411"></p><p>我们从网上找一张<img src="Snipaste_2023-09-13_19-40-39.png" class="lazyload placeholder" data-srcset="Snipaste_2023-09-13_19-40-39.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-09-13_19-40-39" style="zoom:50%;" />图片上传</p><p>选择预处理器（OpenPose就是提取姿势的），并选择相应的模型</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913194602605.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913194602605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913194602605"></p><p>其他参数先维持不变</p><p>加入我们期望的场景提示词，如在森林里</p><blockquote><p>1 cute girl, forest, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p>生成![00228-2167140323-1 cute girl, forest, smile, _SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper,](00228-2167140323-1 cute girl, forest, smile, _SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper,.png)</p><p>更改一下提示词</p><blockquote><p>1 cute girl, city, smile,<br>SFW, (masterpiece:1.2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2)</p></blockquote><p>![00236-1319366320-1 cute girl, city, smile, white coat_SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wa](00236-1319366320-1 cute girl, city, smile, white coat_SFW, (masterpiece_1.2), best quality, masterpiece, highres, original, extremely detailed wa.png)</p><p>可以看出姿势完全不变</p><p>同时它还会附加给我们一张骨骼图</p><p><img src="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" class="lazyload placeholder" data-srcset="http://127.0.0.1:6006/file=/tmp/tmpk7lwq82o.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="3-1-参数详解"><a href="#3-1-参数详解" class="headerlink" title="3.1 参数详解"></a>3.1 参数详解</h2><p><strong>Control Weight</strong></p><p>决定这个控制效应在图片中呈现出来的强度，维持默认1不变</p><p><strong>Starting Control step</strong> </p><p><strong>ending Control step</strong> </p><p>什么时候加入ControlNet影响，默认的0到1表示全程生效，缩短影响，可以赋予图像更多的自由度</p><p><strong>ControlMode</strong></p><p>提示词影响和ControlNet之间倾向于哪一个，一般维持默认Balanced即可，二者兼顾</p><p>核心就是控制强弱</p><p><strong>缩放模式</strong></p><p>会在导入图片和你生成图片分辨率不匹配的时候起作用</p><h2 id="3-2-代表性ControlNet模型应用"><a href="#3-2-代表性ControlNet模型应用" class="headerlink" title="3.2 代表性ControlNet模型应用"></a>3.2 代表性ControlNet模型应用</h2><h3 id="3-2-1-Open-Pose姿态"><a href="#3-2-1-Open-Pose姿态" class="headerlink" title="3.2.1 Open Pose姿态"></a>3.2.1 Open Pose姿态</h3><p>上面讲到的只是OpenPose的基本的身体整体骨骼的刻画</p><p>选择不同的预处理器可以获得对手部，脸部更精确的刻画</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913200558559.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913200558559.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913200558559"></p><p>比如我们使用openpose_face,可以看到获得了更精细的脸部特征骨骼图</p><p>![tmpbpgj9ukv (1)](tmpbpgj9ukv (1).png)</p><h3 id="3-2-2-Depth-深度"><a href="#3-2-2-Depth-深度" class="headerlink" title="3.2.2 Depth 深度"></a>3.2.2 Depth 深度</h3><p>适合富有空间感的多层次场景</p><h3 id="3-2-3-canny-边缘检测"><a href="#3-2-3-canny-边缘检测" class="headerlink" title="3.2.3 canny 边缘检测"></a>3.2.3 canny 边缘检测</h3><p>通过边缘来进行绘画输出，超级强大！！！</p><p>比如我们这里用Canny检测器，可以生成几乎一模一样的</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913201834850.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913201834850.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913201834850"></p><p>可以实现线稿上色</p><p><img src="/img%5CStable_diffusion%5Cimage-20230913202412411.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230913202412411.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230913202412411"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（七）扩展插件</title>
      <link href="/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/07/22/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/7%20%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Stable diffusion的开源生态为各种各样的辅助插件的开发提供了极大的便利，而这些辅助插件又可以为我们AI作画提供极大的便捷</p><h1 id="1-插件界面介绍"><a href="#1-插件界面介绍" class="headerlink" title="1 插件界面介绍"></a>1 插件界面介绍</h1><p>Extensions 在扩展一栏</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905174839326.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905174839326.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905174839326"></p><p>三个installed  (已安装) Available （可用的）install from URL 从URL安装</p><p>如果是自己安装的sd，很可能刚开始的时候installed里面只有一些必要的插件，但是如果是一些大佬的整合包，则已经自带了一些插件</p><h1 id="2-插件安装方式"><a href="#2-插件安装方式" class="headerlink" title="2 插件安装方式"></a>2 插件安装方式</h1><p>1 Available（可用的插件）这里作者会把一些常用的插件记录在一个地址中，点击Load from，则可以加载出一系列详细的扩展应用清单</p><p>2 链接安装，复制代码仓库的地址，再点击安装也能实现一键安装</p><p>3 但上面两种方式都是借助git，因而可能会不稳定，所以还有最后一种方式，直接下扩展插件的代码包，然后送到Stable-diffusion根目录下的extensions文件夹里，然后点击应用并重启用户界面即可</p><h1 id="3-新手插件"><a href="#3-新手插件" class="headerlink" title="3 新手插件"></a>3 新手插件</h1><h2 id="3-1-中文本地化语言包"><a href="#3-1-中文本地化语言包" class="headerlink" title="3.1 中文本地化语言包"></a>3.1 中文本地化语言包</h2><p>​搜索栏里搜索 zh</p><h2 id="3-2-图库浏览器-image-browser"><a href="#3-2-图库浏览器-image-browser" class="headerlink" title="3.2 图库浏览器  image browser"></a>3.2 图库浏览器  image browser</h2><p>​有很多功能如收藏夹，筛选，查看图片信息等等</p><p>​    链接<a href="https://github.com/yfszzx/stable-diffusion-webui-images-browser">https://github.com/yfszzx/stable-diffusion-webui-images-browser</a></p><h2 id="3-3-提示词自动补全-tag-autocompletion"><a href="#3-3-提示词自动补全-tag-autocompletion" class="headerlink" title="3.3 提示词自动补全  tag autocompletion"></a>3.3 提示词自动补全  tag autocompletion</h2><p>​链接<a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git"> https://github.com/DominikDoom/a1111-sd-webui-tagcomplete.git</a></p><p>  （1）他可以告诉我们AI可以更好理解的一些提示词</p><p>比如我们这里，输入one girl 这时候他下边自动提示1girl的写法，点击换用1girl会更好</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905175245286.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905175245286.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175245286"></p><p>（2）可以快速补全各类模型名称</p><p>我们知道一些embeddings，lora模型需要特定提示词才能激活，但是那些提示词可能又臭又长记不住，怎么办，提示词插件来咯</p><p>输入：</p><ul><li><code>&lt;e:</code> 会展示 embeddings 名字</li><li><code>&lt;l:</code> 或者<code>&lt;lora:</code> 会展现 Lora 名字</li><li><code>&lt;h:</code> 或者<code>&lt;hypernet:</code> 会展现可选的 Hypernetworks</li></ul><p><img src="/img%5CStable_diffusion%5Cimage-20230905175526580.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905175526580.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905175526580"></p><h2 id="3-4-Tagger-提示词反推插件"><a href="#3-4-Tagger-提示词反推插件" class="headerlink" title="3.4 Tagger 提示词反推插件"></a>3.4 Tagger 提示词反推插件</h2><p>链接 <a href="https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git">https://github.com/toriato/stable-diffusion-webui-wd14-tagger.git</a></p><p>上传图片，选择反推算法，一般维持默认即可，点击开始反推</p><p><img src="/img%5CStable_diffusion%5Cimage-20230905180334053-1693910444141.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230905180334053-1693910444141.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230905180334053"></p><p>使用完后，点击卸载显存中所有反推模型</p><h2 id="3-5-Prompt-all-in-one"><a href="#3-5-Prompt-all-in-one" class="headerlink" title="3.5 Prompt-all-in-one"></a>3.5 Prompt-all-in-one</h2><p> Prompts 神器，它提供了自动翻译、历史记录和收藏等功能，支持多种语言，满足不同用户的需求。对英文不熟悉的用户，使用它，再也不用在翻译软件和SD之间反复横跳了。</p><h1 id="4-进阶扩展"><a href="#4-进阶扩展" class="headerlink" title="4 进阶扩展"></a>4 进阶扩展</h1><h2 id="4-1提升画质"><a href="#4-1提升画质" class="headerlink" title="4.1提升画质"></a>4.1提升画质</h2><h3 id="Ultimate-Upscale-无损放大脚本"><a href="#Ultimate-Upscale-无损放大脚本" class="headerlink" title="Ultimate Upscale 无损放大脚本"></a>Ultimate Upscale 无损放大脚本</h3><p>​类似于SD 自带的放大，把图片拆成不同的块去放大</p><h3 id="local-latent-Couple-局部隐空间"><a href="#local-latent-Couple-局部隐空间" class="headerlink" title="local latent Couple  局部隐空间"></a>local latent Couple  局部隐空间</h3><p>​可以进行一些细节局部修饰，重新绘制</p><h2 id="4-2-提示词"><a href="#4-2-提示词" class="headerlink" title="4.2 提示词"></a>4.2 提示词</h2><h3 id="cutoff-解决提示词之间的相互干预"><a href="#cutoff-解决提示词之间的相互干预" class="headerlink" title="cutoff 解决提示词之间的相互干预"></a>cutoff 解决提示词之间的相互干预</h3><p>​比如我们想让女生穿一个红色裙子，但是忽然发现红色到了帽子上等等其他地方</p><h2 id="4-3-视频制作"><a href="#4-3-视频制作" class="headerlink" title="4.3 视频制作"></a>4.3 视频制作</h2><h3 id="infinite-zoom-无限放大扩展"><a href="#infinite-zoom-无限放大扩展" class="headerlink" title="infinite zoom 无限放大扩展"></a>infinite zoom 无限放大扩展</h3><p>​可以将图片无限延伸成为视频</p><h3 id="Deforum"><a href="#Deforum" class="headerlink" title="Deforum"></a>Deforum</h3><p>最近大火的可以将图片转出视频的插件，</p><h2 id="4-4-精准绘图"><a href="#4-4-精准绘图" class="headerlink" title="4.4 精准绘图"></a>4.4 精准绘图</h2><p> 骨架等识别</p><p> 3d-open-pose-editor插件</p><p> Openpose-editor（骨架编辑）</p><p>用来编辑人体骨架，可以从已有照片中自动检测生成。结合controlnet，可以生成指定姿势的人物。可以大大提高出图的可控性。</p><h2 id="4-5-抠图神器"><a href="#4-5-抠图神器" class="headerlink" title="4.5 抠图神器"></a>4.5 抠图神器</h2><p>Segment-anything（抠图神器）</p><h1 id="5-自身内置"><a href="#5-自身内置" class="headerlink" title="5 自身内置"></a>5 自身内置</h1><p><strong>X&#x2F;Y plot &amp; Prompt matrix</strong></p><p>prompt matrix和x&#x2F;y plot多用于演示,都是生成一个有好几张图组成的多格图、当你想要对比一个或多个词(艺术风格、人物细节描述等等)对最后图片的影响(prompt matrix的使用场景)亦或是一个或多个参数的不同值下(不同扩散次数、不同cfg值等等)生成的不同图片对比结果(x&#x2F;y plot的使用场景)</p><p><a href="https://zhuanlan.zhihu.com/p/637138476">【基础篇 第五课】Stable Diffusion 出图必备脚本神器 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（五）高清作图、高清修复</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/5%20%E9%AB%98%E6%B8%85%E4%BD%9C%E5%93%81%E4%BA%A7%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>如何优化出图质量，产出更高清，分辨率更高，更有细节的绘画作品呢？</p><p>之前为了提高绘画质量，我们学习了诸多的提示词，选用了更优的模型</p><p>同时我们了解到，越高的分辨率意味着模型有着更大的发挥空间，细节会更好，但是受限于直接放大图片分辨率产生的多头多脚的问题，同时大的分辨率可能会直接爆显存，那么我们该怎么办呢</p><p>本节我们了解更多的放大算法，使得AI画出的图更加有质感</p><p>涉及方法主要有：</p><p><strong>高分辨率修复</strong></p><p><strong>Upscale脚本</strong></p><p><strong>附加功能中的图片放大算法</strong></p><p>他们各有优缺点</p><p>我们首先生成一张原图</p><p>输入正向提示词</p><blockquote><p>cinematic photo official art,unity 8k wallpaper,ultra detailed,aesthetic,masterpiece,best quality,photorealistic,entangle,mandala,tangle,entangle,1girl,cowboy shot,ecstasy of flower,dynamic angle,the most beautiful form of chaos,elegant,a brutalist designed,vivid colours,romanticism,atmospheric . 35mm photograph, film, bokeh, professional, 4k, highly detailed, skin detail realistic, ultra realistic, long hair, straight hair, eyes detail</p></blockquote><p>输入反向提示词</p><blockquote><p>(worst quality:1.5), (low quality:1.5), (normal quality:1.5), lowres, bad anatomy, bad hands, multiple eyebrow, (cropped), extra limb, missing limbs, deformed hands, long neck, long body, (bad hands), signature, username, artist name, conjoined fingers, deformed fingers, ugly eyes, imperfect eyes, skewed eyes, unnatural face, unnatural body, error, painting by bad-artist<br>layman work, worst quality, ugly, (deformed|distorted|disfigured:1.21), poorly drawn, bad anatomy, wrong anatomy, mutation, mutated, (mutated hands AND fingers:1.21), bad hands, bad fingers, loss of a limb, extra limb, missing limb, floating limbs, amputation, Yaeba, photo, deformed, black and white, realism, disfigured, low contrast, long neck</p></blockquote><p>初始分辨率设置为了640*704</p><img src="原图.png" class="lazyload placeholder" data-srcset="原图.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="原图" style="zoom:50%;" /><p>#1 高清修复</p><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>先绘制一份低分辨率的图像</p><p>再根据它重绘第二幅高分辨率的图像</p><h2 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h2><p>先在低分辨率的情况下反复抽卡尝试，有满意的图之后，固定随机种子，进行高分辨率修复</p><p>（1）查看图片随机种子，填入种子栏</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110407249.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110407249.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110407249"></p><p>（2）在文生图界面出图设置栏勾选高清修复</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110504309.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110504309.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110504309"></p><p>勾选高清修复后会出现两行新的参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823110812405.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823110812405.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110812405"></p><p>（3）出图参数设置</p><p><strong>1 放大算法</strong>  将低分辨率打回重画的方法，这里我们一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 高清修复采用次数</strong>   维持0不变即可，意味着和原图采样次数一样是20 </p><p><strong>3 重绘幅度</strong>  等图于图生图里的重绘幅度，和原图有多像，一般维持在0.5以下</p><p><strong>4  尺寸设置</strong> 将图片由原始的分辨率放大到多少，</p><p>​放大倍率就是放大几倍</p><p>点击 出图如下</p><img src="高清修复.png" class="lazyload placeholder" data-srcset="高清修复.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="高清修复" style="zoom:33%;" /><p>比较一下 细节</p><img src="image-20230823111953209.png" class="lazyload placeholder" data-srcset="image-20230823111953209.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823111953209" style="zoom:67%;" /><h2 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h2><p>优点</p><p>​（1）不会改变画面构图，由随机种子固定即可</p><p>​（2）操作简单</p><p>​（3）稳定克服多人，多头情况</p><p>缺点</p><p>​（1）仍然需要较大的显存，而且能画多大依然受到显存的限制</p><p>​（2）计算速度相对较慢，，耗费较长时间</p><h1 id="2-UpScale-放大脚本"><a href="#2-UpScale-放大脚本" class="headerlink" title="2 UpScale 放大脚本"></a>2 UpScale 放大脚本</h1><p>第一种方法依然受到显存限制，所以但这种方法就不受影响啦</p><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>​将图片打成不同块，每一块分别绘制</p><h2 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h2><p>这是属于图生图的功能</p><p>​这里有一个小技巧，点击图片预览下方的图生图，可以把刚刚文生图生成的图片移动到图生图，同时各种参数设置，提示词，模型都会复制一份</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823211634513.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823211634513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823211634513"></p><p>​（1）点击脚本一栏，选择使用SD放大</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823102859699.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823102859699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823102859699"></p><p>（2）参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823212157442.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823212157442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212157442"></p><p><strong>1 放大算法</strong> 我们选择和1高清修复一样的即可，二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>2 图块重叠的像素</strong>，原理部分我们讲到，UpScale 是通过打成不同的块进行的，因而块与块之间要缝合需要一定的像素过渡，一般维持默认64即可</p><p><strong>3 缩放系数</strong> 将图片由原始的分辨率放大到多少倍</p><p>点击生成</p><p>比较一下细节</p><p><strong><img src="img\Stable_diffusion\image-20230823212328217.png" class="lazyload placeholder" data-srcset="img\Stable_diffusion\image-20230823212328217.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212328217" style="zoom: 50%;" /></strong></p><h2 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h2><p>优点</p><p>​（1）可以突破内存限制，获得更大的分辨率，速度较快</p><p>​（2）画面精度更高</p><p>缺点</p><p>​（1）分割过程较为不可控</p><p>​（2）操作比较繁琐</p><h1 id="3-附加功能放大"><a href="#3-附加功能放大" class="headerlink" title="3 附加功能放大"></a>3 附加功能放大</h1><p>用于图片后期处理</p><p>用于两种算法放大</p><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><p>附加功能的放大，相当于重绘幅度为0的Upscale</p><h2 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h2><p>这里也有一个小技巧，点击图片预览下方的添加到附加功能，可以把刚刚文生图生成的图片移动到附加功能一栏中，同时各种参数设置，提示词，模型都会复制一份</p><p>（1）参数设置</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823212634383.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823212634383.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823212634383"></p><p><strong>1 缩放比例</strong>  将图片由原始的分辨率放大到多少倍</p><p><strong>2 Upscale1</strong> ，放大算法 同上面讲到的，一般对于二次元选择 R-ESRGAN 4x+Anime 6B的方法，其他风格选择R-ESRGAN 4x+</p><p><strong>3 其他设置</strong>  Upscale2  可见度什么的维持默认即可</p><p>点击生成</p><p>比较一下细节</p><p><img src="/img%5CStable_diffusion%5Cimage-20230823213027789.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230823213027789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823213027789"></p><h2 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h2><p> 优点</p><p>​（1）简单，方便，计算快</p><p>​（2）完全不改变图片内容</p><p>缺点</p><p>​（1）细节上不如前两种方法</p><p><a href="https://zhuanlan.zhihu.com/p/623014034">AI绘画教程：如何在stable diffusion中生成高清大图？ - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（六）局部重绘</title>
      <link href="/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/"/>
      <url>/2023/07/21/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/6%20%E5%B1%80%E9%83%A8%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<p>之前我们熟悉了AI绘画的各类模型，提示词写法，图像放大等技巧。但我们目前所有的操作都是针对整张图片的。</p><p>但是我们有些时候会遇到这样一种情况，就是我们生成的图片整体满意，但是一些细节，如手部绘画不满意，这时候该怎么办呢？打回炉子重新画一遍吗？</p><p>这样可能会面临的一个问题是</p><p>（1）如果本身AI绘画的分辨率比较高，那么意味着再画一次需要很长时间</p><p>（2）更重要的是，增加我们想要的提示词，对提示词做改变后，画面内容可能发现较大的变化</p><p>因而，用我们今天的局部重绘功能就可以很好解决这个问题啦</p><p>当然局部重绘还有更多的发挥空间</p><p>​如删除画面中自己不想要的物品，人物，增添自己想要的人物等等……</p><p>局部重绘是图生图的下属功能</p><h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h1><p>首先在文生图生成一张图片</p><p>![00160-1889848896-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00160-1889848896-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)</p><p>点击图库浏览器里或浏览图下方的局部重绘按钮，就可以跳转到图生图的局部重绘功能</p><h2 id="1-1-步骤1-补充提示词"><a href="#1-1-步骤1-补充提示词" class="headerlink" title="1.1 步骤1 补充提示词"></a>1.1 步骤1 补充提示词</h2><p>局部重绘也依然需要提示词</p><p>比如我们想在这个的基础上让这个女生戴一个帽子，那么我们就要在正向提示词里加上(a hat:1.4) 同时这里一定要给一定的权重加强1.4   否则就不能正常的展示效果<img src="/img%5CStable_diffusion%5Cimage-20230902114649762.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902114649762.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114649762"></p><h2 id="1-2-步骤2-绘制蒙版"><a href="#1-2-步骤2-绘制蒙版" class="headerlink" title="1.2 步骤2 绘制蒙版"></a>1.2 步骤2 绘制蒙版</h2><p>蒙版是什么呢？就是要通过蒙版选定区域告诉模型我们要对哪些区域做处理</p><p>用黑色的画笔在图像上画黑色的蒙版</p><p>右上角画笔一样的按钮<strong>可以调整画笔粗细</strong></p><p>圆圈表示 重新画蒙版</p><p>叉号表示关闭当前图像</p><p><img src="/img%5CStable_diffusion%5Cimage-20230825163450914.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230825163450914.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230825163450914"></p><p>在这里我们要给女生重新加一个帽子，</p><p>需要让模型重新绘制头部上方，因而我们用模板把头部上方画一画即可</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902114938059.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902114938059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902114938059"></p><h2 id="1-3-步骤3-参数设置"><a href="#1-3-步骤3-参数设置" class="headerlink" title="1.3 步骤3 参数设置"></a>1.3 步骤3 参数设置</h2><p><strong>重绘幅度</strong>在0.7到0.8之间</p><p><strong>蒙版模糊</strong></p><p>局部重绘使用的就是蒙版来确定绘图的区域，如果只改变蒙版内或者蒙版外的内容，那么边缘处就会突变，很不协调，所以蒙版模糊可以理解成PS中的羽化，用来控制蒙版过渡效果，越大过渡越平滑。</p><p>设置10以下的模糊可以让重绘区域拼接进去更加丝滑</p><p><strong>蒙版模式</strong>  </p><p>选重绘蒙版内容，则会重新绘制黑色蒙版画住的</p><p>选重绘非蒙版内容，就是会重新绘制黑色区域画住以外区域的</p><p><strong>蒙版蒙住的内容</strong> 可以理解为把蒙版交给模型时候的内容</p><p>选原图的话采用原图作为重绘底图，通常选这个就好，AI模型发挥空间较小，会比较遵循原图</p><p>选填充，用蒙版边缘像素填充作为重绘底图，则会让AI模型有较大的发挥空间  ，可以综合对比几种方式</p><p><strong>重绘区域</strong></p><p>选仅蒙版 涉及区域小，绘制速度更快，但由于没有读取全貌，有些时候出图会比较奇怪</p><p>选全图，整张输入</p><p>一般情况建议重绘全图</p><p><strong>边缘预留像素</strong>    充当缓冲带作用，可以让新生成的内容与原图更好的融合在一起（一般25-35就行）</p><p>其他设置基于与文生图内操作一致，选择采样方式、迭代步数等，这里建议在使用局部重绘时，要选择与原图一致的设置，从而可以确保重绘效果。</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902115002095.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902115002095.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902115002095"></p><p>点击生![00154-1538941015-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00154-1538941015-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)成</p><h1 id="2-局部重绘其他应用"><a href="#2-局部重绘其他应用" class="headerlink" title="2.局部重绘其他应用"></a>2.局部重绘其他应用</h1><h2 id="2-1-手绘蒙版"><a href="#2-1-手绘蒙版" class="headerlink" title="2.1 手绘蒙版"></a>2.1 手绘蒙版</h2><p><img src="/img%5CStable_diffusion%5Cimage-20230902123316514.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902123316514.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123316514"></p><p>和第1节讲到的局部重绘类似，不同的是，会融入颜色信息</p><p>可以通过颜色选择器可以选取颜色</p><p>我们这里选取红色，给女生画一个红色的帽子</p><p>这里和第1节的提示词，参数设置都一样，就是选取了红色绘制蒙版而已</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902123616396.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902123616396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902123616396"></p><p>点击生成</p><p>![00155-2457917830-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat](00155-2457917830-A beautiful girl blows a bubble, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemat.png)</p><h2 id="2-2-删除某些东西"><a href="#2-2-删除某些东西" class="headerlink" title="2.2 删除某些东西"></a>2.2 删除某些东西</h2><p>只需要将我们想要删除的东西用蒙版画好</p><p>然后在负面提示词里增加删除的东西</p><p>比如我们想让这个女生摘掉眼镜</p><p>![00179-17401323-A beautiful girl, Wear glasses, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemati](00179-17401323-A beautiful girl, Wear glasses, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinemati.png)</p><p>负面提示词里加 戴眼镜</p><p><img src="/img%5CStable_diffusion%5Cimage-20230902153701635.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902153701635.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153701635"></p><p><img src="/img%5CStable_diffusion%5Cimage-20230902153720702.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230902153720702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230902153720702"></p><p>点击生成</p><p>![00158-1817286803-A beautiful girl, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinematic sensual, Sha](00158-1817286803-A beautiful girl, (Studio ghibli style, Art by Hayao Miyazaki_1.2), Anime Style, Manga Style, Hand drawn, cinematic sensual, Sha.png)</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（四）图生图</title>
      <link href="/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/"/>
      <url>/2023/07/20/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/4%20%E5%9B%BE%E7%94%9F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>前段时间有一个风靡全网的真人转漫画风格，受到了大家的喜欢</p><p>而在SD里，就可以通过图生图来实现类似的效果</p><p>当然图生图还有更好玩的应用，我们一点一点来探索</p><p>首先我们来简单进行一下图生图的这一个实践—真人转动漫</p><h2 id="1-图生图基本界面"><a href="#1-图生图基本界面" class="headerlink" title="1. 图生图基本界面"></a>1. 图生图基本界面</h2><p>和文生图基本界面差不多，多了一个上传图像区</p><h2 id="2-图生图步骤"><a href="#2-图生图步骤" class="headerlink" title=" 2.图生图步骤"></a><img src="/img%5CStable_diffusion%5Cimage-20230817104804853.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230817104804853.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817104804853"> 2.图生图步骤</h2><h3 id="2-1-导入图片"><a href="#2-1-导入图片" class="headerlink" title="2.1 导入图片"></a>2.1 导入图片</h3><p>准备一张真人图像</p><p><img src="/img%5CStable_diffusion%5CSnipaste_2023-08-18_22-20-40.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5CSnipaste_2023-08-18_22-20-40.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Snipaste_2023-08-18_22-20-40"></p><p>导入有两种方式</p><p>（1）点击上传图像区，打开资源管理器选取</p><p>（2）直接将图片拖拽到上传图像区</p><h3 id="2-2-写提示词"><a href="#2-2-写提示词" class="headerlink" title="2.2 写提示词"></a>2.2 写提示词</h3><p>提示词很重要，也需要提示词的准确</p><p>用自然语言描述一下我们的画面内容，一开始我们可以偷个懒，就写一个</p><blockquote><p>1man即可</p></blockquote><p>再把我们的固定模板加上</p><blockquote><p>正面提示词后添加：<br>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p></blockquote><blockquote><p>负面提示词后添加：<br>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p></blockquote><h3 id="2-3参数设置"><a href="#2-3参数设置" class="headerlink" title="2.3参数设置"></a>2.3参数设置</h3><p> 图生图参数设置和文生图差不多</p><p>有一个比较独特的就是下面的重绘幅度</p><p><strong>重绘幅度</strong>  ，通俗理解就是他跟原图有多像</p><p>一般我们为了实现这种图生图效果，会降低一些重绘幅度，维持在6-8之间即可，太低或太高都不太好</p><p><strong>图像设置宽高</strong>，一般和我们输入图像大小保持一致</p><p>​如果输入图像太大，显存吃不消，那么我们至少保证比例一致，比如原图是3000*3000像素，那么我们就等比例缩放到1024 *1024</p><p>采样方法选择DPM++2Mkarras</p><p>其他选择和图生图一样，可以维持默认不变</p><p><img src="/img%5CStable_diffusion%5Cimage-20230818224818756.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230818224818756.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818224818756"></p><p>点击生成就可以生成</p><p><img src="/123.png" class="lazyload placeholder" data-srcset="/123.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="123"></p><p>但是发现差别还是蛮大的，原因是我们内容提示词对人物描述不够</p><p>我们把1man 换成 1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,short hair,Blue jeans</p><p>多了更多的服饰，面部细节等的描述，再点击生成</p><p>![00062-262499971-1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,sho](00062-262499971-1man,Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,  looking at viewer,shirt,suits,sho.png)</p><p>整体会好多了</p><h2 id="3-巧用随机种子"><a href="#3-巧用随机种子" class="headerlink" title="3. 巧用随机种子"></a>3. 巧用随机种子</h2><p>如果我们对这个人物整体很满意了，但是一些细节还想微调，我们就要用到随机种子了</p><p>在图片生成区下方，可以查看随机种子</p><p><img src="/img%5CStable_diffusion%5Cimage-20230818230647705.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230818230647705.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818230647705"></p><p>然后把我们的随机种子从-1改为262499971</p><p>这时候我们点击生成，会发现生成的图片几乎和之前的一模一样，不论你点多少次</p><p>然后这时候我们对自己不满意的提示词进行微调，如让男主穿牛仔裤，看向镜头等，再点击生成即可</p><p>![00074-262499971-1man,(Blue jeans_1.1),(black suits_1.1),Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,](00074-262499971-1man,(Blue jeans_1.1),(black suits_1.1),Stay in sunglasses, short beard,put  hands in pants pockets,,sit by the window,outdoors,-1692515162052.png)</p><h2 id="4-拓展应用"><a href="#4-拓展应用" class="headerlink" title="4. 拓展应用"></a>4. 拓展应用</h2><p> 动漫转真人，真人转动漫都是比较好玩的</p><p>当然除了这些，我们还可以把一张本来不是真人的物体，用真人的提示词去进行拟人化</p><p>除此之外还可以</p><p>将随机涂鸦的场景转换为好看的动漫风格图片</p><p>其他关于图生图进阶用法，我们会在另外的文章里讲到</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（三）AI绘画模型基础</title>
      <link href="/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/07/18/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/3%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>想要做出好的AI绘画，模型是最重要的，他相当于AI绘画的大脑，决定了AI绘画质量的上限，所以了解AI绘画的各种模型非常重要</p><p>相比于Midjourney，Stable Diffusion<strong>最大的优势就是开源</strong>。</p><p>因而<strong>SD则每时每刻都有人在世界各地训练自己的模型并免费公开共享给全世界的使用者</strong>。当然我们也可以训练自己的专属模型</p><p>提示词+模型+参数设置</p><p>全能型赛博画手</p><p>首先我们来了解一下模型的基本分类</p><h2 id="1-模型基本分类"><a href="#1-模型基本分类" class="headerlink" title="1.模型基本分类"></a>1.模型基本分类</h2><p>具体模型类型有checkpoint、Textual lnversion、Hypernetwork、Aesthetic Gradient、LoRA、LyCORIS、Controlnet、Poses、wildcards等等</p><p>常用的有checkpoint</p><p>哇塞，这么多，那么这些究竟都是什么意思呢？</p><h3 id="1-1-CheckPoint-大模型-底模型-主模型"><a href="#1-1-CheckPoint-大模型-底模型-主模型" class="headerlink" title="1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型"></a>1.1 CheckPoint 大模型&#x2F;底模型&#x2F;主模型</h3><p>检查点，常玩游戏的朋友肯定不陌生，一般会在一些节点存档</p><p>一个大的模型训练起来是非常费力的，如果每次迭代我们都从头训练那可真实个灾难，因而训练到一定程度我们就给模型存档，生成一个关键点Checkpoint模型，</p><p><strong>常见文件后缀</strong>:后缀ckpt、safetensors（如果都有提供的话建议下载safetensors，下同）</p><p><strong>存放路径</strong>: 根目录\models\Stable-diffusion</p><p><strong>占用存储：</strong> 模型较大，占用3-7GB</p><p>我们这里的根目录都是指我们<strong>webui的最外层的那个文件夹，比如我这里的是stable-diffusion-webui</strong></p><p><strong>使用方法</strong>  将模型移动到根目录\models\Stable-diffusion后，在webui界面点击刷新按钮，再点下拉就可以看到了</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819103854526.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819103854526.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819103854526"></p><p>模型推荐</p><p>二次元模型</p><p>​ menia mix  生成动漫</p><p>​AbyssOrangeMix 深源橘</p><p>​counter-feit v2.5  动漫模型</p><p>​dream Shper v5  模型   肖像画 梦幻的插画风格</p><p>真实系模型</p><p>​realistic vision v2.0 现实模型</p><p>​Delibe-rate   比较全能的一个模型</p><p>在本章第二节可以看到如何利用其他网站来筛选自己需要的模型</p><h3 id="1-2-VAE美化模型-变分自编码器"><a href="#1-2-VAE美化模型-变分自编码器" class="headerlink" title="1.2 VAE美化模型&#x2F;变分自编码器"></a>1.2 VAE美化模型&#x2F;变分自编码器</h3><p>从使用来看，我们可以把他粗略的理解为“调色滤镜”  有些时候不加载VAE的情况下，出图就会发灰发白</p><p>有很多比较新的大模型是会将VAE整合到内部的，比如Chilloutmix。如果再加VAE则可能画面效果不会更好，甚至适得其反</p><p>而有的大模型则会有自己适配的VAE，如深渊橘，这里看模型网站上作者的推荐就好</p><p>也有一些适用于大多数模型的VAE</p><p>二次元风格：kf-f8-anime</p><p>写实风格:840000</p><p><strong>常见文件后缀</strong>:后缀ckpt、pt</p><p><strong>存放路径</strong>: 根目录&#x2F;models&#x2F;VAE</p><p><strong>占用存储：</strong> 模型较小，占用0-1个GB</p><p><strong>使用方法</strong>  将模型移动到根目录\models\VAE后，在VAE选项点击刷新按钮，再点下拉就可以看到了</p><h3 id="1-3-HyperNetwork-超网络"><a href="#1-3-HyperNetwork-超网络" class="headerlink" title="1.3 HyperNetwork 超网络"></a>1.3 HyperNetwork 超网络</h3><p>hypernetworks是一个附加到stable diffusion model上的小型网络，用于微调，和embedings类似，不过现在用的也不是很多了，因为它的功能基本可以被smbeddings替代了</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;models&#x2F;hypernetworks</p><p><strong>占用存储：</strong> 模型较小，占用几百MB</p><p><strong>使用方法</strong>  注意HyperNetwork，embeddings这种微调网络和大模型使用方法不同</p><p>（1）将模型放到  根目录&#x2F;models&#x2F;hypernetworks</p><p>（2）首先点击生成按钮下的从左往右数的第三个，然后点击超网络，再点击需要用到的超网络模型，就会在提示词中添加相应的尖括号内容，如本例中的<hypernet></p><p><img src="/img%5CStable_diffusion%5Cimage-20230820103415473.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820103415473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820103415473"></p><h3 id="1-4-embeddings（-Textual-Inversion）-嵌入式向量"><a href="#1-4-embeddings（-Textual-Inversion）-嵌入式向量" class="headerlink" title="1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量"></a>1.4 embeddings（&#x2F;Textual Inversion） 嵌入式向量</h3><p>（1）优化画风,</p><p>（2）通过仅使用的几张图像，向模型教授新的概念，比如AI不知道奥特曼，通过embeddigns就可以让AI知道奥特曼长什么样子</p><p>（3）减少提示词的输入，比如EasyNegative这个Embeddings，里面包含了大量的负面词，可以减少你每次打一堆负面词的痛苦，解决AI绘画痛点，如画手等等</p><p><strong>常见文件后缀</strong>: 后缀pt</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p>模型的切换通过文件名称来触发</p><p><strong>占用存储：</strong> 模型很小，占用几十kB到几百kB</p><p><strong>使用方法:</strong></p><p>（1）将模型放到  根目录&#x2F;embeddings目录下</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击嵌式入，再点击需要用到的嵌入式模型，就会在提示词中添加相应的尖括号内容</p><h3 id="1-5-loRa-低秩适应模型"><a href="#1-5-loRa-低秩适应模型" class="headerlink" title="1.5 loRa 低秩适应模型"></a>1.5 loRa 低秩适应模型</h3><p>进行人物模型的微调，</p><p>让AI学习到一些新的人物概念</p><p><strong>常见文件后缀</strong>: 后缀safesensors</p><p><strong>存放路径:</strong> 根目录&#x2F;embeddings</p><p><strong>占用存储：</strong> 模型较小，10-200 MB。必须与checkpoint模型一起使用。</p><p><strong>使用方法:</strong> </p><p>（1）将模型放到  根目录&#x2F;models&#x2F;Lora</p><p>（2）同HyperNetwork超网络，首先点击生成按钮下的从左往右数的第三个，然后点击Lora，再点击需要用到的Lora模型，就会在提示词中添加相应的尖括号内容</p><p>除了这些以外还有DreamBooth模型，LyCORIS模型等等，这些模型在模型的进阶用法给大家介绍</p><h2 id="2-下载途径和渠道"><a href="#2-下载途径和渠道" class="headerlink" title="2. 下载途径和渠道"></a>2. 下载途径和渠道</h2><p>SD官方会发布模型</p><p>但是官方这个模型出图风格比较单一，因而我们现在下载使用的大多是私人训练的</p><p>主流下载网站</p><h3 id="2-1-C站"><a href="#2-1-C站" class="headerlink" title="2.1 C站"></a>2.1 C站</h3><p>需要科学上网  C站是最主流的一个AI绘画模型网站了，对于模型都是图像化展示，非常便捷</p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105707494.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105707494.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105707494"></p><h4 id="2-1-1-如何筛选到自己需要的模型"><a href="#2-1-1-如何筛选到自己需要的模型" class="headerlink" title="2.1.1 如何筛选到自己需要的模型"></a><strong>2.1.1 如何筛选到自己需要的模型</strong></h4><p><strong>1 通过模型生成内容区分查找  模型栏目上边有一排可以选择的</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111507513.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111507513.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111507513"></p><p><strong>2 利用我们第一节讲到的模型类型区分</strong></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819111606100.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819111606100.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819111606100"></p><h4 id="2-1-2-使用技巧"><a href="#2-1-2-使用技巧" class="headerlink" title="2.1.2 使用技巧"></a>2.1.2 使用技巧</h4><p>注意模型的各种信息，包括作者推荐的VAE，分辨率设置，采样方式等等</p><p>如我们点击进入ReV Animated这个模型的下载界面，在模型的介绍界面里有show More</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105040732.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105040732.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105040732"></p><p>然后就可以看到作者推荐的VAE啦，提示词prompting啦之类的</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105202493.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105202493.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105202493"></p><p>初学可以使用别人推荐的一些大模型</p><p>[stable diffusion 常用大模型解释和推荐（持续更新ing） - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/631941039#:~:text=stable">https://zhuanlan.zhihu.com/p/631941039#:~:text=stable</a> diffusion 常用大模型解释和推荐（持续更新ing） 1 基础模型（不推荐） SD系列 比如sd-v1-4、sd-v1-5、sd-v2（简写成SD1.5、SD2.0）之类的大模型，这些都是Stable-Diffusion自带的大模型，分别是1.4、1.5和2.0版本。 目前的话1.5版本更好用一些，但是,亚洲美女模型 。 … 4 2.5D%2F数绘风格 PerfectWorld 欧美版的Chilloutmix，主要绘制欧美风格的美女，不过偏2.5D，介于动漫和写实之间。 )</p><h4 id="2-1-3-学习他人作品"><a href="#2-1-3-学习他人作品" class="headerlink" title="2.1.3 学习他人作品"></a>2.1.3 学习他人作品</h4><p>C站除了优秀的模型以外，还会有很多优秀的作品，我们可以学习他们的模型搭配，提示词等等</p><p>点击C站的Images</p><p><img src="/img%5CStable_diffusion%5Cmage-20230820105459668.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cmage-20230820105459668.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105459668"></p><p>点进去以后就可以看到详细的图片生成信息,模型搭配，提示词，采样方式，种子等等</p><p><img src="/img%5CStable_diffusion%5Cimage-20230820105538667.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230820105538667.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230820105538667"></p><h3 id="2-2-HuggingFace"><a href="#2-2-HuggingFace" class="headerlink" title="2.2 HuggingFace"></a>2.2 HuggingFace</h3><p>不需要科学上网，网速较快</p><p><a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a></p><p><img src="/img%5CStable_diffusion%5Cimage-20230819105627701.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230819105627701.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819105627701"></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（二）AI提示词</title>
      <link href="/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/"/>
      <url>/2023/07/16/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/2%20%EF%BC%A1%EF%BC%A9%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>Prompts提示词是指用户输入的指导模型生成图像的文本信息，他是我们要告诉AI 我要画什么，怎么画最方便的方式</p><p>可以想象我们是呼风唤雨的魔法师，那么Promts就好比我们的咒语</p><p>不过有些时候我们的咒语不那么灵验，因为我们的AI绘画具有随机性，所以需要多多尝试</p><p>我们知道AI绘画可以图生图，但是即便图生图也会依赖好的提示词</p><p>接下来我们就从提示词规则，分类等来快速入门提示词</p><p>首先我们来来了解提示词基本规则</p><h2 id="1-提示词-基本的规则"><a href="#1-提示词-基本的规则" class="headerlink" title="1.提示词 基本的规则"></a>1.提示词 基本的规则</h2><p>（1）英文书写  可以求助翻译软件</p><p>（2）词组作为单位，不需要主谓宾句子结构</p><p>​比如画一个在阳光下骑车的男孩</p><p>​提示词写为  男孩，骑车，阳光下即可</p><p>（3）提示词分隔符英文逗号，</p><p>（4）提示词可以换行，但每一行结尾要打上分隔符,</p><h2 id="2-提示词分类"><a href="#2-提示词分类" class="headerlink" title="2.提示词分类"></a>2.提示词分类</h2><p>提示词不是一下子写好的，是先有雏形，然后再慢慢微调得到的</p><p>提示词也不是混乱不堪的，优秀的提示词分别包含以下内容，我们可以按照顺序依次填写自己需要的</p><h3 id="2-1内容性提示词"><a href="#2-1内容性提示词" class="headerlink" title="2.1内容性提示词"></a>2.1内容性提示词</h3><p>内容性提示词实际上就是告诉AI绘画我们要画什么</p><p><strong>人类以及主体</strong></p><p>​服饰穿搭 pink dress,</p><p>​发型发色  long hair  black hair</p><p>​五官特点 big eyes,small mouth</p><p>​面部表情  laughing</p><p>​肢体动作  stretching arms</p><p><strong>场景特征</strong></p><p>​室内  indoor</p><p>​室外  outdoor</p><p>​大场景 forest，city</p><p>​小细节 bush, a white flower</p><p><strong>环境光照</strong></p><p>​白天   day</p><p>​黑夜   night</p><p>​特定时段  morning</p><p>​光环境  sunlight</p><p>​天空  blue sky</p><h3 id="2-2-画风艺术派提示词"><a href="#2-2-画风艺术派提示词" class="headerlink" title="2.2 画风艺术派提示词"></a>2.2 画风艺术派提示词</h3><p>​插画风illustration </p><p>​二次元   anime ，comic ，game CG</p><p>​写实系   photo realistic，realistic，photograph</p><h3 id="2-3-画幅视角"><a href="#2-3-画幅视角" class="headerlink" title="2.3 画幅视角"></a>2.3 <strong>画幅视角</strong></h3><p>​距离  close-up,distant</p><p>​人物比例   full body,upper body</p><p>​观察视角   from above,view of back</p><p>​镜头类型  wide angle m Sony A7 III</p><h3 id="2-4画质提示词"><a href="#2-4画质提示词" class="headerlink" title="2.4画质提示词"></a>2.4画质提示词</h3><p>通用高画质</p><p>​best quailty</p><p>​ultra-detailed</p><p>​masterpiece</p><p>​hires</p><p>​8k</p><p>特定高分辨率类型</p><p>​extremely detailed CG unity 8k wallpaper （超精细8k Unity 游戏CG）</p><p>​unreal engine rendered（虚幻引擎渲染）</p><h2 id="3-反向提示词"><a href="#3-反向提示词" class="headerlink" title="3 反向提示词"></a>3 反向提示词</h2><h3 id="3-1-内容性反向提示词"><a href="#3-1-内容性反向提示词" class="headerlink" title="3.1 内容性反向提示词"></a>3.1 内容性反向提示词</h3><p>single background 单一背景</p><p> bad hands 不好的手</p><p>missing fingers 缺少手指</p><p>bad anatomy 身体姿态不良</p><p>long neck 长脖子</p><p>mutated hands 突变的手</p><p>poorly drawn hands 画的不好的手</p><p>poorly drawn face 画的不好的脸</p><p>missing arms 缺少手臂</p><p>missing legs 缺少腿</p><p> extra arms 缺少胳膊</p><p>extra legs 缺少腿</p><h3 id="3-2-画质性反向提示词"><a href="#3-2-画质性反向提示词" class="headerlink" title="3.2 画质性反向提示词"></a>3.2 画质性反向提示词</h3><p>worst quality, 最差质量</p><p>low quality 低质量</p><p>上述大概了解有哪些，我们后续会对于一些人物有一些特定模板可以直接用</p><h2 id="4-实例分析"><a href="#4-实例分析" class="headerlink" title="4 实例分析"></a>4 实例分析</h2><p><strong><img src="/img%5CStable_diffusion%5Cimage-20230817101306166.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230817101306166.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230817101306166"></strong></p><p>正向提示词</p><blockquote><p>&lt;!–swig￼0–&gt;, &lt;!–swig￼1–&gt;,<br> little girl, grey long hair , blue eyes, shirt, hat, hoodie, shoes , headphones, smirk, cute face, head tilt,<br>outdoor, forest,bush,  sunlight,<br>illustration,<br>full body</p></blockquote><p>反向提示词</p><blockquote><p>signature, watermark, username, blurry, missing arms, long neck, humpbacked, bad feet, {bad anatomy},single background, {bad hands},missing fingers,<br>{lowres}, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, artifacts, nsfw,</p></blockquote><p>一般而言，优质出图有一定的固定模板</p><h2 id="5-权重"><a href="#5-权重" class="headerlink" title="5 权重"></a>5 权重</h2><p>观察别人的提示词咒语，会发现有很多的括号</p><h3 id="5-1-方法一"><a href="#5-1-方法一" class="headerlink" title="5.1 方法一"></a>5.1 方法一</h3><p><strong>括号加数字</strong></p><p>​示例：</p><p>​{a white flower :1.5} 调节白花权重为原来1.5倍</p><p>​{white flower:  0.8} 调节白花权重为 0.8倍</p><h3 id="5-2-方法二"><a href="#5-2-方法二" class="headerlink" title="5.2 方法二"></a>5.2 方法二</h3><p><strong>套括号</strong></p><p> 适合于微调</p><p>提示词套圆括号（）</p><p>​每一层圆括号，权重×1.1</p><p>​比如两层圆括号，提示词权重1.1 *1.1&#x3D;1.331</p><p>提示词套大括号{}</p><p>​每一层大括号，权重×1.05</p><p>提示词套方括号[]</p><p>​每一层大括号，权重×0.9</p><p>经验：权重不能太高，最好小于1.5，否则会导致扭曲</p><p>提示词权重分配 进阶语法</p><p>​如混合，迁移，迭代</p><p>后面会给大家介绍</p><h2 id="6-参数"><a href="#6-参数" class="headerlink" title="6.参数"></a>6.参数</h2><p>如果把提示词比作咒语，那么参数是魔杖或者魔导书</p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>理论上采样步数越多画面越清晰，但超过２０步之后，后面的提升不大，增加步数意味着出图时间增长，一般维持在２０到４０之间即可</p><p>以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="7-学习and-技巧"><a href="#7-学习and-技巧" class="headerlink" title="7. 学习and 技巧"></a>7. 学习and 技巧</h2><p>当然知道上面的知识还远远不够，需要多多学习他人写提示词的方式</p><p>写提示词</p><p>翻译大法，插件</p><p>利用AI工具  AI绘画提示词生成器，AI词语加速器</p><p>选择性  抄作业    openart.ai     arthub.ai</p><h3 id="7-1-辅助写提示词的网站"><a href="#7-1-辅助写提示词的网站" class="headerlink" title="7.1 辅助写提示词的网站"></a>7.1 辅助写提示词的网站</h3><p>（1）AI绘画提示词生成器</p><p><a href="http://www.atoolbox.net/Tool.php?Id=1101">AI绘画提示词生成器 - 一个工具箱 - 好用的在线工具都在这里！ (atoolbox.net)</a></p><p>（2）AI 词汇加速器</p><p><a href="https://ai.dawnmark.cn/">AI词汇加速器 AcceleratorI Prompt (dawnmark.cn)</a>权重设置</p><p>使用这些工具像是经历一个更方便的过程，但思路不要被他索限制</p><p>（3）词图</p><p><a href="https://www.prompttool.com/NovelAI">词图PromptTool - AI绘画</a></p><p>（4）AI创造者</p><p><a href="https://ai-creator.net/arts">AI creator - AI Creator|AI Art gallery | 创作者AI (ai-creator.net)</a></p><h3 id="7-2-学习他人优秀作品"><a href="#7-2-学习他人优秀作品" class="headerlink" title="7.2 学习他人优秀作品"></a>7.2 学习他人优秀作品</h3><p>有很多网站会放出优秀作品，其中的作者也会分享自己的prmpts，可供我们学习</p><p>（1） openart.ai   </p><p>​里面有很多基于sd官方模型和欧美模型的生成的作品</p><p>​<a href="https://openart.ai/home">Home | OpenArt</a></p><p>  （2）arthub.ai</p><p>​里面更多一些二次元和亚洲风的作品</p><p><a href="https://arthub.ai/">Arthub.ai: Discover, Upload and Share AI Generated Art</a></p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stable Diffusion（一）AI绘画quickly入门</title>
      <link href="/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/14/AI%E5%BA%94%E7%94%A8/Stable_Diffusion/1%20AI%E7%BB%98%E7%94%BBquickly%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><p>​在2012年，就有很多的学者对图像生成展开了研究，但在那时候，因为算法，数据，算力等各方面原因，生成的图像过于“抽象” ，可以称他为灵魂画手，直到最近两年，AI产出的图像内容在质量上和准确度上渐渐地变得更高，同时由于一些辅助装备，如ControlNet等让AI绘画可控性更高，也更受到大家的重视。</p><p>​现在的主流的AI绘画模型，主要运用了扩散Diffusion模型，他很人类绘画相比差异很大，不是起稿，勾线，描边，上色等步骤按部就班完成的，他采取了一个独特的方式</p><p>首先它将图片通过增加噪声的方式进行“扩散”，也就是让他变得更模糊，当内容模糊之后，我们就可以理解为有更大的空间让它自由发挥了，AI也是如此，但是在训练它的过程中，它可以学习到一种重要的能力，就是逐步恢复这种杂乱的噪声为真实图像</p><p>而如果在训练的过程中我们给AI 一些限制条件等，AI就可以按我们限制条件去恢复生成我们想要的图像了</p><h2 id="2-主流方式"><a href="#2-主流方式" class="headerlink" title="2.主流方式"></a>2.主流方式</h2><p><strong>Midjourney，DALL E等方式</strong></p><p>​（1）出图额度需要购买会员（换句话说就是需要付费）直接租价格比较贵，可以去租用共享账号</p><p>​（2）较容易出比较高质量的图</p><p>​（3）模型部署在云端，不需要本地电脑配置较高</p><p><strong>Stable Diffusion</strong></p><p>​（1）是一款免费的软件，可以无限制出图</p><p>​（2）但是有一定的上手门槛，出图质量需要较多的调控才能达到满意的效果，因而我们这系列教程主要围绕stable diffusion</p><p>​（3）部署在本地，比较吃电脑配置，显卡内存（也可以部署在GPU服务器）</p><p>​（4）但是由于开源，依托强大的开源社区，收获非常多的活跃用户，可以进行个性化的训练，个性化程度较高</p><h2 id="3-配置要求"><a href="#3-配置要求" class="headerlink" title="3.配置要求"></a>3.配置要求</h2><h3 id="3-1-显卡方面"><a href="#3-1-显卡方面" class="headerlink" title="3.1 显卡方面"></a>3.1 显卡方面</h3><p><strong>显卡品牌型号</strong> N卡（英伟达的独立显卡）首选，目前也支持A卡，但是速度较N卡慢</p><p>不同品牌型号，意味着显卡的算力不同，进而影响着出图的速度</p><p>查看自己的显卡品牌型号的方法如下链接  AI应用\Stable_Diffusion\image-20230814163822829.png</p><p><a href="https://zhuanlan.zhihu.com/p/462233007">分享几种查看本机显卡类型的方法~~ - 知乎 (zhihu.com)</a></p><p>查到以后可以对照下表 ，下表是不同型号N卡出一张512*512分辨率的图片，迭代步数为100步的时间 </p><p><img src="/img%5CStable_diffusion%5Cimage-20230814163822829.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814163822829.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815210656999"></p><p>图片来源 B站 Nenly同学</p><p><strong>显卡内存</strong>  最少8GB能玩，16GB及格，上不封顶，越高玩的越爽        内存主要影响着出图分辨率，模型大小等</p><p><strong>硬盘空间</strong>  最少有60GB以上的硬盘空间，因为我们需要下载很多模型，而一个模型往往都有几个GB</p><h2 id="4-基本界面"><a href="#4-基本界面" class="headerlink" title="4.基本界面"></a>4.基本界面</h2><p>下面界面是加了一些插件之后的，如中文插件，图库浏览器，如果你使用的是一些大佬的整合包，那么一般他们都会帮助你安装好，但是如果没有也无所谓，我们会在之后给大家讲解插件的安装</p><p><img src="/img%5CStable_diffusion%5Cimage-20230814164648622.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814164648622.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164648622"></p><h3 id="4-1-模型设置区"><a href="#4-1-模型设置区" class="headerlink" title="4.1 模型设置区"></a>4.1 模型设置区</h3><p>左上角用来更换模型</p><p><img src="/img%5CStable_diffusion%5Cimage-20230814164736337.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814164736337.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814164736337"></p><p>点击下拉箭头查看并且选择模型</p><p>模型需要我们提前下载并且保存到    根目录&#x2F;models&#x2F;Stable-diffusion文件夹下</p><p>当我们保存模型到上述文件夹下后，点击蓝色的刷新按钮，刷新模型，再点击下拉箭头就可以看到我们的模型了</p><h3 id="4-2-菜单栏区域"><a href="#4-2-菜单栏区域" class="headerlink" title="4.2 菜单栏区域"></a>4.2 菜单栏区域</h3><p><img src="/img%5CStable_diffusion%5Cimage-20230814165333774.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230814165333774.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814165333774"></p><p>一些基本功能</p><p>最常用的两个 文生图，图生图</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>文生图</td><td>由prompts提示词生成图片</td></tr><tr><td>图生图</td><td>由已有的图片+提示词生成图片</td></tr><tr><td>图库浏览器（后安装的插件）</td><td>查看生成的图片</td></tr><tr><td>Tag 反推</td><td>由图片反推提示词prompts</td></tr><tr><td>设置</td><td>进行一些设置操作</td></tr><tr><td>扩展</td><td>进行扩展安装管理等操作</td></tr></tbody></table><p>其他我们用到的时候再介绍</p><h3 id="4-3-提示词区"><a href="#4-3-提示词区" class="headerlink" title="4.3 提示词区"></a>4.3 提示词区</h3><p>最关键的一个区域，也就是我们念咒语的地方，这里用英语撰写（可以用翻译软件）</p><p><strong>正向提示词</strong>  希望画面出现的内容，一般我们会有一些固定的提示词，如（杰作masterpiece, 最高质量best quality，高细节）特定模型也会有特定的让画面质量变高的正向提示词</p><p><strong>反向提示词</strong>  不希望画面出现的内容，如（丑陋的，多手指的）</p><p>之后会给大家专门总结，到时候直接复制粘贴即可</p><p>提示词区右边的生成下边有五个小图标，相当于一些快捷键，从左到右依次为</p><p><img src="/img%5CStable_diffusion%5Cimage-20230815211951592.png" class="lazyload placeholder" data-srcset="/img%5CStable_diffusion%5Cimage-20230815211951592.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815211951592"></p><table><thead><tr><th>图标</th><th>作用</th></tr></thead><tbody><tr><td>箭头</td><td>复原上次生成图片的提示词（自动记录）</td></tr><tr><td>垃圾桶</td><td>清空当前所有提示词</td></tr><tr><td>红色日出</td><td>打开其他模型选择界面如Embedding，HypernetWork的选择，这些模型后面会单独讲到</td></tr><tr><td>记事薄</td><td>应用选择的风格模板到当前提示词，就是着五个小图标下面那个风格模板选项</td></tr><tr><td>保存按钮</td><td>保存当前的正反向提示词</td></tr></tbody></table><h3 id="4-4-出图设置区"><a href="#4-4-出图设置区" class="headerlink" title="4.4 出图设置区"></a>4.4 出图设置区</h3><p>如图</p><img src="img\Stable_diffusion\image-20230814165739102.png" class="lazyload placeholder" data-srcset="img\Stable_diffusion\image-20230814165739102.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img\Stable_diffusion\image-20230814165739102" style="zoom: 67%;" /><p><strong>从上到下，左到右依次介绍</strong></p><p><strong>采样方法</strong></p><p>​采样方法具体是什么涉及到模型原理，不必深究，我们这里只需要知道什么时候用什么样的采样方法即可，一般遵循如下原则</p><p>​（1）在显卡给力，时间充裕的条件下，可以自己尝试比较不同的采样方法</p><p>​（2）一般在C站下载模型的同时，模型作者会给出他觉得比较好的采样方式，这是作者已经经过大量实验的结论，可以帮助你节约时间</p><p>​（3）没有作者相关建议的时候</p><p>​对于二次元图  DPM++ 2M或DPM++ 2M Karras  UniPC</p><p>​对于真实系图 Euler a、DPM++ SDE、DPM++ SDE Karras</p><p>​同时，一般而言带++的都相对来说不戳</p><p><strong>迭代采样步数</strong></p><p>之前讲原理的时候，模型将噪声一步一步恢复到真实图片，此参数控制这些去噪步骤的数量。通常越高越好，但在一定程度上，我们使用的默认值是25个步骤。以下是不同情况下使用哪个步骤编号的一般指南：</p><p>​（1）如果正在测试新的提示，并希望获得快速结果来调整您的输入，请使用10-15个步骤</p><p>​（2）当您找到您喜欢的提示时，请将步骤增加到25</p><p>​（3）如果是有毛皮的动物或有纹理的主题，生成的图像缺少一些细节，尝试将其提高到40</p><p><strong>面部修复</strong>：修复人物的面部，但是非写实风格的人物开启面部修复可能导致面部崩坏。<br><strong>平铺&#x2F;分块</strong>：生成一张可以平铺的图像<br><strong>高分辨率重绘</strong>：使用两个步骤的过程进行生成，以较小的分辨率创建图像，然后在不改变构图的情况下改进其中的细节，选中后会有新的参数，之后专门出一篇介绍</p><p><strong>宽度高度</strong> 出图分辨率设置  最佳的范围应在512至768像素之间</p><p>设置的出图分辨率太低，会导致图像不清晰</p><p>设置的出图的分辨率过高，一方面显存支撑不了，另外一方面可能会导致图像生成多人情况，</p><p><strong>生成批次</strong>：每次生成图像的组数。<br><strong>每批数量</strong>：每组多少个图像。图像总数是这个值乘以批次数。除 4090 等高级显卡以外通常保持为 1</p><p><strong>提示词相关性CFG</strong>：较高的数值将提高生成结果与提示的匹配度。<br>OpenArt上使用的默认CFG是7，这在创造力和生成你想要的东西之间提供了最佳平衡。通常不建议低于5。<br>CFG量表可以分为不同的范围，每个范围都适合不同的提示类型和目标<br>CFG 2 – 6：有创意，但可能太扭曲，没有遵循提示。对于简短的提示来说，可以很有趣和有用<br>CFG 7-10：推荐用于大多数提示。创造力和引导一代之间的良好平衡<br>CFG 10-15：当您确定您的提示是详细且非常清晰的，您希望图像是什么样子时<br>CFG 16-20：除非提示非常详细，否则通常不推荐。可能影响一致性和质量<br>CFG &gt;20：几乎无法使用</p><p><strong>随机种子（Seed）</strong>:生成每张图片时的随机种子，这个种子是用来作为确定扩散初始状态的基础。不懂的话，用随机的即可。</p><h2 id="5-文生图基本操作流程"><a href="#5-文生图基本操作流程" class="headerlink" title="5.文生图基本操作流程"></a>5.文生图基本操作流程</h2><p>我们可能一下子了解不了这么多，大家可能都看困了，那么我们来亲自来出一张图，体验一下基本的过程，加深印象</p><h3 id="5-1-选用模型，撰写提示词"><a href="#5-1-选用模型，撰写提示词" class="headerlink" title="5.1 选用模型，撰写提示词"></a>5.1 选用模型，撰写提示词</h3><p>在左上角模型选取，选择深渊橘模型</p><p><strong>写提示词</strong></p><p><strong>画面内容</strong> 用自己的语言描述一个画面出来</p><p>如  一个女生在城市里骑着自行车，阳光洒在她的身上，但是提示词不认中文打开翻译软件，翻译即可</p><p>A girl rides a bicycle in the city, and the sunlight  shines on her</p><p>但仅有这个远远不够，不相信？给你看一下这样<strong>图片直出 有多离谱</strong></p><p>点击生成，喀嚓，生成如下</p><p>![00061-202973728-A girl rides a bicycle in the city and the sunlight  shines on her_b7c2db5a94e11e2b3e236598b41eaad053a308d7](00061-202973728-A girl rides a bicycle in the city and the sunlight  shines on her_b7c2db5a94e11e2b3e236598b41eaad053a308d7.png)</p><p>惨不忍睹，所以还需要加一些正面对画面质量这些约束的咒语</p><p><strong>在正向提示框加入</strong></p><p>SFW, (masterpiece:1,2), best quality, masterpiece, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</p><p><strong>反向提示框加入</strong></p><p>NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, missing fingers, (((extra arms and legs))),</p><h3 id="5-2-进行出图设置"><a href="#5-2-进行出图设置" class="headerlink" title="5.2 进行出图设置"></a>5.2 进行出图设置</h3><p>我们就将采样方式设置为 DPM++ 2M</p><h3 id="5-3-再次出图！"><a href="#5-3-再次出图！" class="headerlink" title="5.3 再次出图！"></a>5.3 再次出图！</h3><p>![00068-300861399-A girl rides a bicycle in the city, and the sunlight  shines on her_SFW, (masterpiece_1,2), best quality, masterpiece, highres,](00068-300861399-A girl rides a bicycle in the city, and the sunlight  shines on her_SFW, (masterpiece_1,2), best quality, masterpiece, highres,.png)</p><p>不能说有多好，但至少比刚才好了一些，当然后续还会介绍更多技巧提升画面质量</p><p>所以我们要意识到一点， stable diffusion 出一张好图是不容易的，这也是为什么显卡这些的重要性，它可以让我们低成本试错</p><h3 id="5-4-保存"><a href="#5-4-保存" class="headerlink" title="5.4 保存"></a>5.4 保存</h3><p>点击图库浏览器，可以查看生成的图片</p><p>想把他导出来</p><p>右键，另存为即可</p><p>或者找到根目录下的outputs文件夹</p>]]></content>
      
      
      <categories>
          
          <category> Stable Diffusion </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/2020/09/14/categories/index/"/>
      <url>/2020/09/14/categories/index/</url>
      
        <content type="html"><![CDATA[<p>这里有我写过的相关的系列的文章，欢迎系统阅读！<br>如果对你有任何问题，可以给我反馈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/2020/09/14/tags/index/"/>
      <url>/2020/09/14/tags/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分类器整体</title>
      <link href="/2020/09/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/"/>
      <url>/2020/09/14/AI%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/0%20%E5%88%86%E7%B1%BB%E5%99%A8%E6%95%B4%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图像表示"><a href="#1-图像表示" class="headerlink" title="1 图像表示"></a>1 图像表示</h2><ul><li>基础像素表示</li><li>全局特征表示 如GIST    比较适合风景类，室内场景，城市建筑。要依赖所有像素，对于如遮挡一类问题就不太适合了</li><li>局部特征表示 如GIST</li></ul><p>2012年前，就要找到一个很好的特征，但对于神经网路而言是无所谓的</p><h2 id="2-分类模型"><a href="#2-分类模型" class="headerlink" title="2 分类模型"></a>2 分类模型</h2><p>我们学习神经网络在学些什么？</p><p>其实就是在学</p><ol><li>这每一类分类器的优势，适用于哪些场合</li><li>这每一类分类器的原理，从而我们对于分类器做出合理的调整来解决具体问题</li></ol><p>常见分类器</p><ul><li>近邻分类器</li><li>贝叶斯分类器</li><li>线性分类器</li><li>支撑向量机分类器</li><li>神经网络分类器</li><li>随机森林</li><li>Adaboost<br>sd</li></ul><h2 id="3-损失函数"><a href="#3-损失函数" class="headerlink" title="3 损失函数"></a>3 损失函数</h2><p>常见的损失函数</p><ul><li>0-1 损失</li><li>多类支撑向量机损失</li><li>交叉熵损失</li><li>L1损失</li><li>L2损失</li></ul><h2 id="4-优化方法"><a href="#4-优化方法" class="headerlink" title="4 优化方法"></a>4 优化方法</h2><p>一阶方法</p><ul><li>梯度下降</li><li>随机梯度下降</li><li>小批量随机梯度下降</li></ul><p>二阶方法</p><ul><li>牛顿法</li><li>BFGS</li><li>L-BFGS</li></ul><p>训练过程本身</p><ul><li>数据集划分</li><li>数据预处理</li><li>数据增强</li><li>欠拟合与过拟合</li><li>超参数调整</li><li>模型集成<img src="/img%5C1.jpg" class="lazyload placeholder" data-srcset="/img%5C1.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1"></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经典深度神经网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
